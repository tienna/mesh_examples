"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PersistentAuthenticator_instances, _PersistentAuthenticator_requestAccess, _PersistentAuthenticator_storage, _PersistentAuthenticator_logger, _PersistentAuthenticator_originsReady, _PersistentAuthenticator_store;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PersistentAuthenticator = void 0;
const util_1 = require("../util");
class PersistentAuthenticator {
    constructor({ requestAccess }, { logger, storage }) {
        _PersistentAuthenticator_instances.add(this);
        _PersistentAuthenticator_requestAccess.set(this, void 0);
        _PersistentAuthenticator_storage.set(this, void 0);
        _PersistentAuthenticator_logger.set(this, void 0);
        _PersistentAuthenticator_originsReady.set(this, void 0);
        __classPrivateFieldSet(this, _PersistentAuthenticator_requestAccess, requestAccess, "f");
        __classPrivateFieldSet(this, _PersistentAuthenticator_storage, storage, "f");
        __classPrivateFieldSet(this, _PersistentAuthenticator_logger, logger, "f");
        __classPrivateFieldSet(this, _PersistentAuthenticator_originsReady, storage.get(), "f");
    }
    async requestAccess(sender) {
        const origin = (0, util_1.senderOrigin)(sender);
        if (!origin) {
            __classPrivateFieldGet(this, _PersistentAuthenticator_logger, "f").warn('Invalid sender url', sender);
            return false;
        }
        const origins = await __classPrivateFieldGet(this, _PersistentAuthenticator_originsReady, "f");
        if (origins.includes(origin)) {
            return true;
        }
        try {
            const accessGranted = await __classPrivateFieldGet(this, _PersistentAuthenticator_requestAccess, "f").call(this, sender);
            if (accessGranted) {
                const newOrigins = [...origins, origin];
                if (await __classPrivateFieldGet(this, _PersistentAuthenticator_instances, "m", _PersistentAuthenticator_store).call(this, newOrigins)) {
                    __classPrivateFieldGet(this, _PersistentAuthenticator_logger, "f").info('[Authenticator] added', origin);
                    return true;
                }
            }
        }
        catch (error) {
            __classPrivateFieldGet(this, _PersistentAuthenticator_logger, "f").error('[Authenticator] requestAccess failed', error);
        }
        return false;
    }
    async revokeAccess(sender) {
        const origin = (0, util_1.senderOrigin)(sender);
        if (!origin) {
            __classPrivateFieldGet(this, _PersistentAuthenticator_logger, "f").warn('Invalid sender url', sender);
            return false;
        }
        const origins = await __classPrivateFieldGet(this, _PersistentAuthenticator_originsReady, "f");
        const idx = origins.indexOf(origin);
        if (idx >= 0) {
            const newOrigins = [...origins.slice(0, idx), ...origins.slice(idx + 1)];
            if (await __classPrivateFieldGet(this, _PersistentAuthenticator_instances, "m", _PersistentAuthenticator_store).call(this, newOrigins)) {
                __classPrivateFieldGet(this, _PersistentAuthenticator_logger, "f").info('[Authenticator] revoked access for', origin);
                return true;
            }
        }
        else {
            __classPrivateFieldGet(this, _PersistentAuthenticator_logger, "f").warn('[Authenticator] attempted to revoke access for unknown origin', origin);
        }
        return false;
    }
    async haveAccess(sender) {
        const origin = (0, util_1.senderOrigin)(sender);
        if (!origin)
            return false;
        const origins = await __classPrivateFieldGet(this, _PersistentAuthenticator_originsReady, "f");
        return origins.includes(origin);
    }
    async clear() {
        await __classPrivateFieldGet(this, _PersistentAuthenticator_instances, "m", _PersistentAuthenticator_store).call(this, []);
    }
}
exports.PersistentAuthenticator = PersistentAuthenticator;
_PersistentAuthenticator_requestAccess = new WeakMap(), _PersistentAuthenticator_storage = new WeakMap(), _PersistentAuthenticator_logger = new WeakMap(), _PersistentAuthenticator_originsReady = new WeakMap(), _PersistentAuthenticator_instances = new WeakSet(), _PersistentAuthenticator_store = async function _PersistentAuthenticator_store(origins) {
    try {
        await __classPrivateFieldGet(this, _PersistentAuthenticator_storage, "f").set(origins);
        __classPrivateFieldSet(this, _PersistentAuthenticator_originsReady, Promise.resolve(origins), "f");
        return true;
    }
    catch (error) {
        __classPrivateFieldGet(this, _PersistentAuthenticator_logger, "f").error('[Authenticator] storage.set failed', error);
        return false;
    }
};
//# sourceMappingURL=PersistentAuthenticator.js.map