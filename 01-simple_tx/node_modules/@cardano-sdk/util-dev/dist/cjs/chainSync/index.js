"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.chainSyncData = exports.ChainSyncDataSet = void 0;
const core_1 = require("@cardano-sdk/core");
const rxjs_1 = require("rxjs");
const util_1 = require("@cardano-sdk/util");
const genesisToEraSummary_1 = require("./genesisToEraSummary");
const memoize_js_1 = __importDefault(require("lodash/memoize.js"));
__exportStar(require("./genesisToEraSummary"), exports);
const intersect = (events, points) => {
    const blockPoints = points.filter((point) => point !== 'origin');
    if (blockPoints.length === 0) {
        if (points.length === 0) {
            throw new core_1.ChainSyncError(core_1.ChainSyncErrorCode.IntersectionNotFound, { points, tip: events[0].tip }, 'Intersection not found');
        }
        return {
            events,
            intersection: {
                point: 'origin',
                tip: events[0].tip
            }
        };
    }
    const remainingEvents = [...events];
    let eventsSinceIntersection = [];
    let evt;
    while ((evt = remainingEvents.pop())) {
        if (evt.eventType !== core_1.ChainSyncEventType.RollForward) {
            eventsSinceIntersection = [evt, ...eventsSinceIntersection];
            continue;
        }
        const { block: { header } } = evt;
        const point = blockPoints.find(({ hash }) => header.hash === hash);
        if (point) {
            return {
                events: eventsSinceIntersection,
                intersection: {
                    point,
                    tip: eventsSinceIntersection.length > 0
                        ? eventsSinceIntersection[eventsSinceIntersection.length - 1].tip
                        : header
                }
            };
        }
        eventsSinceIntersection = [evt, ...eventsSinceIntersection];
    }
    if (points.includes('origin')) {
        return {
            events,
            intersection: {
                point: 'origin',
                tip: events[0].tip
            }
        };
    }
    throw new core_1.ChainSyncError(core_1.ChainSyncErrorCode.IntersectionNotFound, { points, tip: events[0].tip }, 'Intersection not found');
};
var ChainSyncDataSet;
(function (ChainSyncDataSet) {
    ChainSyncDataSet["PreviewStakePoolProblem"] = "preview-stake-pool-problem.json";
    ChainSyncDataSet["AssetNameUtf8Problem"] = "asset-name-utf8-problem.json";
    ChainSyncDataSet["MissingExtraDatumMetadataProblem"] = "missing-extra-datum-metadata-problem.json";
    ChainSyncDataSet["ExtraDataNullCharactersProblem"] = "extra-data-null-characters-problem.json";
    ChainSyncDataSet["WithPoolRetirement"] = "with-pool-retirement.json";
    ChainSyncDataSet["WithStakeKeyDeregistration"] = "with-stake-key-deregistration.json";
    ChainSyncDataSet["WithMint"] = "with-mint.json";
    ChainSyncDataSet["WithHandle"] = "with-handle.json";
    ChainSyncDataSet["WithInlineDatum"] = "with-inline-datum.json";
})(ChainSyncDataSet = exports.ChainSyncDataSet || (exports.ChainSyncDataSet = {}));
exports.chainSyncData = (0, memoize_js_1.default)((dataSet) => {
    const { body: allEvents, metadata: { cardano: { compactGenesis } } } = (0, util_1.fromSerializableObject)(require(`./data/${dataSet}`));
    const eraSummaries = [(0, genesisToEraSummary_1.genesisToEraSummary)(compactGenesis)];
    const cardanoNode = {
        eraSummaries$: (0, rxjs_1.of)(eraSummaries),
        findIntersect: (points) => {
            const { intersection, events } = intersect(allEvents, points);
            return (0, rxjs_1.of)({
                chainSync$: new rxjs_1.Observable((subscriber) => {
                    const remainingEvents = [...events];
                    const requestNext = () => {
                        const nextEvent = remainingEvents.shift();
                        if (nextEvent) {
                            subscriber.next({
                                ...nextEvent,
                                requestNext: () => setTimeout(requestNext, 1)
                            });
                        }
                        else {
                            subscriber.complete();
                        }
                    };
                    requestNext();
                }),
                intersection
            });
        },
        genesisParameters$: (0, rxjs_1.of)(compactGenesis),
        healthCheck$: new rxjs_1.Observable(),
        submitTx: () => (0, rxjs_1.throwError)(() => new core_1.GeneralCardanoNodeError(core_1.GeneralCardanoNodeErrorCode.Unknown, null, 'submitTx is not implemented'))
    };
    return {
        allEvents,
        cardanoNode,
        networkInfo: {
            eraSummaries,
            genesisParameters: compactGenesis
        }
    };
});
//# sourceMappingURL=index.js.map