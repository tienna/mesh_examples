var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SdkCom_httpUrl, _SdkCom_apiVersion, _SdkCom_k6Http;
export var Environment;
(function (Environment) {
    Environment["dev"] = "dev";
    Environment["ops"] = "ops";
    Environment["staging"] = "staging";
    Environment["live"] = "live";
})(Environment || (Environment = {}));
export var Network;
(function (Network) {
    Network["mainnet"] = "mainnet";
    Network["preprod"] = "preprod";
    Network["preview"] = "preview";
    Network["sanchonet"] = "sanchonet";
})(Network || (Network = {}));
export const getDut = (k6Env, options) => {
    const allowedEnvironments = new Set([
        Environment.dev,
        Environment.ops,
        Environment.staging,
        Environment.live
    ]);
    const allowedNetworks = new Set([Network.mainnet, Network.preprod, Network.preview, Network.sanchonet]);
    const allowedOptions = new Set(['environments', 'networks']);
    const { TARGET_ENV, TARGET_NET, DUT } = k6Env;
    if (!(TARGET_ENV && TARGET_NET) && !DUT)
        throw new Error('Please specify both TARGET_ENV and TARGET_NET or DUT (Domain Under Test');
    let urlEnvironments = [...allowedEnvironments];
    let urlNetworks = [...allowedNetworks];
    if (options) {
        if (typeof options !== 'object')
            throw new Error(`${typeof options}: not allowed type for options`);
        for (const option of Object.keys(options))
            if (!allowedOptions.has(option))
                throw new Error(`${options}: not allowed option`);
        const { environments, networks } = options;
        switch (typeof environments) {
            case 'undefined':
                break;
            case 'object':
                if (!Array.isArray(environments))
                    throw new Error('options.environments must be an array');
                for (const environment of environments)
                    if (!allowedEnvironments.has(environment))
                        throw new Error(`${environment}: not allowed environment`);
                urlEnvironments = environments;
                break;
            default:
                throw new Error(`${typeof environments}: not allowed type for options.environments`);
        }
        switch (typeof networks) {
            case 'undefined':
                break;
            case 'object':
                if (!Array.isArray(networks))
                    throw new Error('options.networks must be an array');
                for (const network of networks)
                    if (!allowedNetworks.has(network))
                        throw new Error(`${network}: not allowed network`);
                urlNetworks = networks;
                break;
            default:
                throw new Error(`${typeof networks}: not allowed type for options.networks`);
        }
    }
    if (TARGET_ENV && !urlEnvironments.includes(TARGET_ENV))
        throw new Error(`${TARGET_ENV}: not allowed environment`);
    if (TARGET_NET && !urlNetworks.includes(TARGET_NET))
        throw new Error(`${TARGET_NET}: not allowed network`);
    const domainUnderTest = DUT || `${TARGET_ENV}-${TARGET_NET}${TARGET_ENV === 'ops' ? '-1' : ''}.lw.iog.io`;
    console.log(`Domain under test is: ${domainUnderTest}`);
    return domainUnderTest;
};
export const chunkArray = (array, chunkSize) => {
    const arrayCopy = [...array];
    const chunked = [];
    while (arrayCopy.length > 0) {
        chunked.push(arrayCopy.splice(0, chunkSize));
    }
    return chunked;
};
export class SdkCom {
    constructor({ dut, secure = true, apiVersion, k6Http }) {
        _SdkCom_httpUrl.set(this, void 0);
        _SdkCom_apiVersion.set(this, void 0);
        _SdkCom_k6Http.set(this, void 0);
        const scheme = secure ? 'https' : 'http';
        __classPrivateFieldSet(this, _SdkCom_httpUrl, `${scheme}://${dut}`, "f");
        __classPrivateFieldSet(this, _SdkCom_apiVersion, apiVersion, "f");
        __classPrivateFieldSet(this, _SdkCom_k6Http, k6Http, "f");
    }
    tip() {
        return this.httpPost('network-info/ledger-tip', 'networkInfo');
    }
    eraSummaries() {
        return this.httpPost('network-info/era-summaries', 'networkInfo');
    }
    genesisParameters() {
        return this.httpPost('network-info/genesis-parameters', 'networkInfo');
    }
    protocolParameters() {
        return this.httpPost('network-info/protocol-parameters', 'networkInfo');
    }
    lovelaceSupply() {
        return this.httpPost('network-info/lovelace-supply', 'networkInfo');
    }
    stake() {
        return this.httpPost('network-info/stake', 'networkInfo');
    }
    stakePoolStats() {
        return this.httpPost('stake-pool/stats', 'stakePool');
    }
    httpPost(url, serviceName, body = {}) {
        const opts = { headers: { 'content-type': 'application/json' }, timeout: '1m' };
        return __classPrivateFieldGet(this, _SdkCom_k6Http, "f").post(`${__classPrivateFieldGet(this, _SdkCom_httpUrl, "f")}/v${__classPrivateFieldGet(this, _SdkCom_apiVersion, "f")[serviceName]}/${url}`, JSON.stringify(body), opts);
    }
    txsByAddress(addresses, takeOne = false, pageSize = 25) {
        const addressChunks = chunkArray(addresses, pageSize);
        for (const chunk of addressChunks) {
            let startAt = 0;
            let txCount = 0;
            do {
                const resp = this.httpPost('chain-history/txs/by-addresses', 'chainHistory', {
                    addresses: chunk,
                    blockRange: { lowerBound: { __type: 'undefined' } },
                    pagination: { limit: pageSize, startAt }
                });
                if (resp.status !== 200 || typeof resp.body !== 'string') {
                    break;
                }
                const { pageResults } = JSON.parse(resp.body);
                startAt += pageSize;
                txCount = pageResults.length;
            } while (txCount === pageSize && !takeOne);
        }
    }
    utxosByAddresses(addresses) {
        const addressChunks = chunkArray(addresses, 25);
        for (const chunk of addressChunks) {
            this.httpPost('utxo/utxo-by-addresses', 'utxo', { addresses: chunk });
        }
    }
    rewardsAccBalance(rewardAccount) {
        return this.httpPost('rewards/account-balance', 'rewards', { rewardAccount });
    }
    stakePoolSearch(poolAddress) {
        return this.httpPost('stake-pool/search', 'stakePool', {
            filters: { identifier: { values: [{ id: poolAddress }] } },
            pagination: { limit: 1, startAt: 0 }
        });
    }
    getAssets({ assetIds, nftMetadata, tokenMetadata }) {
        return this.httpPost('asset/get-assets', 'assetInfo', {
            assetIds,
            extraData: { nftMetadata, tokenMetadata }
        });
    }
}
_SdkCom_httpUrl = new WeakMap(), _SdkCom_apiVersion = new WeakMap(), _SdkCom_k6Http = new WeakMap();
//# sourceMappingURL=k6-utils.js.map