import * as Crypto from '@cardano-sdk/crypto';
import { TxInId } from '../types.js';
import { Cardano } from '@cardano-sdk/core';
import { DREP_KEY_DERIVATION_PATH } from './key.js';
import { isNotNil } from '@cardano-sdk/util';
import isEqual from 'lodash/isEqual.js';
import uniqBy from 'lodash/uniqBy.js';
import uniqWith from 'lodash/uniqWith.js';
const checkWithdrawals = ({ withdrawals }, accounts) => {
    const signatureCheck = { derivationPaths: [], requiresForeignSignatures: false };
    if (withdrawals) {
        for (const withdrawal of withdrawals) {
            const account = accounts.find((acct) => acct.rewardAccount === withdrawal.stakeAddress);
            if (account) {
                signatureCheck.derivationPaths.push(account.derivationPath);
            }
            else {
                signatureCheck.requiresForeignSignatures = true;
            }
        }
    }
    return signatureCheck;
};
const checkStakeKeyHashCertificate = (certificate, accounts) => {
    const signatureCheck = { derivationPaths: [], requiresForeignSignatures: false };
    switch (certificate.__typename) {
        case Cardano.CertificateType.VoteDelegation:
        case Cardano.CertificateType.StakeVoteDelegation:
        case Cardano.CertificateType.StakeRegistrationDelegation:
        case Cardano.CertificateType.VoteRegistrationDelegation:
        case Cardano.CertificateType.StakeVoteRegistrationDelegation:
        case Cardano.CertificateType.Registration:
        case Cardano.CertificateType.Unregistration:
        case Cardano.CertificateType.StakeDeregistration:
        case Cardano.CertificateType.StakeDelegation: {
            const account = accounts.find((acct) => certificate.stakeCredential.type === Cardano.CredentialType.KeyHash &&
                acct.stakeKeyHash === certificate.stakeCredential.hash);
            if (account) {
                signatureCheck.derivationPaths = [account.derivationPath];
            }
            else {
                signatureCheck.requiresForeignSignatures = true;
            }
        }
    }
    return signatureCheck;
};
const checkPoolRegistrationCertificate = (certificate, accounts) => {
    const signatureCheck = { derivationPaths: [], requiresForeignSignatures: false };
    if (certificate.__typename === Cardano.CertificateType.PoolRegistration) {
        for (const owner of certificate.poolParameters.owners) {
            const account = accounts.find((acct) => acct.rewardAccount === owner);
            if (account) {
                signatureCheck.derivationPaths.push(account.derivationPath);
            }
            else {
                signatureCheck.requiresForeignSignatures = true;
            }
        }
    }
    return signatureCheck;
};
const checkPoolRetirementCertificate = (certificate, accounts) => {
    const signatureCheck = { derivationPaths: [], requiresForeignSignatures: false };
    if (certificate.__typename === Cardano.CertificateType.PoolRetirement) {
        const account = accounts.find((acct) => acct.poolId === certificate.poolId);
        if (account) {
            signatureCheck.derivationPaths.push(account.derivationPath);
        }
        else {
            signatureCheck.requiresForeignSignatures = true;
        }
    }
    return signatureCheck;
};
const checkMirCertificate = (certificate, accounts) => {
    const signatureCheck = { derivationPaths: [], requiresForeignSignatures: false };
    if (certificate.__typename === Cardano.CertificateType.MIR) {
        if (certificate.kind === Cardano.MirCertificateKind.ToStakeCreds) {
            const account = accounts.find((acct) => Crypto.Hash28ByteBase16(acct.stakeKeyHash) === certificate.stakeCredential.hash);
            if (account) {
                signatureCheck.derivationPaths.push(account.derivationPath);
            }
            else {
                signatureCheck.requiresForeignSignatures = true;
            }
        }
        else {
            signatureCheck.requiresForeignSignatures = true;
        }
    }
    return signatureCheck;
};
export const checkStakeCredentialCertificates = (accounts, { certificates }) => {
    const signatureCheck = { derivationPaths: [], requiresForeignSignatures: false };
    if (!certificates?.length) {
        return signatureCheck;
    }
    for (const certificate of certificates) {
        const stakeKeyHashCheck = checkStakeKeyHashCertificate(certificate, accounts);
        signatureCheck.requiresForeignSignatures ||= stakeKeyHashCheck.requiresForeignSignatures;
        signatureCheck.derivationPaths.push(...stakeKeyHashCheck.derivationPaths);
        const poolOwnerCheck = checkPoolRegistrationCertificate(certificate, accounts);
        signatureCheck.requiresForeignSignatures ||= poolOwnerCheck.requiresForeignSignatures;
        signatureCheck.derivationPaths.push(...poolOwnerCheck.derivationPaths);
        const poolIdCheck = checkPoolRetirementCertificate(certificate, accounts);
        signatureCheck.requiresForeignSignatures ||= poolIdCheck.requiresForeignSignatures;
        signatureCheck.derivationPaths.push(...poolIdCheck.derivationPaths);
        const mirCheck = checkMirCertificate(certificate, accounts);
        signatureCheck.requiresForeignSignatures ||= mirCheck.requiresForeignSignatures;
        signatureCheck.derivationPaths.push(...mirCheck.derivationPaths);
    }
    signatureCheck.derivationPaths = uniqWith(signatureCheck.derivationPaths, isEqual);
    return signatureCheck;
};
const getSignersData = (groupedAddresses) => uniqBy(groupedAddresses, 'rewardAccount')
    .map((groupedAddress) => {
    const stakeKeyHash = Cardano.RewardAccount.toHash(groupedAddress.rewardAccount);
    const poolId = Cardano.PoolId.fromKeyHash(stakeKeyHash);
    return {
        derivationPath: groupedAddress.stakeKeyDerivationPath,
        poolId,
        rewardAccount: groupedAddress.rewardAccount,
        stakeKeyHash
    };
})
    .filter((acct) => acct.derivationPath !== undefined);
const getStakeCredentialKeyPaths = (groupedAddresses, txBody) => {
    let requiresForeignSignatures = false;
    const paths = [];
    const uniqueAccounts = getSignersData(groupedAddresses);
    const withdrawalCheck = checkWithdrawals(txBody, uniqueAccounts);
    requiresForeignSignatures ||= withdrawalCheck.requiresForeignSignatures;
    paths.push(...withdrawalCheck.derivationPaths);
    const stakeCredentialCertificatesCheck = checkStakeCredentialCertificates(uniqueAccounts, txBody);
    requiresForeignSignatures ||= stakeCredentialCertificatesCheck.requiresForeignSignatures;
    paths.push(...stakeCredentialCertificatesCheck.derivationPaths);
    return { derivationPaths: new Set(paths), requiresForeignSignatures };
};
export const getVotingProcedureKeyPaths = ({ groupedAddresses, dRepKeyHash, txBody }) => {
    const signatureCheck = { derivationPaths: [], requiresForeignSignatures: false };
    const accounts = getSignersData(groupedAddresses);
    for (const { voter } of txBody.votingProcedures || []) {
        switch (voter.__typename) {
            case Cardano.VoterType.dRepKeyHash: {
                if (dRepKeyHash && voter.credential.hash === Crypto.Hash28ByteBase16.fromEd25519KeyHashHex(dRepKeyHash)) {
                    signatureCheck.derivationPaths.push(DREP_KEY_DERIVATION_PATH);
                }
                else {
                    signatureCheck.requiresForeignSignatures = true;
                }
                break;
            }
            case Cardano.VoterType.stakePoolKeyHash: {
                const account = accounts.find((acct) => Crypto.Hash28ByteBase16.fromEd25519KeyHashHex(acct.stakeKeyHash) === voter.credential.hash);
                if (account) {
                    signatureCheck.derivationPaths.push(account.derivationPath);
                }
                else {
                    signatureCheck.requiresForeignSignatures = true;
                }
                break;
            }
            default:
                signatureCheck.requiresForeignSignatures = true;
                break;
        }
    }
    return signatureCheck;
};
const getRequiredSignersKeyPaths = (groupedAddresses, keyHashes) => {
    const paths = [];
    if (!keyHashes)
        return paths;
    for (const keyHash of keyHashes) {
        for (const address of groupedAddresses) {
            const paymentCredential = Cardano.Address.fromBech32(address.address)?.asBase()?.getPaymentCredential().hash;
            const stakeCredential = Cardano.RewardAccount.toHash(address.rewardAccount);
            if (paymentCredential && paymentCredential.toString() === keyHash) {
                paths.push({ index: address.index, role: Number(address.type) });
            }
            if (stakeCredential && address.stakeKeyDerivationPath && stakeCredential.toString() === keyHash) {
                paths.push(address.stakeKeyDerivationPath);
            }
        }
    }
    return paths;
};
export const getDRepCredentialKeyPaths = ({ dRepKeyHash, txBody }) => {
    const signature = { derivationPaths: [], requiresForeignSignatures: false };
    for (const certificate of txBody.certificates || []) {
        if (certificate.__typename === Cardano.CertificateType.UnregisterDelegateRepresentative ||
            certificate.__typename === Cardano.CertificateType.UpdateDelegateRepresentative ||
            certificate.__typename === Cardano.CertificateType.RegisterDelegateRepresentative) {
            if (certificate.dRepCredential.type === Cardano.CredentialType.ScriptHash ||
                !dRepKeyHash ||
                certificate.dRepCredential.hash !== Crypto.Hash28ByteBase16.fromEd25519KeyHashHex(dRepKeyHash)) {
                signature.requiresForeignSignatures = true;
            }
            else {
                signature.derivationPaths = [DREP_KEY_DERIVATION_PATH];
            }
        }
    }
    return signature;
};
export const createTxInKeyPathMap = async (txBody, knownAddresses, inputResolver) => {
    const result = {};
    const txInputs = [...txBody.inputs, ...(txBody.collaterals ? txBody.collaterals : [])];
    await Promise.all(txInputs.map(async (txIn) => {
        const resolution = await inputResolver.resolveInput(txIn);
        if (!resolution)
            return;
        const ownAddress = knownAddresses.find(({ address }) => address === resolution.address);
        if (!ownAddress)
            return;
        result[TxInId(txIn)] = { index: ownAddress.index, role: Number(ownAddress.type) };
    }));
    return result;
};
export const ownSignatureKeyPaths = (txBody, knownAddresses, txInKeyPathMap, dRepKeyHash) => {
    const paymentKeyPaths = Object.values(txInKeyPathMap).filter(isNotNil);
    return uniqWith([
        ...paymentKeyPaths,
        ...getStakeCredentialKeyPaths(knownAddresses, txBody).derivationPaths,
        ...getDRepCredentialKeyPaths({ dRepKeyHash, txBody }).derivationPaths,
        ...getRequiredSignersKeyPaths(knownAddresses, txBody.requiredExtraSignatures),
        ...getVotingProcedureKeyPaths({ dRepKeyHash, groupedAddresses: knownAddresses, txBody }).derivationPaths
    ], isEqual);
};
//# sourceMappingURL=ownSignatureKeyPaths.js.map