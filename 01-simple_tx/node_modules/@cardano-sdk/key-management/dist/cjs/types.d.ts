import * as Crypto from '@cardano-sdk/crypto';
import { Cardano, HandleResolution, Serialization, TxCBOR } from '@cardano-sdk/core';
import { HexBlob, OpaqueString, Shutdown } from '@cardano-sdk/util';
import { Logger } from 'ts-log';
import type { Runtime } from 'webextension-polyfill';
export declare type MessageSender = Runtime.MessageSender;
export interface SignBlobResult {
    publicKey: Crypto.Ed25519PublicKeyHex;
    signature: Crypto.Ed25519SignatureHex;
}
export declare enum CardanoKeyConst {
    PURPOSE = 1852,
    COIN_TYPE = 1815
}
export declare enum Cip1852PathLevelIndexes {
    PURPOSE = 0,
    COIN_TYPE = 1,
    ACCOUNT = 2,
    ROLE = 3,
    INDEX = 4
}
export declare enum KeyAgentType {
    InMemory = "InMemory",
    Ledger = "Ledger",
    Trezor = "Trezor"
}
export declare enum KeyRole {
    External = 0,
    Internal = 1,
    Stake = 2,
    DRep = 3
}
export declare enum KeyPurpose {
    STANDARD = 1852,
    MULTI_SIG = 1854
}
export interface AccountKeyDerivationPath {
    role: KeyRole;
    index: number;
}
export declare enum AddressType {
    Internal = 1,
    External = 0
}
export declare enum DeviceType {
    Ledger = "Ledger"
}
export declare enum CommunicationType {
    Web = "web",
    Node = "node"
}
export interface KeyAgentDependencies {
    logger: Logger;
    bip32Ed25519: Crypto.Bip32Ed25519;
}
export interface AccountAddressDerivationPath {
    type: AddressType;
    index: number;
}
export interface GroupedAddress {
    type: AddressType;
    index: number;
    networkId: Cardano.NetworkId;
    accountIndex: number;
    address: Cardano.PaymentAddress;
    rewardAccount: Cardano.RewardAccount;
    stakeKeyDerivationPath?: AccountKeyDerivationPath;
}
export interface TrezorConfig {
    communicationType: CommunicationType;
    silentMode?: boolean;
    lazyLoad?: boolean;
    manifest: {
        email: string;
        appUrl: string;
    };
}
export interface SerializableKeyAgentDataBase {
    chainId: Cardano.ChainId;
    accountIndex: number;
    extendedAccountPublicKey: Crypto.Bip32PublicKeyHex;
    purpose?: KeyPurpose;
}
export interface SerializableInMemoryKeyAgentData extends SerializableKeyAgentDataBase {
    __typename: KeyAgentType.InMemory;
    encryptedRootPrivateKeyBytes: number[];
}
export interface SerializableLedgerKeyAgentData extends SerializableKeyAgentDataBase {
    __typename: KeyAgentType.Ledger;
    communicationType: CommunicationType;
}
export interface SerializableTrezorKeyAgentData extends SerializableKeyAgentDataBase {
    __typename: KeyAgentType.Trezor;
    trezorConfig: TrezorConfig;
}
export declare type SerializableKeyAgentData = SerializableInMemoryKeyAgentData | SerializableLedgerKeyAgentData | SerializableTrezorKeyAgentData;
export interface KeyPair {
    skey: Crypto.Bip32PrivateKeyHex;
    vkey: Crypto.Bip32PublicKeyHex;
}
export interface Ed25519KeyPair {
    skey: Crypto.Ed25519PrivateNormalKeyHex | Crypto.Ed25519PrivateExtendedKeyHex;
    vkey: Crypto.Ed25519PublicKeyHex;
}
export declare type GetPassphrase = (noCache?: true) => Promise<Uint8Array>;
export declare type TxInId = OpaqueString<'TxInId'>;
export declare const TxInId: ({ txId, index }: Cardano.TxIn) => TxInId;
export declare type TxInKeyPathMap = Partial<Record<TxInId, AccountKeyDerivationPath>>;
export declare type RewardAccountKeyPathMap = Partial<Record<Cardano.RewardAccount, AccountKeyDerivationPath>>;
export declare type KeyHashKeyPathMap = Partial<Record<Crypto.Ed25519KeyHashHex, AccountKeyDerivationPath>>;
export declare type TransactionSignerResult = {
    pubKey: Crypto.Ed25519PublicKeyHex;
    signature: Crypto.Ed25519SignatureHex;
};
export interface TransactionSigner {
    sign(tx: Cardano.TxBodyWithHash): Promise<TransactionSignerResult>;
}
export interface SignTransactionOptions {
    additionalKeyPaths?: AccountKeyDerivationPath[];
    extraSigners?: TransactionSigner[];
    stubSign?: boolean;
}
export interface SignTransactionContext {
    txInKeyPathMap: TxInKeyPathMap;
    knownAddresses: GroupedAddress[];
    handleResolutions?: HandleResolution[];
    dRepKeyHashHex?: Crypto.Ed25519KeyHashHex;
    sender?: MessageSender;
}
export interface SignDataContext {
    address?: Cardano.PaymentAddress | Cardano.RewardAccount | Cardano.DRepID;
    payload?: HexBlob;
    sender?: MessageSender;
}
export interface KeyAgent {
    get chainId(): Cardano.ChainId;
    get accountIndex(): number;
    get serializableData(): SerializableKeyAgentData;
    get extendedAccountPublicKey(): Crypto.Bip32PublicKeyHex;
    get bip32Ed25519(): Crypto.Bip32Ed25519;
    get purpose(): KeyPurpose | undefined;
    signBlob(derivationPath: AccountKeyDerivationPath, blob: HexBlob): Promise<SignBlobResult>;
    signTransaction(txInternals: Cardano.TxBodyWithHash, context: SignTransactionContext, options?: SignTransactionOptions): Promise<Cardano.Signatures>;
    derivePublicKey(derivationPath: AccountKeyDerivationPath): Promise<Crypto.Ed25519PublicKeyHex>;
    deriveAddress(paymentKeyDerivationPath: AccountAddressDerivationPath, stakeKeyDerivationIndex: number): Promise<GroupedAddress>;
    exportRootPrivateKey(): Promise<Crypto.Bip32PrivateKeyHex>;
}
export declare type AsyncKeyAgent = Pick<KeyAgent, 'deriveAddress' | 'derivePublicKey' | 'signBlob' | 'signTransaction'> & {
    getChainId(): Promise<Cardano.ChainId>;
    getBip32Ed25519(): Promise<Crypto.Bip32Ed25519>;
    getExtendedAccountPublicKey(): Promise<Crypto.Bip32PublicKeyHex>;
    getAccountIndex(): Promise<number>;
} & Shutdown;
export declare type WitnessOptions = SignTransactionOptions;
export interface WitnessedTx {
    cbor: TxCBOR;
    tx: Cardano.Tx;
    context: {
        handleResolutions: HandleResolution[];
    };
}
export interface Witnesser {
    witness(transaction: Serialization.Transaction, context: SignTransactionContext, options?: WitnessOptions): Promise<WitnessedTx>;
    signBlob(derivationPath: AccountKeyDerivationPath, blob: HexBlob, context: SignDataContext): Promise<SignBlobResult>;
}
//# sourceMappingURL=types.d.ts.map