"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.emip3decrypt = exports.emip3encrypt = exports.createPbkdf2Key = void 0;
const pbkdf2_1 = require("pbkdf2");
const chacha_1 = __importDefault(require("chacha"));
const get_random_values_1 = __importDefault(require("get-random-values"));
const KEY_LENGTH = 32;
const NONCE_LENGTH = 12;
const PBKDF2_ITERATIONS = 19162;
const SALT_LENGTH = 32;
const TAG_LENGTH = 16;
const AAD = Buffer.from('', 'hex');
const createPbkdf2Key = async (passphrase, salt) => await new Promise((resolve, reject) => (0, pbkdf2_1.pbkdf2)(passphrase, salt, PBKDF2_ITERATIONS, KEY_LENGTH, 'sha512', (err, derivedKey) => {
    if (err)
        return reject(err);
    resolve(derivedKey);
}));
exports.createPbkdf2Key = createPbkdf2Key;
const emip3encrypt = async (data, passphrase) => {
    const salt = new Uint8Array(SALT_LENGTH);
    (0, get_random_values_1.default)(salt);
    const key = await (0, exports.createPbkdf2Key)(passphrase, salt);
    const nonce = new Uint8Array(NONCE_LENGTH);
    (0, get_random_values_1.default)(nonce);
    const cipher = chacha_1.default.createCipher(key, Buffer.from(nonce));
    cipher.setAAD(AAD, { plaintextLength: data.length });
    const head = cipher.update(data);
    const final = cipher.final();
    const tag = cipher.getAuthTag();
    return Buffer.concat([salt, nonce, tag, head, final]);
};
exports.emip3encrypt = emip3encrypt;
const emip3decrypt = async (encrypted, passphrase) => {
    const salt = encrypted.slice(0, SALT_LENGTH);
    const nonce = encrypted.slice(SALT_LENGTH, SALT_LENGTH + NONCE_LENGTH);
    const tag = encrypted.slice(SALT_LENGTH + NONCE_LENGTH, SALT_LENGTH + NONCE_LENGTH + TAG_LENGTH);
    const data = encrypted.slice(SALT_LENGTH + NONCE_LENGTH + TAG_LENGTH);
    const key = await (0, exports.createPbkdf2Key)(passphrase, salt);
    const decipher = chacha_1.default.createDecipher(key, Buffer.from(nonce));
    decipher.setAuthTag(Buffer.from(tag));
    decipher.setAAD(AAD);
    return Buffer.concat([decipher.update(Buffer.from(data)), decipher.final()]);
};
exports.emip3decrypt = emip3decrypt;
//# sourceMappingURL=emip3.js.map