"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cip30signData = exports.Cip30DataSignError = exports.Cip30DataSignErrorCode = void 0;
const cardano_message_signing_nodejs_1 = require("@emurgo/cardano-message-signing-nodejs");
const util_1 = require("../util");
const core_1 = require("@cardano-sdk/core");
const util_2 = require("@cardano-sdk/util");
const util_3 = require("./util");
var Cip30DataSignErrorCode;
(function (Cip30DataSignErrorCode) {
    Cip30DataSignErrorCode[Cip30DataSignErrorCode["ProofGeneration"] = 1] = "ProofGeneration";
    Cip30DataSignErrorCode[Cip30DataSignErrorCode["AddressNotPK"] = 2] = "AddressNotPK";
    Cip30DataSignErrorCode[Cip30DataSignErrorCode["UserDeclined"] = 3] = "UserDeclined";
})(Cip30DataSignErrorCode = exports.Cip30DataSignErrorCode || (exports.Cip30DataSignErrorCode = {}));
class Cip30DataSignError extends util_2.ComposableError {
    constructor(code, info, innerError) {
        super(`DataSignError code: ${code}`, innerError);
        this.code = code;
        this.info = info;
    }
}
exports.Cip30DataSignError = Cip30DataSignError;
const getAddressBytes = (signWith) => {
    const address = core_1.Cardano.Address.fromString(signWith);
    if (!address) {
        throw new Cip30DataSignError(Cip30DataSignErrorCode.AddressNotPK, 'Invalid address');
    }
    return Buffer.from(address.toBytes(), 'hex');
};
const getDerivationPath = async (signWith, knownAddresses) => {
    if (core_1.Cardano.DRepID.isValid(signWith)) {
        return util_1.DREP_KEY_DERIVATION_PATH;
    }
    const isRewardAccount = signWith.startsWith('stake');
    if (isRewardAccount) {
        const knownRewardAddress = knownAddresses.find(({ rewardAccount }) => rewardAccount === signWith);
        if (!knownRewardAddress)
            throw new Cip30DataSignError(Cip30DataSignErrorCode.ProofGeneration, 'Unknown reward address');
        return knownRewardAddress.stakeKeyDerivationPath || util_1.STAKE_KEY_DERIVATION_PATH;
    }
    const knownAddress = knownAddresses.find(({ address }) => address === signWith);
    if (!knownAddress) {
        throw new Cip30DataSignError(Cip30DataSignErrorCode.ProofGeneration, 'Unknown address');
    }
    return { index: knownAddress.index, role: knownAddress.type };
};
const createSigStructureHeaders = (addressBytes) => {
    const protectedHeaders = cardano_message_signing_nodejs_1.HeaderMap.new();
    protectedHeaders.set_key_id(addressBytes);
    protectedHeaders.set_header(util_3.CoseLabel.address, cardano_message_signing_nodejs_1.CBORValue.new_bytes(addressBytes));
    protectedHeaders.set_algorithm_id(cardano_message_signing_nodejs_1.Label.from_algorithm_id(cardano_message_signing_nodejs_1.AlgorithmId.EdDSA));
    return protectedHeaders;
};
const signSigStructure = (witnesser, derivationPath, sigStructure, address, sender) => {
    try {
        const payload = core_1.util.bytesToHex(sigStructure.payload());
        return witnesser.signBlob(derivationPath, core_1.util.bytesToHex(sigStructure.to_bytes()), { address, payload, sender });
    }
    catch (error) {
        throw new Cip30DataSignError(Cip30DataSignErrorCode.UserDeclined, 'Failed to sign', error);
    }
};
const createCoseKey = (addressBytes, publicKey) => {
    const coseKey = cardano_message_signing_nodejs_1.COSEKey.new(cardano_message_signing_nodejs_1.Label.from_key_type(cardano_message_signing_nodejs_1.KeyType.OKP));
    coseKey.set_key_id(addressBytes);
    coseKey.set_algorithm_id(cardano_message_signing_nodejs_1.Label.from_algorithm_id(cardano_message_signing_nodejs_1.AlgorithmId.EdDSA));
    coseKey.set_header(util_3.CoseLabel.crv, cardano_message_signing_nodejs_1.CBORValue.from_label(cardano_message_signing_nodejs_1.Label.from_curve_type(cardano_message_signing_nodejs_1.CurveType.Ed25519)));
    coseKey.set_header(util_3.CoseLabel.x, cardano_message_signing_nodejs_1.CBORValue.new_bytes(Buffer.from(publicKey, 'hex')));
    return coseKey;
};
const cip30signData = async ({ knownAddresses, witnesser, signWith, payload, sender }) => {
    if (core_1.Cardano.DRepID.isValid(signWith) && !core_1.Cardano.DRepID.canSign(signWith)) {
        throw new Cip30DataSignError(Cip30DataSignErrorCode.AddressNotPK, 'Invalid address');
    }
    const addressBytes = getAddressBytes(signWith);
    const derivationPath = await getDerivationPath(signWith, knownAddresses);
    const builder = cardano_message_signing_nodejs_1.COSESign1Builder.new(cardano_message_signing_nodejs_1.Headers.new(cardano_message_signing_nodejs_1.ProtectedHeaderMap.new(createSigStructureHeaders(addressBytes)), cardano_message_signing_nodejs_1.HeaderMap.new()), Buffer.from(payload, 'hex'), false);
    const sigStructure = builder.make_data_to_sign();
    const { signature, publicKey } = await signSigStructure(witnesser, derivationPath, sigStructure, signWith, sender);
    const coseSign1 = builder.build(Buffer.from(signature, 'hex'));
    const coseKey = createCoseKey(addressBytes, publicKey);
    return {
        key: core_1.util.bytesToHex(coseKey.to_bytes()),
        signature: core_1.util.bytesToHex(coseSign1.to_bytes())
    };
};
exports.cip30signData = cip30signData;
//# sourceMappingURL=cip30signData.js.map