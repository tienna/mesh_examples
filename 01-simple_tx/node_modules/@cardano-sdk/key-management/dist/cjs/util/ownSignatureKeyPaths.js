"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ownSignatureKeyPaths = exports.createTxInKeyPathMap = exports.getDRepCredentialKeyPaths = exports.getVotingProcedureKeyPaths = exports.checkStakeCredentialCertificates = void 0;
const Crypto = __importStar(require("@cardano-sdk/crypto"));
const types_1 = require("../types");
const core_1 = require("@cardano-sdk/core");
const key_1 = require("./key");
const util_1 = require("@cardano-sdk/util");
const isEqual_js_1 = __importDefault(require("lodash/isEqual.js"));
const uniqBy_js_1 = __importDefault(require("lodash/uniqBy.js"));
const uniqWith_js_1 = __importDefault(require("lodash/uniqWith.js"));
const checkWithdrawals = ({ withdrawals }, accounts) => {
    const signatureCheck = { derivationPaths: [], requiresForeignSignatures: false };
    if (withdrawals) {
        for (const withdrawal of withdrawals) {
            const account = accounts.find((acct) => acct.rewardAccount === withdrawal.stakeAddress);
            if (account) {
                signatureCheck.derivationPaths.push(account.derivationPath);
            }
            else {
                signatureCheck.requiresForeignSignatures = true;
            }
        }
    }
    return signatureCheck;
};
const checkStakeKeyHashCertificate = (certificate, accounts) => {
    const signatureCheck = { derivationPaths: [], requiresForeignSignatures: false };
    switch (certificate.__typename) {
        case core_1.Cardano.CertificateType.VoteDelegation:
        case core_1.Cardano.CertificateType.StakeVoteDelegation:
        case core_1.Cardano.CertificateType.StakeRegistrationDelegation:
        case core_1.Cardano.CertificateType.VoteRegistrationDelegation:
        case core_1.Cardano.CertificateType.StakeVoteRegistrationDelegation:
        case core_1.Cardano.CertificateType.Registration:
        case core_1.Cardano.CertificateType.Unregistration:
        case core_1.Cardano.CertificateType.StakeDeregistration:
        case core_1.Cardano.CertificateType.StakeDelegation: {
            const account = accounts.find((acct) => certificate.stakeCredential.type === core_1.Cardano.CredentialType.KeyHash &&
                acct.stakeKeyHash === certificate.stakeCredential.hash);
            if (account) {
                signatureCheck.derivationPaths = [account.derivationPath];
            }
            else {
                signatureCheck.requiresForeignSignatures = true;
            }
        }
    }
    return signatureCheck;
};
const checkPoolRegistrationCertificate = (certificate, accounts) => {
    const signatureCheck = { derivationPaths: [], requiresForeignSignatures: false };
    if (certificate.__typename === core_1.Cardano.CertificateType.PoolRegistration) {
        for (const owner of certificate.poolParameters.owners) {
            const account = accounts.find((acct) => acct.rewardAccount === owner);
            if (account) {
                signatureCheck.derivationPaths.push(account.derivationPath);
            }
            else {
                signatureCheck.requiresForeignSignatures = true;
            }
        }
    }
    return signatureCheck;
};
const checkPoolRetirementCertificate = (certificate, accounts) => {
    const signatureCheck = { derivationPaths: [], requiresForeignSignatures: false };
    if (certificate.__typename === core_1.Cardano.CertificateType.PoolRetirement) {
        const account = accounts.find((acct) => acct.poolId === certificate.poolId);
        if (account) {
            signatureCheck.derivationPaths.push(account.derivationPath);
        }
        else {
            signatureCheck.requiresForeignSignatures = true;
        }
    }
    return signatureCheck;
};
const checkMirCertificate = (certificate, accounts) => {
    const signatureCheck = { derivationPaths: [], requiresForeignSignatures: false };
    if (certificate.__typename === core_1.Cardano.CertificateType.MIR) {
        if (certificate.kind === core_1.Cardano.MirCertificateKind.ToStakeCreds) {
            const account = accounts.find((acct) => Crypto.Hash28ByteBase16(acct.stakeKeyHash) === certificate.stakeCredential.hash);
            if (account) {
                signatureCheck.derivationPaths.push(account.derivationPath);
            }
            else {
                signatureCheck.requiresForeignSignatures = true;
            }
        }
        else {
            signatureCheck.requiresForeignSignatures = true;
        }
    }
    return signatureCheck;
};
const checkStakeCredentialCertificates = (accounts, { certificates }) => {
    const signatureCheck = { derivationPaths: [], requiresForeignSignatures: false };
    if (!certificates?.length) {
        return signatureCheck;
    }
    for (const certificate of certificates) {
        const stakeKeyHashCheck = checkStakeKeyHashCertificate(certificate, accounts);
        signatureCheck.requiresForeignSignatures ||= stakeKeyHashCheck.requiresForeignSignatures;
        signatureCheck.derivationPaths.push(...stakeKeyHashCheck.derivationPaths);
        const poolOwnerCheck = checkPoolRegistrationCertificate(certificate, accounts);
        signatureCheck.requiresForeignSignatures ||= poolOwnerCheck.requiresForeignSignatures;
        signatureCheck.derivationPaths.push(...poolOwnerCheck.derivationPaths);
        const poolIdCheck = checkPoolRetirementCertificate(certificate, accounts);
        signatureCheck.requiresForeignSignatures ||= poolIdCheck.requiresForeignSignatures;
        signatureCheck.derivationPaths.push(...poolIdCheck.derivationPaths);
        const mirCheck = checkMirCertificate(certificate, accounts);
        signatureCheck.requiresForeignSignatures ||= mirCheck.requiresForeignSignatures;
        signatureCheck.derivationPaths.push(...mirCheck.derivationPaths);
    }
    signatureCheck.derivationPaths = (0, uniqWith_js_1.default)(signatureCheck.derivationPaths, isEqual_js_1.default);
    return signatureCheck;
};
exports.checkStakeCredentialCertificates = checkStakeCredentialCertificates;
const getSignersData = (groupedAddresses) => (0, uniqBy_js_1.default)(groupedAddresses, 'rewardAccount')
    .map((groupedAddress) => {
    const stakeKeyHash = core_1.Cardano.RewardAccount.toHash(groupedAddress.rewardAccount);
    const poolId = core_1.Cardano.PoolId.fromKeyHash(stakeKeyHash);
    return {
        derivationPath: groupedAddress.stakeKeyDerivationPath,
        poolId,
        rewardAccount: groupedAddress.rewardAccount,
        stakeKeyHash
    };
})
    .filter((acct) => acct.derivationPath !== undefined);
const getStakeCredentialKeyPaths = (groupedAddresses, txBody) => {
    let requiresForeignSignatures = false;
    const paths = [];
    const uniqueAccounts = getSignersData(groupedAddresses);
    const withdrawalCheck = checkWithdrawals(txBody, uniqueAccounts);
    requiresForeignSignatures ||= withdrawalCheck.requiresForeignSignatures;
    paths.push(...withdrawalCheck.derivationPaths);
    const stakeCredentialCertificatesCheck = (0, exports.checkStakeCredentialCertificates)(uniqueAccounts, txBody);
    requiresForeignSignatures ||= stakeCredentialCertificatesCheck.requiresForeignSignatures;
    paths.push(...stakeCredentialCertificatesCheck.derivationPaths);
    return { derivationPaths: new Set(paths), requiresForeignSignatures };
};
const getVotingProcedureKeyPaths = ({ groupedAddresses, dRepKeyHash, txBody }) => {
    const signatureCheck = { derivationPaths: [], requiresForeignSignatures: false };
    const accounts = getSignersData(groupedAddresses);
    for (const { voter } of txBody.votingProcedures || []) {
        switch (voter.__typename) {
            case core_1.Cardano.VoterType.dRepKeyHash: {
                if (dRepKeyHash && voter.credential.hash === Crypto.Hash28ByteBase16.fromEd25519KeyHashHex(dRepKeyHash)) {
                    signatureCheck.derivationPaths.push(key_1.DREP_KEY_DERIVATION_PATH);
                }
                else {
                    signatureCheck.requiresForeignSignatures = true;
                }
                break;
            }
            case core_1.Cardano.VoterType.stakePoolKeyHash: {
                const account = accounts.find((acct) => Crypto.Hash28ByteBase16.fromEd25519KeyHashHex(acct.stakeKeyHash) === voter.credential.hash);
                if (account) {
                    signatureCheck.derivationPaths.push(account.derivationPath);
                }
                else {
                    signatureCheck.requiresForeignSignatures = true;
                }
                break;
            }
            default:
                signatureCheck.requiresForeignSignatures = true;
                break;
        }
    }
    return signatureCheck;
};
exports.getVotingProcedureKeyPaths = getVotingProcedureKeyPaths;
const getRequiredSignersKeyPaths = (groupedAddresses, keyHashes) => {
    const paths = [];
    if (!keyHashes)
        return paths;
    for (const keyHash of keyHashes) {
        for (const address of groupedAddresses) {
            const paymentCredential = core_1.Cardano.Address.fromBech32(address.address)?.asBase()?.getPaymentCredential().hash;
            const stakeCredential = core_1.Cardano.RewardAccount.toHash(address.rewardAccount);
            if (paymentCredential && paymentCredential.toString() === keyHash) {
                paths.push({ index: address.index, role: Number(address.type) });
            }
            if (stakeCredential && address.stakeKeyDerivationPath && stakeCredential.toString() === keyHash) {
                paths.push(address.stakeKeyDerivationPath);
            }
        }
    }
    return paths;
};
const getDRepCredentialKeyPaths = ({ dRepKeyHash, txBody }) => {
    const signature = { derivationPaths: [], requiresForeignSignatures: false };
    for (const certificate of txBody.certificates || []) {
        if (certificate.__typename === core_1.Cardano.CertificateType.UnregisterDelegateRepresentative ||
            certificate.__typename === core_1.Cardano.CertificateType.UpdateDelegateRepresentative ||
            certificate.__typename === core_1.Cardano.CertificateType.RegisterDelegateRepresentative) {
            if (certificate.dRepCredential.type === core_1.Cardano.CredentialType.ScriptHash ||
                !dRepKeyHash ||
                certificate.dRepCredential.hash !== Crypto.Hash28ByteBase16.fromEd25519KeyHashHex(dRepKeyHash)) {
                signature.requiresForeignSignatures = true;
            }
            else {
                signature.derivationPaths = [key_1.DREP_KEY_DERIVATION_PATH];
            }
        }
    }
    return signature;
};
exports.getDRepCredentialKeyPaths = getDRepCredentialKeyPaths;
const createTxInKeyPathMap = async (txBody, knownAddresses, inputResolver) => {
    const result = {};
    const txInputs = [...txBody.inputs, ...(txBody.collaterals ? txBody.collaterals : [])];
    await Promise.all(txInputs.map(async (txIn) => {
        const resolution = await inputResolver.resolveInput(txIn);
        if (!resolution)
            return;
        const ownAddress = knownAddresses.find(({ address }) => address === resolution.address);
        if (!ownAddress)
            return;
        result[(0, types_1.TxInId)(txIn)] = { index: ownAddress.index, role: Number(ownAddress.type) };
    }));
    return result;
};
exports.createTxInKeyPathMap = createTxInKeyPathMap;
const ownSignatureKeyPaths = (txBody, knownAddresses, txInKeyPathMap, dRepKeyHash) => {
    const paymentKeyPaths = Object.values(txInKeyPathMap).filter(util_1.isNotNil);
    return (0, uniqWith_js_1.default)([
        ...paymentKeyPaths,
        ...getStakeCredentialKeyPaths(knownAddresses, txBody).derivationPaths,
        ...(0, exports.getDRepCredentialKeyPaths)({ dRepKeyHash, txBody }).derivationPaths,
        ...getRequiredSignersKeyPaths(knownAddresses, txBody.requiredExtraSignatures),
        ...(0, exports.getVotingProcedureKeyPaths)({ dRepKeyHash, groupedAddresses: knownAddresses, txBody }).derivationPaths
    ], isEqual_js_1.default);
};
exports.ownSignatureKeyPaths = ownSignatureKeyPaths;
//# sourceMappingURL=ownSignatureKeyPaths.js.map