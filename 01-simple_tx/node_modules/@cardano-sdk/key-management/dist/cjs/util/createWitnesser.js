"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Bip32Ed25519Witnesser_keyAgent;
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBip32Ed25519Witnesser = exports.Bip32Ed25519Witnesser = void 0;
const core_1 = require("@cardano-sdk/core");
const stubSignTransaction_1 = require("./stubSignTransaction");
class Bip32Ed25519Witnesser {
    constructor(keyAgent) {
        _Bip32Ed25519Witnesser_keyAgent.set(this, void 0);
        __classPrivateFieldSet(this, _Bip32Ed25519Witnesser_keyAgent, keyAgent, "f");
    }
    async witness(tx, context, options) {
        const coreTx = tx.toCore();
        const hash = tx.getId();
        const signatures = options?.stubSign !== undefined && options.stubSign
            ? await (0, stubSignTransaction_1.stubSignTransaction)({
                context,
                signTransactionOptions: options,
                txBody: coreTx.body
            })
            : await Bip32Ed25519Witnesser.getSignatures(__classPrivateFieldGet(this, _Bip32Ed25519Witnesser_keyAgent, "f"), { body: coreTx.body, hash }, context, options);
        const transaction = {
            auxiliaryData: coreTx.auxiliaryData,
            body: coreTx.body,
            id: hash,
            isValid: tx.isValid(),
            witness: {
                ...coreTx.witness,
                signatures: new Map([...signatures.entries(), ...(coreTx.witness?.signatures?.entries() || [])])
            }
        };
        return {
            cbor: core_1.TxCBOR.serialize(transaction),
            context: {
                handleResolutions: context.handleResolutions ?? []
            },
            tx: transaction
        };
    }
    async signBlob(derivationPath, blob, _context) {
        return __classPrivateFieldGet(this, _Bip32Ed25519Witnesser_keyAgent, "f").signBlob(derivationPath, blob);
    }
    static async getSignatures(keyAgent, txInternals, context, options) {
        const signatures = await keyAgent.signTransaction({
            body: txInternals.body,
            hash: txInternals.hash
        }, context, options);
        if (options?.extraSigners) {
            for (const extraSigner of options?.extraSigners) {
                const extraSignature = await extraSigner.sign(txInternals);
                signatures.set(extraSignature.pubKey, extraSignature.signature);
            }
        }
        return signatures;
    }
}
exports.Bip32Ed25519Witnesser = Bip32Ed25519Witnesser;
_Bip32Ed25519Witnesser_keyAgent = new WeakMap();
const createBip32Ed25519Witnesser = (keyAgent) => new Bip32Ed25519Witnesser(keyAgent);
exports.createBip32Ed25519Witnesser = createBip32Ed25519Witnesser;
//# sourceMappingURL=createWitnesser.js.map