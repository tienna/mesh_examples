{"version":3,"sources":["../../src/index.ts","../../src/cardano.ts","../../src/grpcTransport.node.ts","../../src/common.ts"],"sourcesContent":["export {\n  SyncClient as CardanoSyncClient,\n  QueryClient as CardanoQueryClient,\n  SubmitClient as CardanoSubmitClient,\n} from \"./cardano.js\";\n","import {\n  PromiseClient,\n  createPromiseClient,\n} from \"@connectrpc/connect\";\n\nimport { createGrpcTransport } from '@sdk/grpcTransport';\n\nimport { PartialMessage } from \"@bufbuild/protobuf\";\n\nimport { Buffer } from \"buffer\";\n\nimport {\n  sync,\n  syncConnect,\n  query,\n  queryConnect,\n  submit,\n  submitConnect,\n  cardano,\n} from \"@utxorpc/spec\";\n\nimport {\n  ClientBuilderOptions,\n  metadataInterceptor,\n  GenericTipEvent,\n  GenericUtxo,\n} from \"./common.js\";\n\nexport type ChainPoint = { slot: number | string; hash: string };\nexport type Utxo = GenericUtxo<query.TxoRef, cardano.TxOutput>;\nexport type TipEvent = GenericTipEvent<cardano.Block, ChainPoint>;\nexport type TxHash = Uint8Array;\nexport type TxCbor = Uint8Array;\n\nfunction anyChainToBlock(msg) {\n  return msg.chain.case == \"cardano\" ? msg.chain.value : null;\n}\n\nfunction pointToBlockRef(p: ChainPoint) {\n  return new sync.BlockRef({\n    index: BigInt(p.slot),\n    hash: new Uint8Array(Buffer.from(p.hash, \"hex\")),\n  });\n}\n\nfunction blockRefToPoint(r) {\n  return {\n    slot: r.index.toString(),\n    hash: Buffer.from(r.hash).toString(\"hex\"),\n  };\n}\n\nfunction anyUtxoToChain(u: query.AnyUtxoData): Utxo {\n  switch (u.parsedState.case) {\n    case \"cardano\":\n      return {\n        txoRef: u.txoRef!,\n        parsedValued: u.parsedState.value,\n        nativeBytes: u.nativeBytes,\n      };\n    default:\n      throw Error(\"source is not Cardano data\");\n  }\n}\n\nfunction anyParamsToChain(p: query.AnyChainParams): cardano.PParams {\n  switch (p.params.case) {\n    case \"cardano\":\n      return p.params.value;\n    default:\n      throw Error(\"source is not Cardano data\");\n  }\n}\n\nexport class SyncClient {\n  inner: PromiseClient<typeof syncConnect.SyncService>;\n\n  constructor(options: ClientBuilderOptions) {\n    let headerInterceptor = metadataInterceptor(options);\n\n    const transport = createGrpcTransport({\n      httpVersion: \"2\",\n      baseUrl: options.uri,\n      interceptors: [headerInterceptor],\n    });\n\n    this.inner = createPromiseClient(syncConnect.SyncService, transport);\n  }\n\n  async *followTip(intersect?: ChainPoint[]): AsyncIterable<TipEvent> {\n    const req = new sync.FollowTipRequest({\n      intersect: intersect?.map((p) => pointToBlockRef(p)),\n    });\n\n    const res = this.inner.followTip(req);\n\n    for await (const any of res) {\n      switch (any.action.case) {\n        case \"apply\":\n          yield {\n            action: \"apply\",\n            block: anyChainToBlock(any.action.value)!,\n          };\n          break;\n        case \"undo\":\n          yield {\n            action: \"undo\",\n            block: anyChainToBlock(any.action.value)!,\n          };\n          break;\n        case \"reset\":\n          yield {\n            action: \"reset\",\n            point: blockRefToPoint(any.action.value),\n          };\n      }\n    }\n  }\n\n  async fetchBlock(p: ChainPoint): Promise<cardano.Block> {\n    const req = pointToBlockRef(p);\n    const res = await this.inner.fetchBlock({ ref: [req] });\n    return anyChainToBlock(res.block[0])!;\n  }\n}\n\nexport class QueryClient {\n  inner: PromiseClient<typeof queryConnect.QueryService>;\n\n  constructor(options: ClientBuilderOptions) {\n    let headerInterceptor = metadataInterceptor(options);\n\n    const transport = createGrpcTransport({\n      httpVersion: \"2\",\n      baseUrl: options.uri,\n      interceptors: [headerInterceptor],\n    });\n\n    this.inner = createPromiseClient(queryConnect.QueryService, transport);\n  }\n\n  async readParams(): Promise<cardano.PParams> {\n    const res = await this.inner.readParams({});\n    return anyParamsToChain(res.values!);\n  }\n\n  async readUtxosByOutputRef(\n    refs: { txHash: Uint8Array; outputIndex: number }[]\n  ): Promise<Utxo[]> {\n    const searchResponse = await this.inner.readUtxos({\n      keys: refs.map((ref) => {\n        return {\n          hash: ref.txHash,\n          index: ref.outputIndex,\n        };\n      }),\n    });\n\n    return searchResponse.items.map(anyUtxoToChain);\n  }\n\n  private async searchUtxosByMatch(\n    pattern: PartialMessage<cardano.TxOutputPattern>\n  ): Promise<Utxo[]> {\n    const searchResponse = await this.inner.searchUtxos({\n      predicate: {\n        match: { utxoPattern: { value: pattern, case: \"cardano\" } },\n      },\n    });\n\n    return searchResponse.items.map(anyUtxoToChain);\n  }\n\n  async searchUtxosByAddress(address: Uint8Array): Promise<Utxo[]> {\n    return this.searchUtxosByMatch({\n      address: {\n        exactAddress: address,\n      },\n    });\n  }\n\n  async searchUtxosByPaymentPart(paymentPart: Uint8Array): Promise<Utxo[]> {\n    return this.searchUtxosByMatch({\n      address: {\n        paymentPart: paymentPart,\n      },\n    });\n  }\n\n  async searchUtxosByDelegationPart(delegationPart: Uint8Array): Promise<Utxo[]> {\n    return this.searchUtxosByMatch({\n      address: {\n        delegationPart: delegationPart,\n      },\n    });\n  }\n\n  async searchUtxosByAsset(\n    policyId?: Uint8Array,\n    name?: Uint8Array\n  ): Promise<Utxo[]> {\n    return this.searchUtxosByMatch({\n      asset: policyId ? { policyId } : { assetName: name },\n    });\n  }\n\n  async searchUtxosByAddressWithAsset(\n    address: Uint8Array,\n    policyId?: Uint8Array,\n    name?: Uint8Array\n  ): Promise<Utxo[]> {\n    return this.searchUtxosByMatch({\n      address: {\n        exactAddress: address,\n      },\n      asset: policyId ? { policyId } : { assetName: name },\n    });\n  }\n}\n\nexport class SubmitClient {\n  inner: PromiseClient<typeof submitConnect.SubmitService>;\n\n  constructor(options: ClientBuilderOptions) {\n    let headerInterceptor = metadataInterceptor(options);\n\n    const transport = createGrpcTransport({\n      httpVersion: \"2\",\n      baseUrl: options.uri,\n      interceptors: [headerInterceptor],\n    });\n\n    this.inner = createPromiseClient(submitConnect.SubmitService, transport);\n  }\n\n  async submitTx(tx: TxCbor): Promise<TxHash> {\n    const res = await this.inner.submitTx({\n      tx: [tx].map((cbor) => ({ type: { case: \"raw\", value: cbor } })),\n    });\n\n    return res.ref[0];\n  }\n\n  async *waitForTx(txHash: TxHash): AsyncIterable<submit.Stage> {\n    const updates = this.inner.waitForTx({\n      ref: [txHash],\n    });\n\n    for await (const change of updates) {\n      yield change.stage;\n    }\n  }\n}\n","import { createGrpcTransport as createGrpcNodeTransport } from \"@connectrpc/connect-node\";\nexport const createGrpcTransport = createGrpcNodeTransport;\n","import {\n  Interceptor,\n} from \"@connectrpc/connect\";\n\nexport function metadataInterceptor(\n  options?: ClientBuilderOptions\n): Interceptor {\n  return (next) => async (req) => {\n    if (!!options?.headers) {\n      Object.entries(options.headers).forEach(([key, value]) =>\n        req.header.set(key, value)\n      );\n    }\n\n    return await next(req);\n  };\n}\n\nexport type GenericTipEvent<Block, Point> =\n  | { action: \"apply\"; block: Block }\n  | { action: \"undo\"; block: Block }\n  | { action: \"reset\"; point: Point };\n\nexport type GenericUtxo<Ref, Parsed> = {\n  txoRef: Ref;\n  parsedValued: Parsed | undefined;\n  nativeBytes: Uint8Array | undefined;\n};\n\nexport type ClientBuilderOptions = {\n  uri: string;\n  headers?: Record<string, string>;\n};\n"],"mappings":"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","names":["createGrpcNodeTransport"]}