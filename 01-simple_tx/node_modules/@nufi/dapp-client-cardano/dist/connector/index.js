"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createInjectedConnectorFactory = exports.API_VERSION = void 0;
const dapp_client_core_1 = require("@nufi/dapp-client-core");
const emulatedWalletIcons_1 = require("./emulatedWalletIcons");
const utils_1 = require("./utils");
__exportStar(require("./utils"), exports);
const connectorKind = 'cardano';
exports.API_VERSION = '1.1.0';
const createInjectedConnectorFactory = (options) => (client, config) => {
    const createProxyMethods = (methods) => Object.fromEntries(methods.map((method) => [method, client.proxy[method]]));
    // CIP-0030
    const cip30ApiObject = Object.assign(Object.assign({}, createProxyMethods([
        'getExtensions',
        'getNetworkId',
        'getUtxos',
        'getBalance',
        'getUsedAddresses',
        'getUnusedAddresses',
        'getChangeAddress',
        'getRewardAddresses',
        'signTx',
        'signData',
        'submitTx',
        'getCollateral',
    ])), { experimental: {
            getCollateral: client.proxy.getCollateral,
        } });
    // CIP-0062
    const cip62ApiObject = Object.assign(Object.assign(Object.assign({}, cip30ApiObject), createProxyMethods([
        'signVotes',
        'getVotingCredentials',
        'submitDelegation',
    ])), { getVotingPurposes: () => __awaiter(void 0, void 0, void 0, function* () { return utils_1.supportedVotingPurposes; }) });
    // CIP-0095
    const cip95ApiObject = Object.assign({}, createProxyMethods([
        'getPubDRepKey',
        'getRegisteredPubStakeKeys',
        'getUnregisteredPubStakeKeys',
    ]));
    const isCip62Enabled = config.connectors.cardano.isCip62Enabled;
    const isCip95Enabled = config.connectors.cardano.isCip95Enabled;
    const connectorObject = Object.assign(Object.assign({ enable: () => __awaiter(void 0, void 0, void 0, function* () {
            if (!client.isConnectorWindowOpen()) {
                yield client.openConnectorWindow();
            }
            yield client.proxy.enable(); // This will throw on failure
            return Object.assign(Object.assign({}, cip30ApiObject), (isCip95Enabled ? { cip95: cip95ApiObject } : {}));
        }), isEnabled: options.getIsEnabled(client) }, (isCip62Enabled
        ? {
            catalyst: {
                apiVersion: '0.1.0',
                enable: (purposes) => __awaiter(void 0, void 0, void 0, function* () {
                    (0, utils_1.ensureCatalystVotingPurpose)(purposes);
                    if (!client.isConnectorWindowOpen())
                        yield client.openConnectorWindow();
                    yield client.proxy.enable(); // This will throw on failure
                    return cip62ApiObject;
                }),
            },
        }
        : {})), { apiVersion: exports.API_VERSION, name: config.name, icon: config.icons.default, supportedExtensions: [
            ...(isCip62Enabled ? [{ cip: 62 }] : []),
            ...(isCip95Enabled ? [{ cip: 95 }] : []),
        ] });
    return {
        connectorKind,
        type: 'withOverrides',
        inject: (window, walletOverrides) => {
            // We are not using `setIfDoesNotExist` here as in case of Widget
            // we are expecting reassignments (due to messaging port recreation).
            (0, dapp_client_core_1.set)(window, [connectorKind, dapp_client_core_1.objKeyByConnectorPlatform[config.connectorPlatform]], connectorObject);
            if (walletOverrides === null || walletOverrides === void 0 ? void 0 : walletOverrides.flint) {
                (0, dapp_client_core_1.setIfDoesNotExist)(window, [connectorKind, 'flint'], Object.assign(Object.assign({}, connectorObject), { name: 'Flint Wallet', icon: emulatedWalletIcons_1.emulatedWalletIcons.flint }));
            }
            if (walletOverrides === null || walletOverrides === void 0 ? void 0 : walletOverrides.eternl) {
                const eternlConnector = Object.assign(Object.assign({}, connectorObject), { name: 'eternl', icon: emulatedWalletIcons_1.emulatedWalletIcons.eternl, experimental: {
                        // without this, e.g. jpg.store fails to recognize eternl wallet
                        appVersion: { major: 1, minor: 9, patch: 5 },
                        enableLogs: () => {
                            /* empty */
                        },
                    } });
                (0, dapp_client_core_1.setIfDoesNotExist)(window, [connectorKind, 'eternl'], eternlConnector);
            }
        },
        eventHandler(method) {
            return __awaiter(this, void 0, void 0, function* () {
                if (method === 'connectorWindowClosed') {
                    // Unfortunately, CIP-30 does not make it possible to signal a
                    // disconnect to the dapp. We will just have to ignore this.
                }
            });
        },
    };
};
exports.createInjectedConnectorFactory = createInjectedConnectorFactory;
//# sourceMappingURL=index.js.map