"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const worker_threads_1 = require("worker_threads");
const mocks_1 = require("./mocks");
const connectorKind = 'connectorTesting';
const connectorPlatform = 'sso';
const createConnectorObject = (client) => {
    const injectedMethods = {
        isEnabled: () => __awaiter(void 0, void 0, void 0, function* () {
            return yield client.proxy.isEnabled();
        }),
    };
    return injectedMethods;
};
const setupRemotePortLister = (transfer, response) => {
    const port2 = transfer[0];
    port2.on('message', (e) => {
        var _a;
        if (e.method === 'isEnabled') {
            const reply = {
                senderContext: 'widget',
                targetContext: 'sdk',
                type: 'response',
                id: e.id,
                result: (_a = response === null || response === void 0 ? void 0 : response.isEnabled) !== null && _a !== void 0 ? _a : {
                    kind: 'success',
                    value: true,
                },
            };
            port2.postMessage(reply);
        }
    });
};
const handleSendPortMessage = (msg, transfer, response) => {
    if (msg.method !== 'initChannel')
        return;
    setupRemotePortLister(transfer, response);
};
describe('initChannelMessage function', () => {
    beforeEach(() => {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        global.MessageChannel = worker_threads_1.MessageChannel;
    });
    test('Expect connectorPlatform to be defined in window object', () => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, mocks_1.getMockedInjectConnectors)({
            createConnectorObject,
            connectorPlatform,
            connectorKind,
            sendPortPostMessage: () => { },
        });
        expect(window[connectorKind]).toBeDefined();
    }));
    test('Expect injected method to return proper output', () => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, mocks_1.getMockedInjectConnectors)({
            createConnectorObject,
            connectorPlatform,
            connectorKind,
            sendPortPostMessage: handleSendPortMessage,
        });
        const enabled = yield window.connectorTesting.nufiSSO.isEnabled();
        expect(enabled).toEqual(true);
    }));
    test('Expect `initChannelData` being send properly', () => __awaiter(void 0, void 0, void 0, function* () {
        const initChannelData = {
            type: 'widget',
            data: {
                connectorKind,
                connectorPlatform,
            },
        };
        yield (0, mocks_1.getMockedInjectConnectors)({
            createConnectorObject,
            connectorPlatform,
            connectorKind,
            initChannelData,
            sendPortPostMessage: (_message, transfer) => {
                const msg = _message;
                if (msg.method !== 'initChannel')
                    return;
                // Check that this was called with the `initChannelData` that we supplied.
                expect(msg.data).toEqual(initChannelData);
                setupRemotePortLister(transfer);
            },
        });
        const enabled = yield window.connectorTesting.nufiSSO.isEnabled();
        expect(enabled).toEqual(true);
    }));
    test('Expect to throw on error', () => __awaiter(void 0, void 0, void 0, function* () {
        yield (0, mocks_1.getMockedInjectConnectors)({
            createConnectorObject,
            connectorPlatform,
            connectorKind,
            sendPortPostMessage: (msg, transfer) => {
                handleSendPortMessage(msg, transfer, {
                    isEnabled: {
                        kind: 'error',
                        value: 'COULD_NOT_INIT',
                    },
                });
            },
        });
        expect(window.connectorTesting.nufiSSO.isEnabled()).rejects.toBe('COULD_NOT_INIT');
    }));
    test('Expect `onBeforeRequest` to have effect', () => __awaiter(void 0, void 0, void 0, function* () {
        const onBeforeRequest = jest.fn();
        yield (0, mocks_1.getMockedInjectConnectors)({
            createConnectorObject,
            connectorPlatform,
            connectorKind,
            onBeforeRequest,
            sendPortPostMessage: (msg, transfer) => {
                expect(onBeforeRequest).toHaveBeenCalled();
                handleSendPortMessage(msg, transfer);
            },
        });
        const enabled = yield window.connectorTesting.nufiSSO.isEnabled();
        expect(enabled).toEqual(true);
    }));
    test('Expect `onBeforeFirstSend` to have effect', () => __awaiter(void 0, void 0, void 0, function* () {
        let listenerReady = false;
        const onBeforeFirstSend = () => __awaiter(void 0, void 0, void 0, function* () {
            yield new Promise((resolve) => setTimeout(() => resolve(), 2000));
            listenerReady = true;
        });
        yield (0, mocks_1.getMockedInjectConnectors)({
            createConnectorObject,
            connectorPlatform,
            connectorKind,
            onBeforeFirstSend,
            sendPortPostMessage: (msg, transfer) => {
                expect(listenerReady).toBe(true);
                handleSendPortMessage(msg, transfer);
            },
        });
        const enabled = yield window.connectorTesting.nufiSSO.isEnabled();
        expect(enabled).toEqual(true);
    }));
});
//# sourceMappingURL=injectConnectors.test.js.map