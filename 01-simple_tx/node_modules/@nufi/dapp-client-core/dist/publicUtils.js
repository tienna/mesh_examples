"use strict";
// Example: `setIfDoesNotExist(into, ['a', 's', 'd'], what)` is the same as
// `into.a.s.d = what`, except that all intermediate objects are created if
// they don't already exists, and `d` also must not already exists.
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRandomUUID = exports.safeReplyToEvent = exports.objKeyByConnectorPlatform = exports.ensureChannelIsReady = exports.messageDirectionMatches = exports.set = exports.setIfDoesNotExist = exports.isNufiWidgetManagementMessage = exports.isNufiMessage = void 0;
const logging_1 = require("./core/logging");
const publicUtils_1 = require("./publicUtils");
var utils_1 = require("./core/utils");
Object.defineProperty(exports, "isNufiMessage", { enumerable: true, get: function () { return utils_1.isNufiMessage; } });
Object.defineProperty(exports, "isNufiWidgetManagementMessage", { enumerable: true, get: function () { return utils_1.isNufiWidgetManagementMessage; } });
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const setIfDoesNotExist = (into, path, what) => {
    for (const [i, segment] of path.entries()) {
        if (!Object.hasOwn(into, segment)) {
            into[segment] = i < path.length - 1 ? {} : what;
        }
        into = into[segment];
    }
};
exports.setIfDoesNotExist = setIfDoesNotExist;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const set = (into, path, what) => {
    for (const [i, segment] of path.entries()) {
        if (i === path.length - 1) {
            into[segment] = what;
        }
        else if (!Object.hasOwn(into, segment)) {
            into[segment] = {};
        }
        into = into[segment];
    }
};
exports.set = set;
const messageDirectionMatches = (msg, senderContext, targetContext) => msg.targetContext === targetContext && msg.senderContext === senderContext;
exports.messageDirectionMatches = messageDirectionMatches;
// Note that storing all previous "interval and handlers" and knowing which
// to invalidate/remove would be complex. Therefore we always keep only the
// last one.
// Note that this means that if user called `ensureChannelIsReady` multiple times,
// only the last call would eventually resolve.
// This should not be an issue as we are preventing re-injection of `injectConnectors`
// when the session is not meant to change.
let channelReadyGlobals = null;
const ensureChannelIsReady = (appId, connectorPlatform, connectorKind, sendPostMessage) => {
    const channelPingMessage = {
        connectorPlatform,
        appId,
        method: 'channelPing',
        data: {
            connectorKind,
            connectorPlatform,
        },
    };
    return new Promise((resolve) => {
        const channelReadyHandler = (e) => {
            // We are only checking message structure here, not the origin,
            // as this code anyways runs in untrusted environment.
            if (!(0, publicUtils_1.isNufiMessage)(e, connectorPlatform))
                return;
            const _e = e;
            if (_e.data.method === 'channelPing') {
                logging_1.logger.debug('"ensureChannelIsReady": received ping response');
                // Note that it is safe to clear interval and listener as each time when
                // calling `ensureChannelIsReady`, old interval and lister are cleared.
                // Therefore these must be the values associated with the same `ensureChannelIsReady` call.
                if (channelReadyGlobals != null) {
                    clearInterval(channelReadyGlobals.interval);
                    window.removeEventListener('message', channelReadyGlobals.handler);
                    channelReadyGlobals = null;
                }
                resolve(true);
            }
        };
        // When calling `ensureChannelIsReady` multiple times in a row, we want to ensure that
        // interval and listener from previous calls are cleared.
        // We can be certain that the handler is not called in the meantime as this function is sync.
        if (channelReadyGlobals != null) {
            clearInterval(channelReadyGlobals.interval);
            window.removeEventListener('message', channelReadyGlobals.handler);
        }
        channelReadyGlobals = {
            // Ping until we can safely establish port connection. Note that it must be registered into
            // global immediately after creation to avoid "stale" timeouts.
            interval: setInterval(() => {
                logging_1.logger.debug('"ensureChannelIsReady": sending ping request');
                sendPostMessage(channelPingMessage);
            }, 500),
            handler: channelReadyHandler,
        };
        // Only register once we stored the callback in global variable.
        window.addEventListener('message', channelReadyGlobals.handler);
    });
};
exports.ensureChannelIsReady = ensureChannelIsReady;
exports.objKeyByConnectorPlatform = {
    extension: 'nufi',
    snap: 'nufiSnap',
    sso: 'nufiSSO',
};
const safeReplyToEvent = (e, message) => {
    var _a;
    (_a = e.source) === null || _a === void 0 ? void 0 : _a.postMessage(message, { targetOrigin: e.origin });
};
exports.safeReplyToEvent = safeReplyToEvent;
var utils_2 = require("./core/utils");
Object.defineProperty(exports, "getRandomUUID", { enumerable: true, get: function () { return utils_2.getRandomUUID; } });
//# sourceMappingURL=publicUtils.js.map