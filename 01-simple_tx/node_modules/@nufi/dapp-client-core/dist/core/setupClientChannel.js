"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupClientChannel = void 0;
const publicUtils_1 = require("../publicUtils");
const assertion_1 = require("./assertion");
const logging_1 = require("./logging");
const utils_1 = require("./utils");
const cachedGetPort = (getPort) => {
    let port = null;
    const invalidatePort = () => {
        port = null;
    };
    return () => {
        if (port === null)
            port = getPort(invalidatePort);
        return port;
    };
};
// This sets up a connection from the dapp script to the nufi script.
// Note that the connection is only actually built up on the first request.
// When a method is called, a request is sent, and a promise is returned. This
// promise will be resolved whenever a response to the request arrives.
const setupClientChannel = ({ appId, connectorPlatform, currentContext, targetContext, eventHandler, onConnectorWindowClosed, sendPortPostMessage, onBeforeFirstSend, onBeforeRequest, initChannelData, }) => {
    logging_1.logger.debug('"setupClientChannel"');
    const { 
    // to be called by the listener waiting for the channel to respond
    setChannelReady, channelReady, } = (() => {
        let _setChannelReady;
        const channelReady = new Promise((resolve) => {
            _setChannelReady = resolve;
        });
        return {
            channelReady,
            setChannelReady: () => {
                logging_1.logger.debug('"setupClientChannel" setting channel ready');
                _setChannelReady(true);
            },
        };
    })();
    // Note that it is important that the logic of this function stays synchronous,
    // as some dappConnectors (extension) relies on it.
    if (onBeforeFirstSend != null) {
        logging_1.logger.debug('"setupClientChannel" calling onBeforeFirstSend');
        onBeforeFirstSend().then(() => {
            logging_1.logger.debug('"onBeforeFirstSend" finished');
            setChannelReady();
        });
    }
    else {
        setChannelReady();
    }
    const activeRequests = new Map();
    const getPort = cachedGetPort(() => {
        logging_1.logger.debug('"setupClientChannel" calling cachedGetPort');
        const channel = new MessageChannel();
        const initChannelMessage = {
            appId,
            connectorPlatform,
            method: 'initChannel',
            data: initChannelData,
        };
        // Note that even if port message is being sent sooner than this call is processed,
        // the listener on the other end will anyway receive the messages.
        sendPortPostMessage(initChannelMessage, [channel.port2]);
        channel.port1.onmessage = (e) => {
            // We are only checking message structure here, not the origin,
            // as this code anyways runs in untrusted environment.
            const msg = e.data;
            if (!(0, publicUtils_1.messageDirectionMatches)(msg, targetContext, currentContext))
                return;
            logging_1.logger.debug('"setupClientChannel" received port message', msg);
            switch (msg.type) {
                case 'response': {
                    const { id, result } = msg;
                    const msgPromiseCallbacks = activeRequests.get(id);
                    if (msgPromiseCallbacks) {
                        activeRequests.delete(id);
                        if (result.kind === 'success')
                            msgPromiseCallbacks.resolve(result.value);
                        else
                            msgPromiseCallbacks.reject(result.value);
                    }
                    break;
                }
                case 'event':
                    // "stray" events related to connections managed from other frames may arrive
                    // and we just want to ignore them as they are not related to "our" frame
                    if (msg.targetOrigin !== window.location.origin)
                        return;
                    if (msg.method === 'connectorWindowClosed') {
                        const errorResponse = (() => {
                            if (onConnectorWindowClosed != null) {
                                return onConnectorWindowClosed(msg);
                            }
                            return 'Connector window was closed';
                        })();
                        // Connector window closed, reject all requests in progress.
                        activeRequests.forEach(({ reject }) => reject(errorResponse));
                        activeRequests.clear();
                    }
                    eventHandler(msg.connectorKind, msg.method, msg.args);
                    break;
                default:
                    (0, assertion_1.safeAssertUnreachable)(msg);
            }
        };
        return channel.port1;
    });
    return (connectorKind, method, args) => __awaiter(void 0, void 0, void 0, function* () {
        const priorityTimestamp = new Date().toISOString();
        logging_1.logger.debug('"setupClientChannel" calling API', {
            connectorKind,
            method,
            args,
        });
        // this ensures that messages don't collide even if we inject the
        // connector objects into multiple (i)frames within the same page (i.e. tab)
        const id = (0, utils_1.getRandomUUID)();
        const request = {
            senderContext: currentContext,
            targetContext,
            id,
            connectorKind,
            method,
            args,
            priorityTimestamp,
        };
        onBeforeRequest === null || onBeforeRequest === void 0 ? void 0 : onBeforeRequest({ connectorKind, method, args });
        yield channelReady;
        logging_1.logger.debug('"setupClientChannel" posting port message', request);
        getPort().postMessage(request);
        return new Promise((resolve, reject) => activeRequests.set(id, { resolve, reject }));
    });
};
exports.setupClientChannel = setupClientChannel;
//# sourceMappingURL=setupClientChannel.js.map