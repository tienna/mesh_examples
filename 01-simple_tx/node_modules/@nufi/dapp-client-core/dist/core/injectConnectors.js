"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.injectConnectors = injectConnectors;
const logging_1 = require("./logging");
const sendRequestProxy_1 = require("./sendRequestProxy");
const setupClientChannel_1 = require("./setupClientChannel");
const utils_1 = require("./utils");
function createConnectors({ connectorsToInject, config, currentContext, targetContext, sendPortPostMessage, onBeforeFirstSend, onBeforeRequest, overridableWallets, initChannelData, }) {
    logging_1.logger.debug('"createConnectors"');
    const connectors = [];
    const eventHandlers = new Map();
    const multiplexedHandler = (0, setupClientChannel_1.setupClientChannel)({
        connectorPlatform: config.connectorPlatform,
        appId: config.appId,
        onBeforeRequest,
        onBeforeFirstSend,
        currentContext,
        targetContext,
        eventHandler: (connectorKind, method, args) => __awaiter(this, void 0, void 0, function* () {
            const eventHandler = eventHandlers.get(connectorKind);
            if (eventHandler) {
                yield eventHandler(method, args);
            }
        }),
        sendPortPostMessage,
        initChannelData,
    });
    const getWalletOverridesRequest = () => __awaiter(this, void 0, void 0, function* () {
        return (yield multiplexedHandler(null, 'getWalletOverrides', []));
    });
    // The "getWalletOverrides" call invoked as the very first call to the service worker is not 100% reliable,
    // so we need to harden it. As far as we tried, the service worker seems to not always wake up
    // fast enough for the request to go through on the first try (not sure if that's a bug in Chrome).
    // Happened especially when opening a dapp right after opening the browser.
    // https://stackoverflow.com/questions/69816133/mv3-serviceworker-wont-wake-up-when-sent-a-message-from-the-contentscript
    const getWalletOverrides = overridableWallets.length > 0
        ? () => (0, utils_1.hardenUnreliableRequest)(getWalletOverridesRequest, Object.fromEntries(overridableWallets.map((w) => [w, false])))
        : null;
    for (const connectorKind of Object.keys(config.connectors)) {
        try {
            const sendRequest = multiplexedHandler.bind(undefined, connectorKind);
            const proxy = (0, sendRequestProxy_1.sendRequestProxy)(sendRequest);
            let connectorWindowOpen = false;
            const client = {
                sendRequest,
                proxy,
                openConnectorWindow: (meta) => __awaiter(this, void 0, void 0, function* () {
                    logging_1.logger.debug('"createConnectors": openConnectorWindow called');
                    yield proxy.openConnectorWindow(meta);
                    connectorWindowOpen = true;
                    logging_1.logger.debug('"createConnectors": openConnectorWindow finished');
                }),
                closeConnectorWindow: () => __awaiter(this, void 0, void 0, function* () {
                    logging_1.logger.debug('"createConnectors": closeConnectorWindow called');
                    yield proxy.closeConnectorWindow();
                    connectorWindowOpen = false;
                    logging_1.logger.debug('"createConnectors": closeConnectorWindow finished');
                }),
                // Original method used by connectors that have to be closed after Dapp refresh.
                // Consider migrating other connectors to `isConnectorWindowOpenAsync`.
                isConnectorWindowOpen: () => {
                    logging_1.logger.debug(`"createConnectors": isConnectorWindowOpen ${connectorWindowOpen}`);
                    return connectorWindowOpen;
                },
                isConnectorWindowOpenAsync: () => __awaiter(this, void 0, void 0, function* () {
                    try {
                        logging_1.logger.debug(`"createConnectors": isConnectorWindowOpenAsync called`);
                        const res = yield proxy.isConnectorWindowOpen();
                        logging_1.logger.debug(`"createConnectors": isConnectorWindowOpenAsync result ${res}`);
                        return res;
                    }
                    catch (err) {
                        // If connector window is not open we are not allowed to proxy
                        // events to it so this will fail. In such case all we can do
                        // is to consider the window closed.
                        logging_1.logger.debug('"createConnectors": isConnectorWindowOpenAsync error');
                        return false;
                    }
                }),
            };
            const connector = connectorsToInject[connectorKind](client, config);
            if (connector) {
                const eventHandler = (method, args) => __awaiter(this, void 0, void 0, function* () {
                    if (method === 'connectorWindowClosed') {
                        connectorWindowOpen = false;
                    }
                    yield connector.eventHandler(method, args);
                });
                eventHandlers.set(connectorKind, eventHandler);
                connectors.push(connector);
            }
        }
        catch (e) {
            // We will continue with the other connectors even if one of them fails.
            // eslint-disable-next-line no-console
            console.error(e);
        }
    }
    return [connectors, getWalletOverrides];
}
/**
 * Initialize already created connectors in a race-condition safe order.
 *
 * Note that declaring this function "async" causes race-conditions
 * with content script and page script, as the content script is no
 * longer guaranteed to end before the page script is executed.
 * This is mainly issue in the EVM ecosystem.
 *
 * Therefore we:
 * 1. Sort connectors, so that the ones with simple "inject" without any
 * asynchronous dependencies comes first.
 * 2. Inject connectors with synchronous "inject" without calling "await", so
 * that these functions are guaranteed to run before page load (even though the
 * function is "async", but no "await" was called until this point).
 * 3. Inject the remaining connectors after doing async logic (e.g. fetching wallet overrides).
 */
const initializeConnectors = (_connectors, getWalletOverrides) => __awaiter(void 0, void 0, void 0, function* () {
    const simpleConnectorsToInit = _connectors.filter((c) => c.type === 'simple');
    for (const connector of simpleConnectorsToInit) {
        try {
            logging_1.logger.debug(`"createConnectors": ${connector.connectorKind} initialization start`);
            connector.inject(window);
            logging_1.logger.debug(`"createConnectors": ${connector.connectorKind} initialization finished`);
        }
        catch (e) {
            // We will continue with the other connectors even if one of them fails.
            // eslint-disable-next-line no-console
            console.error(e);
        }
    }
    const connectorsWithOverridesToInit = _connectors.filter((c) => c.type === 'withOverrides');
    const walletOverrides = getWalletOverrides ? yield getWalletOverrides() : null;
    for (const connector of connectorsWithOverridesToInit) {
        try {
            connector.inject(window, walletOverrides);
        }
        catch (e) {
            // We will continue with the other connectors even if one of them fails.
            // eslint-disable-next-line no-console
            console.error(e);
        }
    }
});
function injectConnectors(params) {
    return __awaiter(this, void 0, void 0, function* () {
        const [connectorsToInitialize, getWalletOverrides] = createConnectors(params);
        // Be mindful with `await` in this file! See `initializeConnectors` explanation of how
        // it is safe to use it when initializing connectors.
        yield initializeConnectors(connectorsToInitialize, getWalletOverrides);
    });
}
//# sourceMappingURL=injectConnectors.js.map