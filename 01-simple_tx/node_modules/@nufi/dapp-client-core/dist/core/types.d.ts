type NewType<name extends string, base = string> = base & {
    [_ in `__NewType_${name}`]: undefined;
};
export type UntypedConnectorKind = string;
export type CoreNufiMessage = {
    appId: string;
    method: string;
};
export type NufiMessage = CoreNufiMessage & {
    connectorPlatform: ConnectorPlatform;
};
export type WidgetSessionData = {
    connectorPlatform: ConnectorPlatform;
    connectorKind: UntypedConnectorKind;
};
export type InitChannelData = {
    type: 'widget';
    data: WidgetSessionData;
};
export type InitChannelMessage = NufiMessage & {
    method: 'initChannel';
    data?: InitChannelData;
};
export type PingChannelMessage = NufiMessage & {
    method: 'channelPing';
    data: WidgetSessionData;
};
export type RequestArgument = NewType<'RequestArgument', []>;
export type SuccessResponse = NewType<'SuccessResponse', []>;
export type ErrorResponse = NewType<'ErrorResponse', []>;
type TrustedRequestContext = {
    origin: string;
    favIconUrl?: string;
};
export type RequestContext = {
    trusted: TrustedRequestContext;
};
export type ScriptContext = 'injectedScript' | 'contentScript' | 'serviceWorker' | 'connectorWindow' | 'app' | 'sdk' | 'widget';
export interface MessageHeader {
    senderContext: ScriptContext;
    targetContext: ScriptContext;
}
export interface RequestMessage<ConnectorKind extends UntypedConnectorKind> extends MessageHeader {
    /** The unique identifier of this request (random UUID). */
    id: string;
    connectorKind: null | ConnectorKind;
    method: string;
    args: RequestArgument[];
    priorityTimestamp: string;
}
export type Response<T, E> = {
    kind: 'success';
    value: T;
} | {
    kind: 'error';
    value: E;
};
export type MessageToClientResponse = MessageHeader & {
    type: 'response';
    id: string;
    result: Response<SuccessResponse, ErrorResponse>;
};
export type MessageToClientEvent<ConnectorKind extends UntypedConnectorKind> = MessageHeader & {
    type: 'event';
    targetOrigin: string;
    connectorKind: ConnectorKind;
    method: string;
    args: any[];
};
export type MessageToClient<ConnectorKind extends UntypedConnectorKind> = MessageToClientResponse | MessageToClientEvent<ConnectorKind>;
export type SendRequest = (method: string, args: RequestArgument[]) => Promise<SuccessResponse>;
export type ServiceEvent = 'connectorWindowClosed' | 'connectorWindowOpen';
export type EventHandler = (method: ServiceEvent, args: any[]) => Promise<void>;
export type Handler = (method: string, args: RequestArgument[], context: RequestContext) => Promise<Response<SuccessResponse, ErrorResponse>>;
export interface MessagingClient {
    sendRequest(method: string, args: any[]): Promise<SuccessResponse>;
    proxy: {
        [_ in string]: (...args: any[]) => Promise<any>;
    };
    openConnectorWindow(meta?: unknown): Promise<void>;
    closeConnectorWindow(): Promise<void>;
    /** Get the state of the connector window tracked automatically on the client side. */
    isConnectorWindowOpen(): boolean;
    /** Get the state of the connector window tracked in connector window that remains
     * open even on Dapp refresh. */
    isConnectorWindowOpenAsync(): Promise<boolean>;
}
/**
 * This represents a connector object, which can implement arbitrary things,
 * and is different across each connector. We can't model that in TS, so we
 * just fake the type.
 */
export type ConnectorObject = NewType<'ConnectorObject', []>;
export type DappConnectorsConfig = {
    connectors: Record<UntypedConnectorKind, unknown>;
    appId: string;
    connectorPlatform: ConnectorPlatform;
};
export type WalletOverrides = Record<string, boolean>;
export type InjectedConnectorFactory<Config extends DappConnectorsConfig> = (client: MessagingClient, config: Config) => InjectedConnector;
interface InjectedConnectorBase {
    connectorKind: UntypedConnectorKind;
    eventHandler: EventHandler;
}
export interface SimpleInjectedConnector extends InjectedConnectorBase {
    inject: (window: Window) => void;
    type: 'simple';
}
export interface InjectedConnectorWithOverrides extends InjectedConnectorBase {
    inject: (window: Window, overrides: WalletOverrides | null) => void;
    type: 'withOverrides';
}
export type InjectedConnector = SimpleInjectedConnector | InjectedConnectorWithOverrides;
export type ConnectorPlatform = 'extension' | 'sso' | 'snap';
export {};
//# sourceMappingURL=types.d.ts.map