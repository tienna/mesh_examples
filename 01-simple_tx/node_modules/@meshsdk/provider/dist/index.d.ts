import { IFetcher, IListener, ISubmitter, IEvaluator, AccountInfo, TransactionInfo, UTxO, AssetMetadata, BlockInfo, Asset, Protocol, GovernanceProposalInfo, Action, Network } from '@meshsdk/common';

/**
 * The BeginProvider class provides methods to query Begin ID.
 *
 * To use this provider, simply create a new instance of the BeginProvider class and call the desired method.
 *
 * ```typescript
 * import { BeginProvider } from "@meshsdk/core";
 *
 * const beginProvider = new BeginProvider();
 * ```
 */
declare class BeginProvider {
    private readonly apikey;
    private readonly chainNumber;
    private readonly domainUrl;
    /**
     * Creates a new instance of the BeginProvider.
     * @param apikey The API key for querying Begin ID.
     */
    constructor(apikey?: string);
    /**
     * Given a Begin ID, resolves the address and other information.
     * @param name name of Begin ID, e.g. `mesh`
     * @param url optional URL to override the default: https://resolveidaddress-ylo5dtxzdq-uc.a.run.app
     * @returns
     * - name: string
     * - domain: string
     * - image: string
     * - address: string
     */
    resolveAddress(name: string, url?: string): Promise<{
        name: string;
        domain: string;
        image: string;
        address: string;
    }>;
    /**
     * Given an address, resolves the Begin ID and other information.
     * @param address address to resolve
     * @param url optional URL to override the default: https://resolveIdReserveAddress-ylo5dtxzdq-uc.a.run.app
     * @returns
     * - name: string
     * - domain: string
     * - image: string
     * - address: string
     */
    resolveAdressReverse(address: string, url?: string): Promise<{
        name: string;
        domain: string;
        image: string;
        address: string;
    }>;
}

type BlockfrostSupportedNetworks = "mainnet" | "preview" | "preprod";
/**
 * Blockfrost provides restful APIs which allows your app to access information stored on the blockchain.
 *
 * Usage:
 * ```
 * import { BlockfrostProvider } from "@meshsdk/core";
 *
 * const blockchainProvider = new BlockfrostProvider('<Your-API-Key>');
 */
declare class BlockfrostProvider implements IFetcher, IListener, ISubmitter, IEvaluator {
    private readonly _axiosInstance;
    private readonly _network;
    private submitTxToBytes;
    /**
     * If you are using a privately hosted Blockfrost instance, you can set the URL in the parameter.
     * @param baseUrl The base URL of the instance.
     */
    constructor(baseUrl: string);
    /**
     * If you are using [Blockfrost](https://blockfrost.io/) hosted instance, you can set the project ID in the parameter.
     * @param projectId The project ID of the instance.
     * @param version The version of the API. Default is 0.
     */
    constructor(projectId: string, version?: number);
    setSubmitTxToBytes(value: boolean): void;
    /**
     * Evaluates the resources required to execute the transaction
     * @param tx - The transaction to evaluate
     */
    evaluateTx(cbor: string): Promise<any>;
    /**
     * Obtain information about a specific stake account.
     * @param address - Wallet address to fetch account information
     */
    fetchAccountInfo(address: string): Promise<AccountInfo>;
    /**
     * Fetches the assets for a given address.
     * @param address - The address to fetch assets for
     * @returns A map of asset unit to quantity
     */
    fetchAddressAssets(address: string): Promise<{
        [key: string]: string;
    }>;
    /**
     * Transactions for an address.
     * @param address
     * @returns - partial TransactionInfo
     */
    fetchAddressTransactions(address: string): Promise<TransactionInfo[]>;
    /**
     * UTXOs of the address.
     * @param address - The address to fetch UTXO
     * @param asset - UTXOs of a given assetâ€‹
     * @returns - Array of UTxOs
     */
    fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]>;
    /**
     * Fetches the asset addresses for a given asset.
     * @param asset - The asset to fetch addresses for
     */
    fetchAssetAddresses(asset: string): Promise<{
        address: string;
        quantity: string;
    }[]>;
    /**
     * Fetches the metadata for a given asset.
     * @param asset - The asset to fetch metadata for
     * @returns The metadata for the asset
     */
    fetchAssetMetadata(asset: string): Promise<AssetMetadata>;
    /**
     * Fetches the metadata for a given asset.
     * @param asset - The asset to fetch metadata for
     * @returns The metadata for the asset
     */
    fetchLatestBlock(): Promise<BlockInfo>;
    fetchBlockInfo(hash: string): Promise<BlockInfo>;
    fetchCollectionAssets(policyId: string, cursor?: number): Promise<{
        assets: Asset[];
        next: string | number | null;
    }>;
    fetchHandle(handle: string): Promise<AssetMetadata>;
    fetchHandleAddress(handle: string): Promise<string>;
    fetchProtocolParameters(epoch?: number): Promise<Protocol>;
    fetchTxInfo(hash: string): Promise<TransactionInfo>;
    fetchUTxOs(hash: string, index?: number): Promise<UTxO[]>;
    fetchGovernanceProposal(txHash: string, certIndex: number): Promise<GovernanceProposalInfo>;
    /**
     * A generic method to fetch data from a URL.
     * @param url - The URL to fetch data from
     * @returns - The data fetched from the URL
     */
    get(url: string): Promise<any>;
    /**
     * A generic method to post data to a URL.
     * @param url - The URL to fetch data from
     * @param body - Payload
     * @param headers - Specify headers, default: { "Content-Type": "application/json" }
     * @returns - Data
     */
    post(url: string, body: any, headers?: {
        "Content-Type": string;
    }): Promise<any>;
    /**
     * Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.
     * @param txHash - The transaction hash to listen for confirmation
     * @param callback - The callback function to call when the transaction is confirmed
     * @param limit - The number of blocks to wait for confirmation
     */
    onTxConfirmed(txHash: string, callback: () => void, limit?: number): void;
    /**
     * Submit a serialized transaction to the network.
     * @param tx - The serialized transaction in hex to submit
     * @returns The transaction hash of the submitted transaction
     */
    submitTx(tx: string): Promise<string>;
    private resolveScriptRef;
    private toUTxO;
    private fetchPlutusScriptCBOR;
    private fetchNativeScriptJSON;
}

declare const HYDRA_STATUS: {
    readonly IDLE: "IDLE";
    readonly DISCONNECTED: "DISCONNECTED";
    readonly CONNECTING: "CONNECTING";
    readonly CONNECTED: "CONNECTED";
    readonly INITIALIZING: "INITIALIZING";
    readonly OPEN: "OPEN";
    readonly CLOSED: "CLOSED";
    readonly FANOUT_POSSIBLE: "FANOUT_POSSIBLE";
    readonly FINAL: "FINAL";
};
type HydraStatus = (typeof HYDRA_STATUS)[keyof typeof HYDRA_STATUS];

/**
 * HydraProvider is a tool for administrating & interacting with Hydra Heads.
 *
 * Usage:
 * ```
 * import { HydraProvider } from "@meshsdk/core";
 *
 * const hydraProvider = new HydraProvider({url:'http://123.45.67.890:4001'});
 */
declare class HydraProvider implements IFetcher, ISubmitter {
    private _connection;
    private _status;
    private readonly _eventEmitter;
    private readonly _axiosInstance;
    constructor({ url, history }: {
        url: string;
        history?: boolean;
    });
    connect(): Promise<void>;
    fetchAccountInfo(address: string): Promise<AccountInfo>;
    fetchAddressUTxOs(address: string): Promise<UTxO[]>;
    fetchAssetAddresses(asset: string): Promise<{
        address: string;
        quantity: string;
    }[]>;
    fetchAssetMetadata(asset: string): Promise<AssetMetadata>;
    fetchBlockInfo(hash: string): Promise<BlockInfo>;
    fetchCollectionAssets(policyId: string, cursor?: string | number | undefined): Promise<{
        assets: Asset[];
        next: string | number | null;
    }>;
    fetchGovernanceProposal(txHash: string, certIndex: number): Promise<GovernanceProposalInfo>;
    fetchProtocolParameters(epoch?: number): Promise<Protocol>;
    fetchTxInfo(hash: string): Promise<TransactionInfo>;
    fetchUTxOs(): Promise<UTxO[]>;
    /**
     * A generic method to fetch data from a URL.
     * @param url - The URL to fetch data from
     * @returns - The data fetched from the URL
     */
    get(url: string): Promise<any>;
    /**
     * Submit a transaction to the Hydra node. Note, unlike other providers, Hydra does not return a transaction hash.
     * @param tx - The transaction in CBOR hex format
     */
    submitTx(tx: string): Promise<string>;
    /**
     * Initializes a new Head. This command is a no-op when a Head is already open and the server will output an CommandFailed message should this happen.
     */
    initializesHead(): Promise<void>;
    send(data: any): void;
    onMessage(callback: (message: any) => void): void;
    onStatusChange(callback: (status: HydraStatus) => void): void;
}

type KoiosSupportedNetworks = "api" | "preview" | "preprod" | "guild";
declare class KoiosProvider implements IFetcher, IListener, ISubmitter {
    private readonly _axiosInstance;
    private readonly _network;
    constructor(baseUrl: string);
    constructor(network: KoiosSupportedNetworks, token: string, version?: number);
    fetchAccountInfo(address: string): Promise<AccountInfo>;
    fetchAddressAssets(address: string): Promise<{
        [key: string]: string;
    }>;
    /**
     * Transactions for an address.
     * @param address
     * @returns - partial TransactionInfo
     */
    fetchAddressTransactions(address: string): Promise<TransactionInfo[]>;
    fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]>;
    fetchAssetAddresses(asset: string): Promise<{
        address: string;
        quantity: string;
    }[]>;
    fetchAssetMetadata(asset: string): Promise<AssetMetadata>;
    fetchBlockInfo(hash: string): Promise<BlockInfo>;
    fetchCollectionAssets(policyId: string): Promise<{
        assets: Asset[];
    }>;
    fetchHandle(handle: string): Promise<AssetMetadata>;
    fetchHandleAddress(handle: string): Promise<string>;
    fetchProtocolParameters(epoch?: number): Promise<Protocol>;
    fetchTxInfo(hash: string): Promise<TransactionInfo>;
    fetchUTxOs(hash: string, index?: number): Promise<UTxO[]>;
    fetchGovernanceProposal(txHash: string, certIndex: number): Promise<GovernanceProposalInfo>;
    /**
     * A generic method to fetch data from a URL.
     * @param url - The URL to fetch data from
     * @returns - The data fetched from the URL
     */
    get(url: string): Promise<any>;
    /**
     * A generic method to post data to a URL.
     * @param url - The URL to fetch data from
     * @param body - Payload
     * @param headers - Specify headers, default: { "Content-Type": "application/json" }
     * @returns - Data
     */
    post(url: string, body: any, headers?: {
        "Content-Type": string;
    }): Promise<any>;
    onTxConfirmed(txHash: string, callback: () => void, limit?: number): void;
    submitTx(tx: string): Promise<string>;
    private toUTxO;
    private resolveScriptRef;
}

type MaestroSupportedNetworks = "Mainnet" | "Preprod" | "Preview";
interface MaestroConfig {
    network: MaestroSupportedNetworks;
    apiKey: string;
    turboSubmit?: boolean;
}
declare class MaestroProvider implements IFetcher, ISubmitter, IEvaluator, IListener {
    private readonly _axiosInstance;
    private readonly _amountsAsStrings;
    private readonly _network;
    submitUrl: string;
    constructor({ network, apiKey, turboSubmit }: MaestroConfig);
    evaluateTx(cbor: string): Promise<Omit<Action, "data">[]>;
    fetchAccountInfo(address: string): Promise<AccountInfo>;
    fetchAddressAssets(address: string): Promise<{
        [key: string]: string;
    }>;
    fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]>;
    fetchAssetAddresses(asset: string): Promise<{
        address: string;
        quantity: string;
    }[]>;
    fetchAssetMetadata(asset: string): Promise<AssetMetadata>;
    fetchBlockInfo(hash: string): Promise<BlockInfo>;
    fetchCollectionAssets(policyId: string, cursor?: string): Promise<{
        assets: Asset[];
        next: string | number | null;
    }>;
    fetchHandle(handle: string): Promise<object>;
    fetchHandleAddress(handle: string): Promise<string>;
    fetchProtocolParameters(epoch?: number): Promise<Protocol>;
    fetchTxInfo(hash: string): Promise<TransactionInfo>;
    fetchUTxOs(hash: string, index?: number): Promise<UTxO[]>;
    fetchGovernanceProposal(txHash: string, certIndex: number): Promise<GovernanceProposalInfo>;
    get(url: string): Promise<any>;
    onTxConfirmed(txHash: string, callback: () => void, limit?: number): void;
    submitTx(tx: string): Promise<string>;
    private toUTxO;
    private resolveScript;
}

declare class OgmiosProvider implements IEvaluator, ISubmitter {
    private readonly _baseUrl;
    constructor(baseUrl: string);
    constructor(network: Network);
    evaluateTx(tx: string): Promise<Omit<Action, "data">[]>;
    onNextTx(callback: (tx: unknown) => void): Promise<() => void>;
    submitTx(tx: string): Promise<string>;
    private open;
    private send;
}

/**
 * A UTxO RPC Provider for [MeshJS](https://meshjs.dev/) Transaction Builder Library.
 *
 * Example usage of how to use the UTxO RPC provider with Mesh to build and submit a transaction.
 * ```
 * // Step #1
 * // Import Mesh SDK and UTxO RPC provider
 * import { Transaction, MeshWallet, U5CProvider } from "@meshsdk/core";
 *
 * async function main() {
 *   // Step #2
 *   // Create a new U5C provider
 *   const provider = new U5CProvider({
 *     url: "http://localhost:50051",
 *     headers: {
 *       "dmtr-api-key": "<api-key>",
 *     },
 *   });
 *
 *   // Step #3
 *   // Create a new wallet from a mnemonic
 *   const wallet = new MeshWallet({
 *     networkId: 0, // 0: testnet, 1: mainnet
 *     fetcher: provider,
 *     submitter: provider,
 *     key: {
 *       type: "mnemonic",
 *       words: [
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *         "solution",
 *       ],
 *     },
 *   });
 *
 *   // Optional: Print the wallet address
 *   console.log(wallet.getChangeAddress());
 *
 *   // Optional: Print the wallet utxos
 *   console.log(await provider.fetchAddressUTxOs(wallet.getChangeAddress()));
 *
 *   // Step #4
 *   // Create an example transaction that sends 5 ADA to an address
 *   const tx = new Transaction({
 *     initiator: wallet,
 *     verbose: false,
 *   }).sendLovelace(
 *     "addr_test1vpvx0sacufuypa2k4sngk7q40zc5c4npl337uusdh64kv0c7e4cxr",
 *     "5000000"
 *   );
 *   const unsignedTx = await tx.build();
 *
 *   // Step #5
 *   // Sign the transaction
 *   const signedTx = wallet.signTx(unsignedTx);
 *
 *   // Step #6
 *   // Submit the transaction to the blockchain network
 *   const txId = await provider.submitTx(signedTx);
 *
 *   // Optional: Print the transaction ID
 *   console.log("Transaction ID", txId);
 * }
 *
 * main().catch(console.error);
 * ```
 */
declare class U5CProvider implements IFetcher, ISubmitter, IEvaluator, IListener {
    private queryClient;
    private submitClient;
    /**
     * Constructor initializes the query and submit clients with provided URL and optional headers.
     * @param url - The base URL for interacting with Cardano nodes.
     * @param headers - Optional HTTP headers for API requests.
     */
    constructor({ url, headers, }: {
        url: string;
        headers?: Record<string, string>;
    });
    /**
     * Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.
     * @param txHash - The transaction hash to listen for confirmation
     * @param callback - The callback function to call when the transaction is confirmed
     * @param limit - The number of blocks to wait for confirmation
     */
    onTxConfirmed(txHash: string, callback: () => void, limit?: number): void;
    /**
     * Evaluates the resources required to execute the transaction
     * @param tx - The transaction to evaluate
     */
    evaluateTx(tx: string): Promise<Omit<Action, "data">[]>;
    /**
     * Submit a serialized transaction to the network.
     * @param tx - The serialized transaction in hex to submit
     * @returns The transaction hash of the submitted transaction
     */
    submitTx(tx: string): Promise<string>;
    /**
     * Obtain information about a specific stake account.
     * @param address - Wallet address to fetch account information
     */
    fetchAccountInfo(address: string): Promise<AccountInfo>;
    fetchAddressAssets(address: string): Promise<{
        [key: string]: string;
    }>;
    /**
     * Fetches the UTxOs for a given address.
     * @param address - The address to fetch UTxOs for
     * @param asset - The asset to filter UTxOs by (optional)
     * @returns UTxOs for the given address
     */
    fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]>;
    /**
     * Fetches the asset addresses for a given asset.
     * @param asset - The asset to fetch addresses for
     */
    fetchAssetAddresses(asset: string): Promise<{
        address: string;
        quantity: string;
    }[]>;
    /**
     * Fetches the metadata for a given asset.
     * @param asset - The asset to fetch metadata for
     */
    fetchAssetMetadata(asset: string): Promise<AssetMetadata>;
    /**
     * Fetches the block information for a given block hash.
     * @param hash - The block hash to fetch block information for
     */
    fetchBlockInfo(hash: string): Promise<BlockInfo>;
    /**
     * Fetches the collection assets for a given policy ID.
     * @param policyId - The policy ID to fetch collection assets for
     * @param cursor - The cursor to fetch the next set of assets (optional)
     */
    fetchCollectionAssets(policyId: string, cursor?: number | string): Promise<{
        assets: Asset[];
        next?: string | number | null;
    }>;
    /**
     * Fetches the information (AssetMetadata) for a given handle.
     * @param handle - The handle to fetch information for
     */
    fetchHandle(handle: string): Promise<object>;
    /**
     * Resolve the handle's address from the handle.
     * @param handle - The handle to resolve
     */
    fetchHandleAddress(handle: string): Promise<string>;
    /**
     * Fetches protocol parameters
     */
    fetchProtocolParameters(epoch?: number): Promise<Protocol>;
    /**
     * Fetches transaction info for a given hash.
     * @param hash - The transaction hash
     */
    fetchTxInfo(hash: string): Promise<TransactionInfo>;
    /**
     * Fetches output UTxOs of a given transaction hash.
     * @param hash - The transaction hash
     */
    fetchUTxOs(hash: string): Promise<UTxO[]>;
    fetchGovernanceProposal(txHash: string, certIndex: number): Promise<GovernanceProposalInfo>;
    get(url: string): Promise<any>;
    /**
     * Waits for transaction confirmation within a given timeout.
     * @param txId - The transaction hash.
     * @param timeout - Optional timeout in milliseconds.
     * @returns True if the transaction is confirmed within the timeout, otherwise false.
     */
    awaitTransactionConfirmation(txId: string, timeout?: number): Promise<boolean>;
    /**
     * Helper function to convert an RPC UTxO object to a Mesh UTxO object.
     * @param rpcTxoRef - The transaction output reference from RPC.
     * @param rpcTxOutput - The transaction output details from RPC.
     * @returns A formatted UTxO object.
     */
    private _rpcUtxoToMeshUtxo;
    /**
     * Converts RPC protocol parameters to a Mesh Protocol object.
     * @param rpcPParams - The protocol parameters from the RPC.
     * @returns A Protocol object.
     */
    private _rpcPParamsToProtocol;
}

/**
 * Yaci DevKit is a development tool designed for rapid and efficient Cardano blockchain development. It allows developers to create and destroy custom Cardano devnets in seconds, providing fast feedback loops and simplifying the iteration process.
 *
 * Get started:
 * ```typescript
 * import { YaciProvider } from "@meshsdk/core";
 * const blockchainProvider = new YaciProvider('<YACI_URL>', '<OPTIONAL_ADMIN_URL>');
 * ```
 */
declare class YaciProvider implements IFetcher, IListener, ISubmitter, IEvaluator {
    private readonly _axiosInstance;
    private readonly _adminAxiosInstance;
    /**
     * Set the URL of the instance.
     * @param baseUrl The base URL of the instance.
     */
    constructor(baseUrl?: string, adminUrl?: string);
    fetchAccountInfo(address: string): Promise<AccountInfo>;
    private resolveScriptRef;
    private toUTxO;
    fetchAddressAssets(address: string): Promise<{
        [key: string]: string;
    }>;
    fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]>;
    fetchAssetAddresses(asset: string): Promise<{
        address: string;
        quantity: string;
    }[]>;
    fetchAssetMetadata(asset: string): Promise<AssetMetadata>;
    fetchBlockInfo(hash: string): Promise<BlockInfo>;
    fetchCollectionAssets(policyId: string, cursor?: number): Promise<{
        assets: Asset[];
        next: string | number | null;
    }>;
    fetchHandle(handle: string): Promise<object>;
    fetchHandleAddress(handle: string): Promise<string>;
    fetchProtocolParameters(epoch?: number): Promise<Protocol>;
    fetchTxInfo(hash: string): Promise<TransactionInfo>;
    fetchUTxOs(hash: string, index?: number): Promise<UTxO[]>;
    fetchGovernanceProposal(txHash: string, certIndex: number): Promise<GovernanceProposalInfo>;
    get(url: string): Promise<any>;
    onTxConfirmed(txHash: string, callback: () => void, limit?: number): void;
    submitTx(txHex: string): Promise<string>;
    evaluateTx(txHex: string): Promise<Omit<Action, "data">[]>;
    getDevnetInfo(): Promise<void>;
    getGenesisByEra(era: string): Promise<void>;
    /**
     * Topup address with ADA
     * @param address - Address to topup
     * @param amount - Amount to topup
     */
    addressTopup(address: string, amount: string): Promise<void>;
    private fetchPlutusScriptCBOR;
    private fetchNativeScriptJSON;
}

type AssetAddress = {
    address: string;
    quantity: string;
};
/**
 * OfflineFetcher implements the IFetcher interface to provide offline access to blockchain data.
 * This class allows working with pre-loaded blockchain data without requiring network connectivity.
 * It's useful for testing, development, and scenarios where offline operation is needed.
 *
 * The class maintains internal storage for various blockchain data types:
 * - Account information
 * - UTXOs (Unspent Transaction Outputs)
 * - Asset addresses and metadata
 * - Block information
 * - Protocol parameters
 * - Transaction information
 *
 * Example usage:
 * ```typescript
 * import { OfflineFetcher } from '@meshsdk/core';
 *
 * // Create a new instance
 * const fetcher = new OfflineFetcher();
 *
 * // Add some blockchain data
 * fetcher.addAccount(address, accountInfo);
 * fetcher.addUTxOs(utxos);
 *
 * // Use the fetcher with MeshWallet
 * const wallet = new MeshWallet({
 *   networkId: 0,
 *   fetcher: fetcher,
 *   key: {
 *     type: 'address',
 *     address: walletAddress
 *   }
 * });
 * ```
 */
declare class OfflineFetcher implements IFetcher {
    private accounts;
    private utxos;
    private assetAddresses;
    private assetMetadata;
    private blocks;
    private collections;
    private protocolParameters;
    private transactions;
    private paginate;
    /**
     * Fetches account information for a given address.
     * @param address - Address to fetch info for
     * @returns Promise resolving to account information
     * @throws Error if account not found
     */
    fetchAccountInfo(address: string): Promise<AccountInfo>;
    /**
     * Fetches UTXOs for a given address, optionally filtered by asset.
     * @param address - Address to fetch UTXOs for
     * @param asset - Optional asset ID to filter UTXOs
     * @returns Promise resolving to array of UTXOs
     */
    fetchAddressUTxOs(address: string, asset?: string): Promise<UTxO[]>;
    /**
     * Fetches addresses holding a specific asset.
     * @param asset - Asset identifier
     * @returns Promise resolving to array of asset addresses and quantities
     */
    fetchAssetAddresses(asset: string): Promise<AssetAddress[]>;
    /**
     * Fetches all assets associated with an address.
     * @param address - Address to fetch assets for
     * @returns Promise resolving to array of assets held by the address
     */
    fetchAddressAssets(address: string): Promise<Asset[]>;
    /**
     * Fetches metadata for a specific asset.
     * @param asset - Asset identifier
     * @returns Promise resolving to asset metadata
     * @throws Error if asset metadata not found
     */
    fetchAssetMetadata(asset: string): Promise<AssetMetadata>;
    /**
     * Fetches information about a specific block.
     * @param hash - Block hash
     * @returns Promise resolving to block information
     * @throws Error if block not found
     */
    fetchBlockInfo(hash: string): Promise<BlockInfo>;
    /**
     * Fetches assets in a collection (by policy ID) with pagination.
     * @param policyId - Policy ID of the collection
     * @param cursor - Optional pagination cursor
     * @returns Promise resolving to paginated assets and next cursor
     * @throws Error if collection not found or invalid cursor
     */
    fetchCollectionAssets(policyId: string, cursor?: number | string): Promise<{
        assets: Asset[];
        next?: string | number;
    }>;
    /**
     * Fetches metadata for a handle.
     * @param handle - Handle to fetch metadata for
     * @returns Promise resolving to handle metadata
     * @throws Error if handle not found or invalid
     */
    fetchHandle(handle: string): Promise<AssetMetadata>;
    /**
     * Fetches address associated with a handle.
     * @param handle - Handle to fetch address for
     * @returns Promise resolving to address
     * @throws Error if no address found for handle
     */
    fetchHandleAddress(handle: string): Promise<string>;
    /**
     * Fetches protocol parameters for a specific epoch.
     * @param epoch - Epoch number
     * @returns Promise resolving to protocol parameters
     * @throws Error if parameters not found for epoch
     */
    fetchProtocolParameters(epoch?: number): Promise<Protocol>;
    /**
     * Fetches information about a specific transaction.
     * @param hash - Transaction hash
     * @returns Promise resolving to transaction information
     * @throws Error if transaction not found
     */
    fetchTxInfo(hash: string): Promise<TransactionInfo>;
    /**
     * Fetches all UTXOs associated with a specific transaction hash.
     * @param hash - Transaction hash to fetch UTXOs for
     * @returns Promise resolving to array of UTXOs associated with the transaction
     * @throws Error if no UTXOs found for the transaction hash
     */
    fetchUTxOs(hash: string): Promise<UTxO[]>;
    fetchGovernanceProposal(txHash: string, certIndex: number): Promise<any>;
    /**
     * HTTP GET method required by IFetcher interface but not implemented in OfflineFetcher.
     * @param url - URL to fetch from
     * @throws Error always, as this fetcher operates offline
     */
    get(url: string): Promise<any>;
    /**
     * Serializes fetcher data to JSON string.
     * @returns JSON string containing all fetcher data
     */
    toJSON(): string;
    /**
     * Creates an OfflineFetcher instance from JSON data.
     * @param json - JSON string containing fetcher data
     * @returns New OfflineFetcher instance
     */
    static fromJSON(json: string): OfflineFetcher;
    private static isValidHex;
    private static isValidAddress;
    private static isValidBase58;
    private static isValidBech32;
    private static isValidBech32Address;
    private static isValidBech32Pool;
    private static isValidBech32VrfVk;
    private static isIntegerString;
    private static isValidAssetOrLovelace;
    /**
     * Adds account information to the fetcher.
     * @param address - Account address
     * @param accountInfo - Account information
     * @throws Error if address or account info invalid
     */
    addAccount(address: string, accountInfo: AccountInfo): void;
    /**
     * Adds UTXOs to the fetcher.
     * @param utxos - Array of UTXOs
     * @throws Error if UTXOs invalid
     */
    addUTxOs(utxos: UTxO[]): void;
    /**
     * Adds asset address information to the fetcher.
     * @param asset - Asset identifier
     * @param addresses - Array of asset addresses
     * @throws Error if asset or addresses invalid
     */
    addAssetAddresses(asset: string, addresses: AssetAddress[]): void;
    /**
     * Adds asset metadata to the fetcher.
     * @param asset - Asset identifier
     * @param metadata - Asset metadata
     * @throws Error if asset or metadata invalid
     */
    addAssetMetadata(asset: string, metadata: AssetMetadata): void;
    /**
     * Adds collection assets to the fetcher.
     * @param assets - Array of assets
     * @throws Error if assets invalid
     */
    addCollectionAssets(assets: Asset[]): void;
    /**
     * Adds protocol parameters to the fetcher.
     * @param parameters - Protocol parameters
     * @throws Error if parameters invalid
     */
    addProtocolParameters(parameters: Protocol): void;
    /**
     * Adds transaction information to the fetcher.
     * @param txInfo - Transaction information
     * @throws Error if transaction info invalid
     */
    addTransaction(txInfo: TransactionInfo): void;
    /**
     * Adds block information to the fetcher.
     * @param blockInfo - Block information
     * @throws Error if block info invalid
     */
    addBlock(blockInfo: BlockInfo): void;
}

export { BeginProvider, BlockfrostProvider, type BlockfrostSupportedNetworks, HydraProvider, KoiosProvider, type KoiosSupportedNetworks, MaestroProvider, type MaestroSupportedNetworks, OfflineFetcher, OgmiosProvider, U5CProvider, YaciProvider };
