// src/begin.ts
import axios2 from "axios";

// src/utils/parse-http-error.ts
import axios from "axios";
var parseHttpError = (error) => {
  if (axios.isAxiosError(error)) {
    if (error.response) {
      return JSON.stringify({
        data: error.response.data,
        headers: error.response.headers,
        status: error.response.status
      });
    } else if (error.request && !(error.request instanceof XMLHttpRequest)) {
      return JSON.stringify(error.request);
    } else {
      return JSON.stringify({ code: error.code, message: error.message });
    }
  } else {
    return JSON.stringify(error);
  }
};

// src/begin.ts
var BeginProvider = class {
  apikey;
  chainNumber = 1815;
  domainUrl = ".bgin.id";
  /**
   * Creates a new instance of the BeginProvider.
   * @param apikey The API key for querying Begin ID.
   */
  constructor(apikey) {
    this.apikey = apikey ?? "31cab9edcc1c530e29924a56167d4ed17d50b7fds";
  }
  /**
   * Given a Begin ID, resolves the address and other information.
   * @param name name of Begin ID, e.g. `mesh`
   * @param url optional URL to override the default: https://resolveidaddress-ylo5dtxzdq-uc.a.run.app
   * @returns
   * - name: string
   * - domain: string
   * - image: string
   * - address: string
   */
  async resolveAddress(name, url) {
    try {
      const axiosInstance = axios2.create({
        baseURL: url ?? "https://resolveidaddress-ylo5dtxzdq-uc.a.run.app",
        headers: {
          "Content-Type": "application/json",
          Authorization: this.apikey
        }
      });
      const { data, status } = await axiosInstance.post(``, {
        name: name.replace("@", "").replace(/(\.bgin\.id|\.beginid\.io|\.bgn\.is)$/, ""),
        chain: this.chainNumber
      });
      if (status === 200) {
        const result = data.result;
        return {
          name: result.name,
          domain: `${"".concat(result.name, this.domainUrl)}`,
          image: result.image,
          address: result.addresses[this.chainNumber]
        };
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Given an address, resolves the Begin ID and other information.
   * @param address address to resolve
   * @param url optional URL to override the default: https://resolveIdReserveAddress-ylo5dtxzdq-uc.a.run.app
   * @returns
   * - name: string
   * - domain: string
   * - image: string
   * - address: string
   */
  async resolveAdressReverse(address, url) {
    try {
      const axiosInstance = axios2.create({
        baseURL: url ?? "https://resolveIdReserveAddress-ylo5dtxzdq-uc.a.run.app",
        headers: {
          "Content-Type": "application/json",
          Authorization: this.apikey
        }
      });
      const { data, status } = await axiosInstance.post(``, {
        address,
        chain: this.chainNumber
      });
      if (status === 200) {
        const result = data.result;
        return {
          name: result.name,
          domain: `${"".concat(result.name, this.domainUrl)}`,
          image: result.image,
          address: result.addresses[this.chainNumber]
        };
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
};

// src/blockfrost.ts
import axios3 from "axios";
import {
  castProtocol,
  fromUTF8 as fromUTF82,
  SUPPORTED_HANDLES,
  toBytes
} from "@meshsdk/common";
import {
  normalizePlutusScript,
  resolveRewardAddress,
  toScriptRef
} from "@meshsdk/core-cst";

// src/common/utxos-to-assets.ts
function utxosToAssets(utxos) {
  const _balance = utxos.map((utxo) => {
    return utxo.output.amount;
  }).reduce(
    (acc, amount) => {
      for (const asset of amount) {
        if (asset) {
          if (acc[asset.unit] == void 0) {
            acc[asset.unit] = 0;
          }
          if (asset.unit in acc) {
            acc[asset.unit] += parseFloat(asset.quantity);
          }
        }
      }
      return acc;
    },
    {}
  );
  return Object.fromEntries(
    Object.entries(_balance).map(([key, value]) => [key, value.toString()])
  );
}

// src/utils/parse-asset-unit.ts
import { fromUTF8, POLICY_ID_LENGTH } from "@meshsdk/common";
var parseAssetUnit = (unit) => {
  const policyId = unit.slice(0, POLICY_ID_LENGTH);
  const assetName = unit.includes(".") ? fromUTF8(unit.split(".")[1] || "") : unit.slice(POLICY_ID_LENGTH);
  return { policyId, assetName };
};

// src/blockfrost.ts
var BlockfrostProvider = class {
  _axiosInstance;
  _network;
  submitTxToBytes = true;
  constructor(...args) {
    if (typeof args[0] === "string" && (args[0].startsWith("http") || args[0].startsWith("/"))) {
      this._axiosInstance = axios3.create({ baseURL: args[0] });
      this._network = "mainnet";
    } else {
      const projectId = args[0];
      const network = projectId.slice(0, 7);
      this._axiosInstance = axios3.create({
        baseURL: `https://cardano-${network}.blockfrost.io/api/v${args[1] ?? 0}`,
        headers: { project_id: projectId }
      });
      this._network = network;
    }
  }
  setSubmitTxToBytes(value) {
    this.submitTxToBytes = value;
  }
  /**
   * Evaluates the resources required to execute the transaction
   * @param tx - The transaction to evaluate
   */
  async evaluateTx(cbor) {
    try {
      const headers = { "Content-Type": "application/cbor" };
      const { status, data } = await this._axiosInstance.post(
        "utils/txs/evaluate",
        cbor,
        {
          headers
        }
      );
      if (status === 200 && data.result.EvaluationResult) {
        const tagMap = {
          spend: "SPEND",
          mint: "MINT",
          certificate: "CERT",
          withdrawal: "REWARD"
        };
        const result = [];
        Object.keys(data.result.EvaluationResult).forEach((key) => {
          const [tagKey, index] = key.split(":");
          const { memory, steps } = data.result.EvaluationResult[key];
          result.push({
            tag: tagMap[tagKey],
            index: Number(index),
            budget: { mem: memory, steps }
          });
        });
        return result;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Obtain information about a specific stake account.
   * @param address - Wallet address to fetch account information
   */
  async fetchAccountInfo(address) {
    const rewardAddress = address.startsWith("addr") ? resolveRewardAddress(address) : address;
    try {
      const { data, status } = await this._axiosInstance.get(
        `accounts/${rewardAddress}`
      );
      if (status === 200 || status == 202)
        return {
          poolId: data.pool_id,
          active: data.active || data.active_epoch !== null,
          balance: data.controlled_amount,
          rewards: data.withdrawable_amount,
          withdrawals: data.withdrawals_sum
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetches the assets for a given address.
   * @param address - The address to fetch assets for
   * @returns A map of asset unit to quantity
   */
  async fetchAddressAssets(address) {
    const utxos = await this.fetchAddressUTxOs(address);
    return utxosToAssets(utxos);
  }
  /**
   * Transactions for an address.
   * @param address
   * @returns - partial TransactionInfo
   */
  async fetchAddressTransactions(address) {
    try {
      const { data, status } = await this._axiosInstance.get(
        `/addresses/${address}/transactions`
      );
      if (status === 200 || status == 202) {
        return data.map((tx) => {
          return {
            hash: tx.tx_hash,
            index: tx.tx_index,
            block: "",
            slot: "",
            fees: "",
            size: 0,
            deposit: "",
            invalidBefore: "",
            invalidAfter: ""
          };
        });
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * UTXOs of the address.
   * @param address - The address to fetch UTXO
   * @param asset - UTXOs of a given assetâ€‹
   * @returns - Array of UTxOs
   */
  async fetchAddressUTxOs(address, asset) {
    const filter = asset !== void 0 ? `/${asset}` : "";
    const url = `addresses/${address}/utxos` + filter;
    const paginateUTxOs = async (page = 1, utxos = []) => {
      const { data, status } = await this._axiosInstance.get(
        `${url}?page=${page}`
      );
      if (status === 200 || status == 202)
        return data.length > 0 ? paginateUTxOs(page + 1, [
          ...utxos,
          ...await Promise.all(
            data.map(
              (utxo) => this.toUTxO(utxo, utxo.tx_hash)
            )
          )
        ]) : utxos;
      throw parseHttpError(data);
    };
    try {
      return await paginateUTxOs();
    } catch (error) {
      return [];
    }
  }
  /**
   * Fetches the asset addresses for a given asset.
   * @param asset - The asset to fetch addresses for
   */
  async fetchAssetAddresses(asset) {
    const paginateAddresses = async (page = 1, addresses = []) => {
      const { policyId, assetName } = parseAssetUnit(asset);
      const { data, status } = await this._axiosInstance.get(
        `assets/${policyId}${assetName}/addresses?page=${page}`
      );
      if (status === 200 || status == 202)
        return data.length > 0 ? paginateAddresses(page + 1, [...addresses, ...data]) : addresses;
      throw parseHttpError(data);
    };
    try {
      return await paginateAddresses();
    } catch (error) {
      return [];
    }
  }
  /**
   * Fetches the metadata for a given asset.
   * @param asset - The asset to fetch metadata for
   * @returns The metadata for the asset
   */
  async fetchAssetMetadata(asset) {
    try {
      const { policyId, assetName } = parseAssetUnit(asset);
      const { data, status } = await this._axiosInstance.get(
        `assets/${policyId}${assetName}`
      );
      if (status === 200 || status == 202)
        return {
          ...data.onchain_metadata,
          fingerprint: data.fingerprint,
          totalSupply: data.quantity,
          mintingTxHash: data.initial_mint_tx_hash,
          // todo: request for `initial_mint_tx_hash`
          mintCount: data.mint_or_burn_count
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetches the metadata for a given asset.
   * @param asset - The asset to fetch metadata for
   * @returns The metadata for the asset
   */
  async fetchLatestBlock() {
    try {
      const { data, status } = await this._axiosInstance.get(`blocks/latest`);
      if (status === 200 || status == 202)
        return {
          confirmations: data.confirmations,
          epoch: data.epoch,
          epochSlot: data.epoch_slot.toString(),
          fees: data.fees,
          hash: data.hash,
          nextBlock: data.next_block ?? "",
          operationalCertificate: data.op_cert,
          output: data.output ?? "0",
          previousBlock: data.previous_block,
          size: data.size,
          slot: data.slot.toString(),
          slotLeader: data.slot_leader ?? "",
          time: data.time,
          txCount: data.tx_count,
          VRFKey: data.block_vrf
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchBlockInfo(hash) {
    try {
      const { data, status } = await this._axiosInstance.get(`blocks/${hash}`);
      if (status === 200 || status == 202)
        return {
          confirmations: data.confirmations,
          epoch: data.epoch,
          epochSlot: data.epoch_slot.toString(),
          fees: data.fees,
          hash: data.hash,
          nextBlock: data.next_block ?? "",
          operationalCertificate: data.op_cert,
          output: data.output ?? "0",
          previousBlock: data.previous_block,
          size: data.size,
          slot: data.slot.toString(),
          slotLeader: data.slot_leader ?? "",
          time: data.time,
          txCount: data.tx_count,
          VRFKey: data.block_vrf
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchCollectionAssets(policyId, cursor = 1) {
    try {
      const { data, status } = await this._axiosInstance.get(
        `assets/policy/${policyId}?page=${cursor}`
      );
      if (status === 200 || status == 202)
        return {
          assets: data.map((asset) => ({
            unit: asset.asset,
            quantity: asset.quantity
          })),
          next: data.length === 100 ? cursor + 1 : null
        };
      throw parseHttpError(data);
    } catch (error) {
      return { assets: [], next: null };
    }
  }
  async fetchHandle(handle) {
    if (this._network !== "mainnet") {
      throw new Error(
        "Does not support fetching addresses by handle on non-mainnet networks."
      );
    }
    try {
      const assetName = fromUTF82(`${handle.replace("$", "")}`);
      const asset = await this.fetchAssetMetadata(
        `${SUPPORTED_HANDLES[1]}000de140${assetName}`
      );
      return asset;
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchHandleAddress(handle) {
    if (this._network !== "mainnet") {
      throw new Error(
        "Does not support fetching addresses by handle on non-mainnet networks."
      );
    }
    try {
      const assetName = fromUTF82(handle.replace("$", ""));
      const { data, status } = await this._axiosInstance.get(
        `assets/${SUPPORTED_HANDLES[1]}${assetName}/addresses`
      );
      if (status === 200 || status == 202) return data[0].address;
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchProtocolParameters(epoch = Number.NaN) {
    try {
      const { data, status } = await this._axiosInstance.get(
        `epochs/${isNaN(epoch) ? "latest" : epoch}/parameters`
      );
      if (status === 200 || status == 202)
        return castProtocol({
          coinsPerUtxoSize: data.coins_per_utxo_word,
          collateralPercent: data.collateral_percent,
          decentralisation: data.decentralisation_param,
          epoch: data.epoch,
          keyDeposit: data.key_deposit,
          maxBlockExMem: data.max_block_ex_mem,
          maxBlockExSteps: data.max_block_ex_steps,
          maxBlockHeaderSize: data.max_block_header_size,
          maxBlockSize: data.max_block_size,
          maxCollateralInputs: data.max_collateral_inputs,
          maxTxExMem: data.max_tx_ex_mem,
          maxTxExSteps: data.max_tx_ex_steps,
          maxTxSize: data.max_tx_size,
          maxValSize: data.max_val_size,
          minFeeA: data.min_fee_a,
          minFeeB: data.min_fee_b,
          minPoolCost: data.min_pool_cost,
          poolDeposit: data.pool_deposit,
          priceMem: data.price_mem,
          priceStep: data.price_step
        });
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchTxInfo(hash) {
    try {
      const { data, status } = await this._axiosInstance.get(`txs/${hash}`);
      if (status === 200 || status == 202)
        return {
          block: data.block,
          deposit: data.deposit,
          fees: data.fees,
          hash: data.hash,
          index: data.index,
          invalidAfter: data.invalid_hereafter ?? "",
          invalidBefore: data.invalid_before ?? "",
          slot: data.slot.toString(),
          size: data.size
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchUTxOs(hash, index) {
    try {
      const { data, status } = await this._axiosInstance.get(
        `txs/${hash}/utxos`
      );
      if (status === 200 || status == 202) {
        const bfOutputs = data.outputs;
        const outputsPromises = [];
        bfOutputs.forEach((output) => {
          outputsPromises.push(this.toUTxO(output, hash));
        });
        const outputs = await Promise.all(outputsPromises);
        if (index !== void 0) {
          return outputs.filter((utxo) => utxo.input.outputIndex === index);
        }
        return outputs;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchGovernanceProposal(txHash, certIndex) {
    try {
      const { data, status } = await this._axiosInstance.get(
        `governance/proposals/${txHash}/${certIndex}`
      );
      if (status === 200 || status == 202)
        return {
          txHash: data.tx_hash,
          certIndex: data.cert_index,
          governanceType: data.governance_type,
          deposit: data.deposit,
          returnAddress: data.return_address,
          governanceDescription: data.governance_description,
          ratifiedEpoch: data.ratified_epoch,
          enactedEpoch: data.enacted_epoch,
          droppedEpoch: data.dropped_epoch,
          expiredEpoch: data.expired_epoch,
          expiration: data.expiration,
          metadata: (await this._axiosInstance.get(
            `governance/proposals/${txHash}/${certIndex}/metadata`
          )).data
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * A generic method to fetch data from a URL.
   * @param url - The URL to fetch data from
   * @returns - The data fetched from the URL
   */
  async get(url) {
    try {
      const { data, status } = await this._axiosInstance.get(url);
      if (status === 200 || status == 202) {
        return data;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * A generic method to post data to a URL.
   * @param url - The URL to fetch data from
   * @param body - Payload
   * @param headers - Specify headers, default: { "Content-Type": "application/json" }
   * @returns - Data
   */
  async post(url, body, headers = { "Content-Type": "application/json" }) {
    try {
      const { data, status } = await this._axiosInstance.post(url, body, {
        headers
      });
      if (status === 200 || status == 202) return data;
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.
   * @param txHash - The transaction hash to listen for confirmation
   * @param callback - The callback function to call when the transaction is confirmed
   * @param limit - The number of blocks to wait for confirmation
   */
  onTxConfirmed(txHash, callback, limit = 100) {
    let attempts = 0;
    const checkTx = setInterval(() => {
      if (attempts >= limit) clearInterval(checkTx);
      this.fetchTxInfo(txHash).then((txInfo) => {
        this.fetchBlockInfo(txInfo.block).then((blockInfo) => {
          if (blockInfo?.confirmations > 0) {
            clearInterval(checkTx);
            callback();
          }
        }).catch(() => {
          attempts += 1;
        });
      }).catch(() => {
        attempts += 1;
      });
    }, 5e3);
  }
  /**
   * Submit a serialized transaction to the network.
   * @param tx - The serialized transaction in hex to submit
   * @returns The transaction hash of the submitted transaction
   */
  async submitTx(tx) {
    try {
      const headers = { "Content-Type": "application/cbor" };
      const { data, status } = await this._axiosInstance.post(
        "tx/submit",
        this.submitTxToBytes ? toBytes(tx) : tx,
        { headers }
      );
      if (status === 200 || status == 202) return data;
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  resolveScriptRef = async (scriptHash) => {
    if (scriptHash) {
      const { data, status } = await this._axiosInstance.get(
        `scripts/${scriptHash}`
      );
      if (status === 200 || status == 202) {
        let script;
        if (data.type.startsWith("plutus")) {
          const plutusScript = await this.fetchPlutusScriptCBOR(scriptHash);
          const normalized = normalizePlutusScript(plutusScript, "DoubleCBOR");
          script = {
            version: data.type.replace("plutus", ""),
            code: normalized
          };
        } else {
          script = await this.fetchNativeScriptJSON(scriptHash);
        }
        return toScriptRef(script).toCbor().toString();
      }
      throw parseHttpError(data);
    }
    return void 0;
  };
  toUTxO = async (bfUTxO, tx_hash) => ({
    input: {
      outputIndex: bfUTxO.output_index,
      txHash: tx_hash
    },
    output: {
      address: bfUTxO.address,
      amount: bfUTxO.amount,
      dataHash: bfUTxO.data_hash ?? void 0,
      plutusData: bfUTxO.inline_datum ?? void 0,
      scriptRef: bfUTxO.reference_script_hash ? await this.resolveScriptRef(bfUTxO.reference_script_hash) : void 0,
      scriptHash: bfUTxO.reference_script_hash
    }
  });
  async fetchPlutusScriptCBOR(scriptHash) {
    const { data, status } = await this._axiosInstance.get(
      `scripts/${scriptHash}/cbor`
    );
    if (status === 200 || status == 202) return data.cbor;
    throw parseHttpError(data);
  }
  async fetchNativeScriptJSON(scriptHash) {
    const { data, status } = await this._axiosInstance.get(
      `scripts/${scriptHash}/json`
    );
    if (status === 200 || status == 202) return data.json;
    throw parseHttpError(data);
  }
};

// src/hydra/index.ts
import { EventEmitter as EventEmitter2 } from "events";
import axios4 from "axios";
import {
  castProtocol as castProtocol2
} from "@meshsdk/common";

// src/hydra/convertor.ts
function toUTxO(hUTxO, txId) {
  const [txHash, txIndex] = txId.split("#");
  return {
    input: {
      outputIndex: Number(txIndex),
      txHash
    },
    output: {
      address: hUTxO.address,
      amount: toAssets(hUTxO.value),
      dataHash: hUTxO.datumhash ?? void 0,
      plutusData: hUTxO.inlineDatum?.toString() ?? void 0,
      // TODO: cast to correct cbor
      scriptHash: hUTxO.referenceScript?.toString() ?? void 0
      // TODO: cast to correct cbor
    }
  };
}
function toAssets(hAssets) {
  const assets = [];
  for (const policy of Object.keys(hAssets)) {
    if (policy === "lovelace") {
      assets.push({
        unit: policy,
        quantity: hAssets[policy].toString()
      });
    } else {
      for (const assetName of Object.keys(hAssets[policy])) {
        assets.push({
          unit: policy + assetName,
          quantity: hAssets[policy][assetName].toString()
        });
      }
    }
  }
  return assets;
}

// src/hydra/hydra-connection.ts
import { EventEmitter } from "events";

// src/hydra/types/index.ts
var HYDRA_STATUS = {
  IDLE: "IDLE",
  DISCONNECTED: "DISCONNECTED",
  CONNECTING: "CONNECTING",
  CONNECTED: "CONNECTED",
  INITIALIZING: "INITIALIZING",
  OPEN: "OPEN",
  CLOSED: "CLOSED",
  FANOUT_POSSIBLE: "FANOUT_POSSIBLE",
  FINAL: "FINAL"
};

// src/hydra/hydra-connection.ts
var HydraConnection = class extends EventEmitter {
  _websocket;
  _status = HYDRA_STATUS.IDLE;
  _websocketUrl;
  _eventEmitter;
  _connected = false;
  constructor({
    url,
    eventEmitter,
    history = false
  }) {
    super();
    const wsUrl = url.replace("http", "ws");
    this._websocketUrl = `${wsUrl}/?history=${history ? "yes" : "no"}`;
    this._eventEmitter = eventEmitter;
  }
  async connect() {
    if (this._status !== HYDRA_STATUS.IDLE) {
      return;
    }
    this._websocket = new WebSocket(this._websocketUrl);
    this._status = HYDRA_STATUS.CONNECTING;
    this._websocket.onopen = () => {
      console.log("Connected to Hydra");
      this._connected = true;
    };
    this._websocket.onerror = (error) => {
      console.error(`Hydra error: ${error}`);
    };
    this._websocket.onclose = (code) => {
      console.error("Hydra websocket closed", code);
    };
    this._websocket.onmessage = (data) => {
      const message = JSON.parse(data.data);
      this._eventEmitter.emit("onmessage", message);
      this.processStatus(message);
    };
  }
  async disconnect() {
    if (this._status === HYDRA_STATUS.IDLE) {
      return;
    }
    if (this._websocket && this._websocket.readyState === WebSocket.OPEN) {
      this._websocket.close(1007);
    }
    this._status = HYDRA_STATUS.IDLE;
  }
  send(data) {
    if (this._connected) {
      this._websocket?.send(JSON.stringify(data));
    }
  }
  async processStatus(message) {
    function getStatus(data) {
      switch (data.headStatus) {
        case "Open":
          return HYDRA_STATUS.OPEN;
      }
      switch (data.tag) {
        case "HeadIsInitializing":
          return HYDRA_STATUS.INITIALIZING;
        case "HeadIsOpen":
          return HYDRA_STATUS.OPEN;
        case "HeadIsClosed":
          return HYDRA_STATUS.CLOSED;
        case "ReadyToFanout":
          return HYDRA_STATUS.FANOUT_POSSIBLE;
        case "HeadIsFinalized":
          return HYDRA_STATUS.FINAL;
        default:
          return null;
      }
    }
    let status = null;
    if ((status = getStatus(message)) && status !== null) {
      this._status = status;
      this._eventEmitter.emit("onstatuschange", status);
    }
  }
};

// src/hydra/index.ts
var HydraProvider = class {
  _connection;
  _status = "DISCONNECTED";
  _eventEmitter;
  _axiosInstance;
  constructor({ url, history = false }) {
    this._eventEmitter = new EventEmitter2();
    this._connection = new HydraConnection({
      url,
      eventEmitter: this._eventEmitter,
      history
    });
    this._axiosInstance = axios4.create({ baseURL: url });
  }
  async connect() {
    if (this._status !== "DISCONNECTED") {
      return;
    }
    this._status = "CONNECTING";
    this._connection.connect();
  }
  fetchAccountInfo(address) {
    throw new Error("Method not implemented.");
  }
  async fetchAddressUTxOs(address) {
    const utxos = await this.fetchUTxOs();
    return utxos.filter((utxo) => utxo.output.address === address);
  }
  fetchAssetAddresses(asset) {
    throw new Error("Method not implemented.");
  }
  fetchAssetMetadata(asset) {
    throw new Error("Method not implemented.");
  }
  fetchBlockInfo(hash) {
    throw new Error("Method not implemented.");
  }
  fetchCollectionAssets(policyId, cursor) {
    throw new Error("Method not implemented.");
  }
  async fetchGovernanceProposal(txHash, certIndex) {
    throw new Error("Method not implemented");
  }
  async fetchProtocolParameters(epoch = Number.NaN) {
    try {
      const { data, status } = await this._axiosInstance.get(
        "protocol-parameters"
      );
      if (status === 200) {
        const protocolParams = castProtocol2({
          coinsPerUtxoSize: data.utxoCostPerByte,
          collateralPercent: data.collateralPercentage,
          maxBlockExMem: data.maxBlockExecutionUnits.memory,
          maxBlockExSteps: data.maxBlockExecutionUnits.steps,
          maxBlockHeaderSize: data.maxBlockHeaderSize,
          maxBlockSize: data.maxBlockBodySize,
          maxCollateralInputs: data.maxCollateralInputs,
          maxTxExMem: data.maxTxExecutionUnits.memory,
          maxTxExSteps: data.maxTxExecutionUnits.steps,
          maxTxSize: data.maxTxSize,
          maxValSize: data.maxValueSize,
          minFeeA: data.txFeePerByte,
          minFeeB: data.txFeeFixed,
          minPoolCost: data.minPoolCost,
          poolDeposit: data.stakePoolDeposit,
          priceMem: data.executionUnitPrices.priceMemory,
          priceStep: data.executionUnitPrices.priceSteps
        });
        return protocolParams;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  fetchTxInfo(hash) {
    throw new Error("Method not implemented.");
  }
  async fetchUTxOs() {
    const { data, status } = await this._axiosInstance.get(`snapshot/utxo`);
    if (status === 200) {
      const utxos = [];
      for (const [key, value] of Object.entries(data)) {
        const utxo = toUTxO(value, key);
        utxos.push(utxo);
      }
      return utxos;
    }
    throw parseHttpError(data);
  }
  /**
   * A generic method to fetch data from a URL.
   * @param url - The URL to fetch data from
   * @returns - The data fetched from the URL
   */
  async get(url) {
    try {
      const { data, status } = await this._axiosInstance.get(url);
      if (status === 200 || status == 202) {
        return data;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Submit a transaction to the Hydra node. Note, unlike other providers, Hydra does not return a transaction hash.
   * @param tx - The transaction in CBOR hex format
   */
  async submitTx(tx) {
    try {
      const payload = {
        tag: "NewTx",
        transaction: {
          type: "Witnessed Tx ConwayEra",
          description: "Ledger Cddl Format",
          cborHex: tx
        }
      };
      this.send(payload);
      const txId = await new Promise((resolve) => {
        this.onMessage((message) => {
          if (message.transaction && message.transaction.cborHex === tx) {
            if (message.tag === "TxValid") {
              console.log("txid", message.transaction.txId);
              resolve(message.transaction.txId);
            } else if (message.tag == "TxInvalid") {
              throw JSON.stringify(message.validationError);
            }
          }
        });
      });
      return txId;
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Initializes a new Head. This command is a no-op when a Head is already open and the server will output an CommandFailed message should this happen.
   */
  async initializesHead() {
    this.send({ tag: "Init" });
  }
  send(data) {
    this._connection.send(data);
  }
  onMessage(callback) {
    this._eventEmitter.on("onmessage", callback);
  }
  onStatusChange(callback) {
    this._eventEmitter.on("onstatuschange", callback);
  }
};

// src/koios.ts
import axios5 from "axios";
import {
  castProtocol as castProtocol3,
  fromUTF8 as fromUTF83,
  SUPPORTED_HANDLES as SUPPORTED_HANDLES2,
  toBytes as toBytes2,
  toUTF8
} from "@meshsdk/common";
import {
  deserializeNativeScript,
  fromNativeScript,
  normalizePlutusScript as normalizePlutusScript2,
  resolveRewardAddress as resolveRewardAddress2,
  toScriptRef as toScriptRef2
} from "@meshsdk/core-cst";
var KoiosProvider = class {
  _axiosInstance;
  _network;
  constructor(...args) {
    if (typeof args[0] === "string" && args[0].startsWith("http")) {
      this._axiosInstance = axios5.create({
        baseURL: args[0],
        headers: {
          Authorization: `Bearer ${args[1]}`
        }
      });
      this._network = "api";
    } else {
      let version = 1;
      if (typeof args[2] === "number") {
        version = args[2];
      }
      const config = {
        baseURL: `https://${args[0]}.koios.rest/api/v${version}`
      };
      this._network = args[0];
      if (typeof args[1] === "string") {
        config.headers = {
          Authorization: `Bearer ${args[1]}`
        };
      }
      this._axiosInstance = axios5.create(config);
    }
  }
  async fetchAccountInfo(address) {
    try {
      const rewardAddress = address.startsWith("addr") ? resolveRewardAddress2(address) : address;
      const { data, status } = await this._axiosInstance.post("account_info", {
        _stake_addresses: [rewardAddress]
      });
      if (status === 200)
        return {
          poolId: data[0].delegated_pool,
          active: data[0].status === "registered",
          balance: data[0].total_balance.toString(),
          rewards: data[0].rewards_available,
          withdrawals: data[0].withdrawals
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchAddressAssets(address) {
    const utxos = await this.fetchAddressUTxOs(address);
    return utxosToAssets(utxos);
  }
  /**
   * Transactions for an address.
   * @param address
   * @returns - partial TransactionInfo
   */
  async fetchAddressTransactions(address) {
    try {
      const { data, status } = await this._axiosInstance.post(`/address_txs`, {
        _addresses: [address]
      });
      if (status === 200 || status == 202) {
        return data.map((tx) => {
          return {
            hash: tx.tx_hash,
            index: 0,
            block: "",
            slot: "",
            fees: "",
            size: 0,
            deposit: "",
            invalidBefore: "",
            invalidAfter: ""
          };
        });
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchAddressUTxOs(address, asset) {
    try {
      const { data, status } = await this._axiosInstance.post("address_info", {
        _addresses: [address]
      });
      if (status === 200) {
        const utxos = data.flatMap((info) => info.utxo_set).map((utxo) => this.toUTxO(utxo, address));
        return asset !== void 0 ? utxos.filter(
          (utxo) => utxo.output.amount.find((a) => a.unit === asset) !== void 0
        ) : utxos;
      }
      throw parseHttpError(data);
    } catch (error) {
      return [];
    }
  }
  async fetchAssetAddresses(asset) {
    try {
      const { policyId, assetName } = parseAssetUnit(asset);
      const { data, status } = await this._axiosInstance.get(
        `asset_addresses?_asset_policy=${policyId}&_asset_name=${assetName}`
      );
      if (status === 200)
        return data.map(
          (item) => ({
            address: item.payment_address,
            quantity: item.quantity
          })
        );
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchAssetMetadata(asset) {
    try {
      const { policyId, assetName } = parseAssetUnit(asset);
      const { data, status } = await this._axiosInstance.get(
        `asset_info?_asset_policy=${policyId}&_asset_name=${assetName}`
      );
      if (status === 200)
        return {
          ...data[0].minting_tx_metadata[721][policyId][toUTF8(assetName)],
          fingerprint: data[0].fingerprint,
          totalSupply: data[0].total_supply,
          mintingTxHash: data[0].minting_tx_hash,
          mintCount: data[0].mint_cnt
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchBlockInfo(hash) {
    try {
      const { data, status } = await this._axiosInstance.post("block_info", {
        _block_hashes: [hash]
      });
      if (status === 200)
        return {
          confirmations: data[0].num_confirmations,
          epoch: data[0].epoch_no,
          epochSlot: data[0].epoch_slot.toString(),
          fees: data[0].total_fees ?? "",
          hash: data[0].hash,
          nextBlock: data[0].child_hash ?? "",
          operationalCertificate: data[0].op_cert,
          output: data[0].total_output ?? "0",
          previousBlock: data[0].parent_hash,
          size: data[0].block_size,
          slot: data[0].abs_slot.toString(),
          slotLeader: data[0].pool ?? "",
          time: data[0].block_time,
          txCount: data[0].tx_count,
          VRFKey: data[0].vrf_key
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchCollectionAssets(policyId) {
    try {
      const { data, status } = await this._axiosInstance.get(
        `policy_asset_info?_asset_policy=${policyId}`
      );
      if (status === 200)
        return {
          assets: data.map((asset) => ({
            unit: `${asset.policy_id}${asset.asset_name}`,
            quantity: asset.total_supply
          }))
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchHandle(handle) {
    if (this._network !== "api") {
      throw new Error(
        "Does not support fetching addresses by handle on non-mainnet networks."
      );
    }
    try {
      const assetName = fromUTF83(`${handle.replace("$", "")}`);
      const asset = await this.fetchAssetMetadata(
        `${SUPPORTED_HANDLES2[1]}000de140${assetName}`
      );
      return asset;
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchHandleAddress(handle) {
    if (this._network !== "api") {
      throw new Error(
        "Does not support fetching addresses by handle on non-mainnet networks."
      );
    }
    try {
      const assetName = fromUTF83(handle.replace("$", ""));
      const { data, status } = await this._axiosInstance.get(
        `asset_addresses?_asset_policy=${SUPPORTED_HANDLES2[1]}&_asset_name=${assetName}`
      );
      if (status === 200) return data[0].payment_address;
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchProtocolParameters(epoch = Number.NaN) {
    try {
      if (isNaN(epoch)) {
        const { data: data2 } = await this._axiosInstance.get(`tip`);
        epoch = data2[0].epoch_no;
      }
      const { data, status } = await this._axiosInstance.get(
        `epoch_params?_epoch_no=${epoch}`
      );
      if (status === 200)
        return castProtocol3({
          coinsPerUtxoSize: data[0].coins_per_utxo_size,
          collateralPercent: data[0].collateral_percent,
          decentralisation: data[0].decentralisation,
          epoch: data[0].epoch_no,
          keyDeposit: data[0].key_deposit,
          maxBlockExMem: data[0].max_block_ex_mem.toString(),
          maxBlockExSteps: data[0].max_block_ex_steps.toString(),
          maxBlockHeaderSize: data[0].max_bh_size,
          maxBlockSize: data[0].max_block_size,
          maxCollateralInputs: data[0].max_collateral_inputs,
          maxTxExMem: data[0].max_tx_ex_mem.toString(),
          maxTxExSteps: data[0].max_tx_ex_steps.toString(),
          maxTxSize: data[0].max_tx_size,
          maxValSize: data[0].max_val_size,
          minFeeA: data[0].min_fee_a,
          minFeeB: data[0].min_fee_b,
          minPoolCost: data[0].min_pool_cost,
          poolDeposit: data[0].pool_deposit,
          priceMem: data[0].price_mem,
          priceStep: data[0].price_step
        });
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchTxInfo(hash) {
    try {
      const { data, status } = await this._axiosInstance.post("tx_info", {
        _tx_hashes: [hash]
      });
      if (status === 200 && data.length == 1)
        return {
          block: data[0].block_hash,
          deposit: data[0].deposit,
          fees: data[0].fee,
          hash: data[0].tx_hash,
          index: data[0].tx_block_index,
          invalidAfter: data[0].invalid_after?.toString() ?? "",
          invalidBefore: data[0].invalid_before?.toString() ?? "",
          slot: data[0].absolute_slot.toString(),
          size: data[0].tx_size
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchUTxOs(hash, index) {
    try {
      const { data, status } = await this._axiosInstance.post("tx_info", {
        _tx_hashes: [hash]
      });
      if (status === 200) {
        const utxos = data[0].outputs.map(
          (utxo) => this.toUTxO(utxo, "undefined")
        );
        if (index !== void 0) {
          return utxos.filter((utxo) => utxo.input.outputIndex === index);
        }
        return utxos;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchGovernanceProposal(txHash, certIndex) {
    throw new Error("Method not implemented");
  }
  /**
   * A generic method to fetch data from a URL.
   * @param url - The URL to fetch data from
   * @returns - The data fetched from the URL
   */
  async get(url) {
    try {
      const { data, status } = await this._axiosInstance.get(url);
      if (status === 200 || status == 202) {
        return data;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * A generic method to post data to a URL.
   * @param url - The URL to fetch data from
   * @param body - Payload
   * @param headers - Specify headers, default: { "Content-Type": "application/json" }
   * @returns - Data
   */
  async post(url, body, headers = { "Content-Type": "application/json" }) {
    try {
      const { data, status } = await this._axiosInstance.post(url, body, {
        headers
      });
      if (status === 200 || status == 202) return data;
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  onTxConfirmed(txHash, callback, limit = 100) {
    let attempts = 0;
    const checkTx = setInterval(() => {
      if (attempts >= limit) clearInterval(checkTx);
      this.fetchTxInfo(txHash).then((txInfo) => {
        this.fetchBlockInfo(txInfo.block).then((blockInfo) => {
          if (blockInfo?.confirmations > 0) {
            clearInterval(checkTx);
            callback();
          }
        }).catch(() => {
          attempts += 1;
        });
      }).catch(() => {
        attempts += 1;
      });
    }, 5e3);
  }
  async submitTx(tx) {
    try {
      const headers = { "Content-Type": "application/cbor" };
      const { data, status } = await this._axiosInstance.post(
        "submittx",
        toBytes2(tx),
        { headers }
      );
      if (status === 202) return data;
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  toUTxO(utxo, address) {
    return {
      input: {
        outputIndex: utxo.tx_index,
        txHash: utxo.tx_hash
      },
      output: {
        address,
        amount: [
          { unit: "lovelace", quantity: utxo.value },
          ...utxo.asset_list.map(
            (a) => ({
              unit: `${a.policy_id}${a.asset_name}`,
              quantity: `${a.quantity}`
            })
          )
        ],
        dataHash: utxo.datum_hash ?? void 0,
        plutusData: utxo.inline_datum?.bytes ?? void 0,
        scriptRef: this.resolveScriptRef(utxo.reference_script),
        scriptHash: utxo.reference_script?.hash ?? void 0
      }
    };
  }
  resolveScriptRef = (kScriptRef) => {
    if (kScriptRef) {
      let script;
      if (kScriptRef.type.startsWith("plutus")) {
        const normalized = normalizePlutusScript2(kScriptRef.bytes, "DoubleCBOR");
        script = {
          code: normalized,
          version: kScriptRef.type.replace("plutus", "")
        };
      } else {
        script = fromNativeScript(deserializeNativeScript(kScriptRef.bytes));
      }
      if (script) return toScriptRef2(script).toCbor().toString();
    }
    return void 0;
  };
};

// src/maestro.ts
import axios6 from "axios";
import {
  castProtocol as castProtocol4,
  fromUTF8 as fromUTF84,
  SUPPORTED_HANDLES as SUPPORTED_HANDLES3,
  toBytes as toBytes3
} from "@meshsdk/common";
import {
  normalizePlutusScript as normalizePlutusScript3,
  resolveRewardAddress as resolveRewardAddress3,
  toScriptRef as toScriptRef3,
  VrfVkBech32
} from "@meshsdk/core-cst";
var MaestroProvider = class {
  _axiosInstance;
  _amountsAsStrings = {
    headers: {
      "amounts-as-strings": "true"
    }
  };
  _network;
  submitUrl;
  constructor({ network, apiKey, turboSubmit = false }) {
    this._axiosInstance = axios6.create({
      baseURL: `https://${network}.gomaestro-api.org/v1`,
      headers: { "api-key": apiKey }
    });
    this.submitUrl = turboSubmit ? "txmanager/turbosubmit" : "txmanager";
    this._network = network;
  }
  async evaluateTx(cbor) {
    try {
      const { data, status } = await this._axiosInstance.post(
        "transactions/evaluate",
        { cbor }
      );
      if (status === 200) {
        const tagMap = {
          spend: "SPEND",
          mint: "MINT",
          cert: "CERT",
          wdrl: "REWARD"
        };
        const result = data.map((action) => {
          const budget = action.ex_units;
          const index = action.redeemer_index;
          const tag = tagMap[action.redeemer_tag];
          return { budget, index, tag };
        });
        return result;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchAccountInfo(address) {
    const rewardAddress = address.startsWith("addr") ? resolveRewardAddress3(address) : address;
    try {
      const { data: timestampedData, status } = await this._axiosInstance.get(
        `accounts/${rewardAddress}`,
        this._amountsAsStrings
      );
      if (status === 200) {
        const data = timestampedData.data;
        return {
          poolId: data.delegated_pool,
          active: data.registered,
          balance: data.total_balance,
          rewards: data.rewards_available,
          withdrawals: data.total_withdrawn
        };
      }
      throw parseHttpError(timestampedData);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchAddressAssets(address) {
    const utxos = await this.fetchAddressUTxOs(address);
    return utxosToAssets(utxos);
  }
  async fetchAddressUTxOs(address, asset) {
    const queryPredicate = (() => {
      if (address.startsWith("addr_vkh") || address.startsWith("addr_shared_vkh"))
        return `addresses/cred/${address}`;
      else return `addresses/${address}`;
    })();
    const appendAssetString = asset ? `&asset=${asset}` : "";
    const paginateUTxOs = async (cursor = null, utxos = []) => {
      const appendCursorString = cursor === null ? "" : `&cursor=${cursor}`;
      const { data: timestampedData, status } = await this._axiosInstance.get(
        `${queryPredicate}/utxos?count=100${appendAssetString}${appendCursorString}`,
        this._amountsAsStrings
      );
      if (status === 200) {
        const data = timestampedData.data;
        const pageUTxOs = data.map(this.toUTxO);
        const addedUtxos = [...utxos, ...pageUTxOs];
        const nextCursor = timestampedData.next_cursor;
        return nextCursor == null ? addedUtxos : paginateUTxOs(nextCursor, addedUtxos);
      }
      throw parseHttpError(timestampedData);
    };
    try {
      return await paginateUTxOs();
    } catch (error) {
      return [];
    }
  }
  async fetchAssetAddresses(asset) {
    const { policyId, assetName } = parseAssetUnit(asset);
    const paginateAddresses = async (cursor = null, addressesWithQuantity = []) => {
      const appendCursorString = cursor === null ? "" : `&cursor=${cursor}`;
      const { data: timestampedData, status } = await this._axiosInstance.get(
        `assets/${policyId}${assetName}/addresses?count=100${appendCursorString}`,
        this._amountsAsStrings
      );
      if (status === 200) {
        const data = timestampedData.data;
        const pageAddressesWithQuantity = data.map((a) => {
          return { address: a.address, quantity: a.amount };
        });
        const nextCursor = timestampedData.next_cursor;
        const addedData = [
          ...addressesWithQuantity,
          ...pageAddressesWithQuantity
        ];
        return nextCursor == null ? addedData : paginateAddresses(nextCursor, addedData);
      }
      throw parseHttpError(timestampedData);
    };
    try {
      return await paginateAddresses();
    } catch (error) {
      return [];
    }
  }
  async fetchAssetMetadata(asset) {
    try {
      const { policyId, assetName } = parseAssetUnit(asset);
      const { data: timestampedData, status } = await this._axiosInstance.get(
        `assets/${policyId}${assetName}`
      );
      if (status === 200) {
        const data = timestampedData.data;
        return {
          ...data.asset_standards.cip25_metadata,
          ...data.asset_standards.cip68_metadata,
          fingerprint: data.fingerprint,
          totalSupply: data.total_supply,
          mintingTxHash: data.latest_mint_tx.tx_hash,
          mintCount: data.mint_tx_count
        };
      }
      throw parseHttpError(timestampedData);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchBlockInfo(hash) {
    try {
      const { data: timestampedData, status } = await this._axiosInstance.get(
        `blocks/${hash}`,
        this._amountsAsStrings
      );
      if (status === 200) {
        const data = timestampedData.data;
        return {
          confirmations: data.confirmations,
          epoch: data.epoch,
          epochSlot: data.epoch_slot.toString(),
          fees: data.total_fees,
          hash: data.hash,
          nextBlock: data.next_block ?? "",
          operationalCertificate: data.operational_certificate?.hot_vkey,
          output: data.total_output_lovelace ?? "0",
          previousBlock: data.previous_block,
          size: data.size,
          slot: data.absolute_slot.toString(),
          slotLeader: data.block_producer ?? "",
          time: Date.parse(data.timestamp) / 1e3,
          txCount: data.tx_hashes.length,
          VRFKey: VrfVkBech32.fromHex(data.vrf_key)
        };
      }
      throw parseHttpError(timestampedData);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchCollectionAssets(policyId, cursor) {
    try {
      const { data: timestampedData, status } = await this._axiosInstance.get(
        `policy/${policyId}/assets?count=100${cursor ? `&cursor=${cursor}` : ""}`
      );
      if (status === 200) {
        const data = timestampedData.data;
        return {
          assets: data.map((asset) => ({
            unit: policyId + asset.asset_name,
            quantity: asset.total_supply
          })),
          next: timestampedData.next_cursor
        };
      }
      throw parseHttpError(timestampedData);
    } catch (error) {
      return { assets: [], next: null };
    }
  }
  async fetchHandle(handle) {
    if (this._network !== "Mainnet") {
      throw new Error(
        "Does not support fetching addresses by handle on non-mainnet networks."
      );
    }
    try {
      const assetName = fromUTF84(`${handle.replace("$", "")}`);
      const asset = await this.fetchAssetMetadata(
        `${SUPPORTED_HANDLES3[1]}000643b0${assetName}`
      );
      if (asset.metadata !== void 0) return asset.metadata;
      throw "Problem fetching metadata";
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchHandleAddress(handle) {
    if (this._network !== "Mainnet") {
      throw new Error(
        "Does not support fetching addresses by handle on non-mainnet networks."
      );
    }
    try {
      const handleWithoutDollar = handle.charAt(0) === "$" ? handle.substring(1) : handle;
      const { data: timestampedData, status } = await this._axiosInstance.get(
        `ecosystem/adahandle/${handleWithoutDollar}`
      );
      if (status === 200) return timestampedData.data;
      throw parseHttpError(timestampedData);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchProtocolParameters(epoch = Number.NaN) {
    if (!isNaN(epoch))
      throw new Error(
        "Maestro only supports fetching Protocol parameters of the latest completed epoch."
      );
    const decimalFromRationalString = (str) => {
      const forwardSlashIndex = str.indexOf("/");
      return parseInt(str.slice(0, forwardSlashIndex)) / parseInt(str.slice(forwardSlashIndex + 1));
    };
    try {
      const { data: timestampedData, status } = await this._axiosInstance.get("protocol-params");
      if (status === 200) {
        const data = timestampedData.data;
        try {
          const { data: timestampedDataEpochData, status: epochStatus } = await this._axiosInstance.get("epochs/current");
          if (epochStatus === 200) {
            const epochData = timestampedDataEpochData.data;
            return castProtocol4({
              coinsPerUtxoSize: parseInt(data.coins_per_utxo_byte),
              collateralPercent: parseInt(data.collateral_percentage),
              decentralisation: 0,
              // Deprecated in Babbage era.
              epoch: parseInt(epochData.epoch_no),
              keyDeposit: parseInt(data.stake_key_deposit),
              maxBlockExMem: data.max_execution_units_per_block.memory.toString(),
              maxBlockExSteps: data.max_execution_units_per_block.steps.toString(),
              maxBlockHeaderSize: parseInt(data.max_block_header_size),
              maxBlockSize: parseInt(data.max_block_body_size),
              maxCollateralInputs: parseInt(data.max_collateral_inputs),
              maxTxExMem: data.max_execution_units_per_transaction.memory.toString(),
              maxTxExSteps: data.max_execution_units_per_transaction.steps.toString(),
              maxTxSize: parseInt(data.max_tx_size),
              maxValSize: parseInt(data.max_value_sized),
              minFeeA: data.min_fee_coefficient,
              minFeeB: data.min_fee_constant,
              minPoolCost: data.min_pool_cost.toString(),
              poolDeposit: parseInt(data.pool_deposit),
              priceMem: decimalFromRationalString(data.prices.memory),
              priceStep: decimalFromRationalString(data.prices.steps)
            });
          }
          throw parseHttpError(timestampedDataEpochData);
        } catch (error) {
          throw parseHttpError(error);
        }
      }
      throw parseHttpError(timestampedData);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchTxInfo(hash) {
    try {
      const { data: timestampedData, status } = await this._axiosInstance.get(
        `transactions/${hash}`
      );
      if (status === 200) {
        const data = timestampedData.data;
        return {
          block: data.block_hash,
          deposit: data.deposit.toString(),
          fees: data.fee.toString(),
          hash: data.tx_hash,
          index: data.block_tx_index,
          invalidAfter: data.invalid_hereafter ?? "",
          invalidBefore: data.invalid_before ?? "",
          slot: data.block_absolute_slot.toString(),
          size: data.size - 1
        };
      }
      throw parseHttpError(timestampedData);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchUTxOs(hash, index) {
    try {
      const { data: timestampedData, status } = await this._axiosInstance.get(
        `transactions/${hash}`,
        this._amountsAsStrings
      );
      if (status === 200) {
        const msOutputs = timestampedData.data.outputs;
        const outputs = msOutputs.map(this.toUTxO);
        if (index !== void 0) {
          return outputs.filter((utxo) => utxo.input.outputIndex === index);
        }
        return outputs;
      }
      throw parseHttpError(timestampedData);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchGovernanceProposal(txHash, certIndex) {
    throw new Error("Method not implemented by Maestro");
  }
  async get(url) {
    try {
      const { data, status } = await this._axiosInstance.get(url);
      if (status === 200) {
        return data;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  onTxConfirmed(txHash, callback, limit = 100) {
    let attempts = 0;
    const checkTx = setInterval(() => {
      if (attempts >= limit) clearInterval(checkTx);
      this.fetchTxInfo(txHash).then((txInfo) => {
        this.fetchBlockInfo(txInfo.block).then((blockInfo) => {
          if (blockInfo?.confirmations > 0) {
            clearInterval(checkTx);
            callback();
          }
        }).catch(() => {
          attempts += 1;
        });
      }).catch(() => {
        attempts += 1;
      });
    }, 5e3);
  }
  async submitTx(tx) {
    try {
      const headers = { "Content-Type": "application/cbor" };
      const { data, status } = await this._axiosInstance.post(
        this.submitUrl,
        toBytes3(tx),
        { headers }
      );
      if (status === 202) return data;
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  toUTxO = (utxo) => ({
    input: {
      outputIndex: utxo.index,
      txHash: utxo.tx_hash
    },
    output: {
      address: utxo.address,
      amount: utxo.assets.map((asset) => ({
        unit: asset.unit,
        quantity: asset.amount
      })),
      dataHash: utxo.datum?.hash,
      plutusData: utxo.datum?.bytes,
      scriptRef: this.resolveScript(utxo),
      scriptHash: utxo.reference_script?.hash
    }
  });
  resolveScript = (utxo) => {
    if (utxo.reference_script) {
      let script;
      if (utxo.reference_script.type === "native") {
        script = utxo.reference_script.json;
      } else {
        const scriptBytes = utxo.reference_script.bytes;
        if (scriptBytes) {
          const normalized = normalizePlutusScript3(scriptBytes, "DoubleCBOR");
          script = {
            code: normalized,
            version: utxo.reference_script.type.replace("plutusv", "V")
          };
        } else {
          throw new Error("Script bytes not found");
        }
      }
      return toScriptRef3(script).toCbor().toString();
    } else return void 0;
  };
};

// src/ogmios.ts
import {
  isNetwork,
  SUPPORTED_OGMIOS_LINKS
} from "@meshsdk/common";
var OgmiosProvider = class {
  _baseUrl;
  constructor(...args) {
    this._baseUrl = isNetwork(args[0]) ? SUPPORTED_OGMIOS_LINKS[args[0]] : args[0];
  }
  async evaluateTx(tx) {
    const client = await this.open();
    this.send(client, "EvaluateTx", {
      evaluate: tx
    });
    return new Promise((resolve, reject) => {
      client.addEventListener(
        "message",
        (response) => {
          try {
            const { result } = JSON.parse(response.data);
            if (result.EvaluationResult) {
              resolve(
                Object.keys(result.EvaluationResult).map((key) => {
                  return {
                    index: parseInt(key.split(":")[1], 10),
                    tag: key.split(":")[0].toUpperCase(),
                    budget: {
                      mem: result.EvaluationResult[key].memory,
                      steps: result.EvaluationResult[key].steps
                    }
                  };
                })
              );
            } else {
              reject(result.EvaluationFailure);
            }
            client.close();
          } catch (error) {
            reject(error);
          }
        },
        { once: true }
      );
    });
  }
  async onNextTx(callback) {
    const client = await this.open();
    this.send(client, "AwaitAcquire", {});
    client.addEventListener("message", (response) => {
      const { result } = JSON.parse(response.data);
      if (result === null) {
        return this.send(client, "AwaitAcquire", {});
      }
      if (result.AwaitAcquired === void 0) {
        callback(result);
      }
      this.send(client, "NextTx", {});
    });
    return () => client.close();
  }
  async submitTx(tx) {
    const client = await this.open();
    this.send(client, "SubmitTx", {
      submit: tx
    });
    return new Promise((resolve, reject) => {
      client.addEventListener(
        "message",
        (response) => {
          try {
            const { result } = JSON.parse(response.data);
            if (result.SubmitSuccess) {
              resolve(result.SubmitSuccess.txId);
            } else {
              reject(result.SubmitFail);
            }
            client.close();
          } catch (error) {
            reject(error);
          }
        },
        { once: true }
      );
    });
  }
  async open() {
    const client = new WebSocket(this._baseUrl);
    await new Promise((resolve) => {
      client.addEventListener("open", () => resolve(true), { once: true });
    });
    return client;
  }
  send(client, methodname, args) {
    client.send(
      JSON.stringify({
        version: "1.0",
        type: "jsonwsp/request",
        servicename: "ogmios",
        methodname,
        args
      })
    );
  }
};

// src/utxo-rpc.ts
import { CardanoQueryClient, CardanoSubmitClient } from "@utxorpc/sdk";
import { submit } from "@utxorpc/spec";
import {
  bytesToHex,
  castProtocol as castProtocol5,
  hexToBytes,
  toBytes as toBytes4
} from "@meshsdk/common";
import { Address, CardanoSDKUtil } from "@meshsdk/core-cst";
var U5CProvider = class {
  // Clients for querying and submitting transactions on the Cardano blockchain.
  queryClient;
  submitClient;
  /**
   * Constructor initializes the query and submit clients with provided URL and optional headers.
   * @param url - The base URL for interacting with Cardano nodes.
   * @param headers - Optional HTTP headers for API requests.
   */
  constructor({
    url,
    headers
  }) {
    this.queryClient = new CardanoQueryClient({
      uri: url,
      headers
    });
    this.submitClient = new CardanoSubmitClient({
      uri: url,
      headers
    });
  }
  /**
   * Allow you to listen to a transaction confirmation. Upon confirmation, the callback will be called.
   * @param txHash - The transaction hash to listen for confirmation
   * @param callback - The callback function to call when the transaction is confirmed
   * @param limit - The number of blocks to wait for confirmation
   */
  onTxConfirmed(txHash, callback, limit = 100) {
    const onConfirmed = async () => {
      const updates = this.submitClient.waitForTx(hexToBytes(txHash));
      for await (const stage of updates) {
        console.log(JSON.stringify(updates));
        if (stage === submit.Stage.CONFIRMED) {
          callback();
          return;
        }
      }
    };
    const timeoutId = setTimeout(() => {
      console.log("Transaction confirmation timed out.");
    }, limit * 5e3);
    onConfirmed().finally(() => clearTimeout(timeoutId));
  }
  /**
   * Evaluates the resources required to execute the transaction
   * @param tx - The transaction to evaluate
   */
  evaluateTx(tx) {
    throw new Error("Method not implemented.");
  }
  /**
   * Submit a serialized transaction to the network.
   * @param tx - The serialized transaction in hex to submit
   * @returns The transaction hash of the submitted transaction
   */
  async submitTx(tx) {
    const cbor = toBytes4(tx);
    const hash = await this.submitClient.submitTx(cbor);
    return bytesToHex(hash);
  }
  /**
   * Obtain information about a specific stake account.
   * @param address - Wallet address to fetch account information
   */
  fetchAccountInfo(address) {
    throw new Error("Method not implemented.");
  }
  async fetchAddressAssets(address) {
    const utxos = await this.fetchAddressUTxOs(address);
    return utxosToAssets(utxos);
  }
  /**
   * Fetches the UTxOs for a given address.
   * @param address - The address to fetch UTxOs for
   * @param asset - The asset to filter UTxOs by (optional)
   * @returns UTxOs for the given address
   */
  async fetchAddressUTxOs(address, asset) {
    const addressBytes = Buffer.from(Address.fromBech32(address).toBytes());
    const utxoSearchResult = await this.queryClient.searchUtxosByAddress(addressBytes);
    return utxoSearchResult.map((item) => {
      const utxo = this._rpcUtxoToMeshUtxo(item.txoRef, item.parsedValued);
      if (asset) {
        if (utxo.output.amount.some((amountItem) => amountItem.unit === asset)) {
          return utxo;
        }
        return void 0;
      }
      return utxo;
    }).filter((utxo) => utxo !== void 0);
  }
  /**
   * Fetches the asset addresses for a given asset.
   * @param asset - The asset to fetch addresses for
   */
  fetchAssetAddresses(asset) {
    throw new Error("Method not implemented.");
  }
  /**
   * Fetches the metadata for a given asset.
   * @param asset - The asset to fetch metadata for
   */
  fetchAssetMetadata(asset) {
    throw new Error("Method not implemented.");
  }
  /**
   * Fetches the block information for a given block hash.
   * @param hash - The block hash to fetch block information for
   */
  fetchBlockInfo(hash) {
    throw new Error("Method not implemented.");
  }
  /**
   * Fetches the collection assets for a given policy ID.
   * @param policyId - The policy ID to fetch collection assets for
   * @param cursor - The cursor to fetch the next set of assets (optional)
   */
  fetchCollectionAssets(policyId, cursor) {
    throw new Error("Method not implemented.");
  }
  /**
   * Fetches the information (AssetMetadata) for a given handle.
   * @param handle - The handle to fetch information for
   */
  fetchHandle(handle) {
    throw new Error("Method not implemented.");
  }
  /**
   * Resolve the handle's address from the handle.
   * @param handle - The handle to resolve
   */
  fetchHandleAddress(handle) {
    throw new Error("Method not implemented.");
  }
  /**
   * Fetches protocol parameters
   */
  async fetchProtocolParameters(epoch = Number.NaN) {
    const rpcPParams = await this.queryClient.readParams();
    if (rpcPParams === void 0 || rpcPParams === null) {
      throw new Error(`Error fetching protocol parameters`);
    }
    return this._rpcPParamsToProtocol(rpcPParams);
  }
  /**
   * Fetches transaction info for a given hash.
   * @param hash - The transaction hash
   */
  fetchTxInfo(hash) {
    throw new Error("Method not implemented.");
  }
  /**
   * Fetches output UTxOs of a given transaction hash.
   * @param hash - The transaction hash
   */
  fetchUTxOs(hash) {
    throw new Error("Method not implemented.");
  }
  async fetchGovernanceProposal(txHash, certIndex) {
    throw new Error("Method not implemented");
  }
  get(url) {
    throw new Error("Method not implemented.");
  }
  /**
   * Waits for transaction confirmation within a given timeout.
   * @param txId - The transaction hash.
   * @param timeout - Optional timeout in milliseconds.
   * @returns True if the transaction is confirmed within the timeout, otherwise false.
   */
  awaitTransactionConfirmation(txId, timeout) {
    const onConfirmed = (async () => {
      const updates = this.submitClient.waitForTx(hexToBytes(txId));
      for await (const stage of updates) {
        if (stage == submit.Stage.CONFIRMED) {
          return true;
        }
      }
      return false;
    })();
    const onTimeout = new Promise(
      (resolve) => setTimeout(() => resolve(false), timeout)
    );
    return Promise.race([onConfirmed, onTimeout]);
  }
  /**
   * Helper function to convert an RPC UTxO object to a Mesh UTxO object.
   * @param rpcTxoRef - The transaction output reference from RPC.
   * @param rpcTxOutput - The transaction output details from RPC.
   * @returns A formatted UTxO object.
   */
  _rpcUtxoToMeshUtxo(rpcTxoRef, rpcTxOutput) {
    const amount = [
      {
        unit: "lovelace",
        quantity: rpcTxOutput.coin.toString()
      }
    ];
    rpcTxOutput.assets.forEach((ma) => {
      ma.assets.forEach((asset) => {
        amount.push({
          unit: Buffer.from(ma.policyId).toString("hex") + Buffer.from(asset.name).toString("hex"),
          quantity: asset.outputCoin.toString()
        });
      });
    });
    let dataHash = void 0;
    let plutusData = void 0;
    if (rpcTxOutput.datum !== void 0) {
      if (rpcTxOutput.datum?.originalCbor && rpcTxOutput.datum.originalCbor.length > 0) {
        dataHash = Buffer.from(rpcTxOutput.datum.hash).toString("hex");
        plutusData = Buffer.from(rpcTxOutput.datum.originalCbor).toString(
          "hex"
        );
      } else if (rpcTxOutput.datum?.hash && rpcTxOutput.datum.hash.length > 0) {
        dataHash = Buffer.from(rpcTxOutput.datum.hash).toString("hex");
      }
    }
    let scriptRef = void 0;
    let scriptHash = void 0;
    if (rpcTxOutput.script !== void 0) {
    }
    return {
      input: {
        outputIndex: rpcTxoRef.index,
        txHash: Buffer.from(rpcTxoRef.hash).toString("hex")
      },
      output: {
        address: Address.fromBytes(
          CardanoSDKUtil.HexBlob.fromBytes(rpcTxOutput.address)
        ).toBech32(),
        amount,
        dataHash,
        plutusData,
        scriptRef,
        scriptHash
      }
    };
  }
  /**
   * Converts RPC protocol parameters to a Mesh Protocol object.
   * @param rpcPParams - The protocol parameters from the RPC.
   * @returns A Protocol object.
   */
  _rpcPParamsToProtocol(rpcPParams) {
    return castProtocol5({
      coinsPerUtxoSize: Number(rpcPParams.coinsPerUtxoByte),
      collateralPercent: Number(rpcPParams.collateralPercentage),
      decentralisation: 0,
      // Deprecated in Babbage era.
      keyDeposit: Number(rpcPParams.stakeKeyDeposit),
      maxBlockExMem: Number(rpcPParams.maxExecutionUnitsPerBlock?.memory),
      maxBlockExSteps: Number(rpcPParams.maxExecutionUnitsPerBlock?.steps),
      maxBlockHeaderSize: Number(rpcPParams.maxBlockHeaderSize),
      maxBlockSize: Number(rpcPParams.maxBlockBodySize),
      maxCollateralInputs: Number(rpcPParams.maxCollateralInputs),
      maxTxExMem: Number(rpcPParams.maxExecutionUnitsPerTransaction?.memory),
      maxTxExSteps: Number(rpcPParams.maxExecutionUnitsPerTransaction?.steps),
      maxTxSize: Number(rpcPParams.maxTxSize),
      maxValSize: Number(rpcPParams.maxValueSize),
      minFeeA: Number(rpcPParams.minFeeCoefficient),
      minFeeB: Number(rpcPParams.minFeeConstant),
      minPoolCost: Number(rpcPParams.minPoolCost),
      poolDeposit: Number(rpcPParams.poolDeposit),
      priceMem: Number(rpcPParams.prices?.memory),
      priceStep: Number(rpcPParams.prices?.steps)
    });
  }
};

// src/yaci.ts
import axios7 from "axios";
import {
  castProtocol as castProtocol6,
  fromUTF8 as fromUTF85,
  SUPPORTED_HANDLES as SUPPORTED_HANDLES4
} from "@meshsdk/common";
import {
  normalizePlutusScript as normalizePlutusScript4,
  resolveRewardAddress as resolveRewardAddress4,
  toScriptRef as toScriptRef4
} from "@meshsdk/core-cst";
var YaciProvider = class {
  _axiosInstance;
  _adminAxiosInstance;
  /**
   * Set the URL of the instance.
   * @param baseUrl The base URL of the instance.
   */
  constructor(baseUrl = "https://yaci-node.meshjs.dev/api/v1/", adminUrl) {
    this._axiosInstance = axios7.create({
      baseURL: baseUrl
    });
    if (adminUrl) {
      this._adminAxiosInstance = axios7.create({
        baseURL: adminUrl
      });
    }
  }
  async fetchAccountInfo(address) {
    const rewardAddress = address.startsWith("addr") ? resolveRewardAddress4(address) : address;
    try {
      const { data, status } = await this._axiosInstance.get(
        `accounts/${rewardAddress}`
      );
      if (status === 200)
        return {
          poolId: data.pool_id,
          active: data.active || data.active_epoch !== null,
          balance: data.controlled_amount,
          rewards: data.withdrawable_amount,
          withdrawals: data.withdrawals_sum
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  resolveScriptRef = async (scriptHash) => {
    if (scriptHash) {
      const { data, status } = await this._axiosInstance.get(
        `scripts/${scriptHash}`
      );
      if (status === 200) {
        let script;
        if (data.type.startsWith("plutus")) {
          const plutusScript = await this.fetchPlutusScriptCBOR(scriptHash);
          const normalized = normalizePlutusScript4(plutusScript, "DoubleCBOR");
          script = {
            version: data.type.replace("plutus", ""),
            code: normalized
          };
        } else {
          script = await this.fetchNativeScriptJSON(scriptHash);
        }
        return toScriptRef4(script).toCbor();
      }
      throw parseHttpError(data);
    }
    return void 0;
  };
  toUTxO = async (bfUTxO, tx_hash) => ({
    input: {
      outputIndex: bfUTxO.output_index,
      txHash: tx_hash
    },
    output: {
      address: bfUTxO.address,
      amount: bfUTxO.amount.map((utxo) => {
        return { ...utxo, quantity: utxo.quantity.toString() };
      }),
      dataHash: bfUTxO.data_hash ?? void 0,
      plutusData: bfUTxO.inline_datum ?? void 0,
      scriptRef: bfUTxO.script_ref ? bfUTxO.script_ref : bfUTxO.reference_script_hash ? await this.resolveScriptRef(bfUTxO.reference_script_hash) : void 0,
      scriptHash: bfUTxO.reference_script_hash
    }
  });
  async fetchAddressAssets(address) {
    const utxos = await this.fetchAddressUTxOs(address);
    return utxosToAssets(utxos);
  }
  async fetchAddressUTxOs(address, asset) {
    const filter = asset !== void 0 ? `/${asset}` : "";
    const url = `addresses/${address}/utxos` + filter;
    const paginateUTxOs = async (page = 1, utxos = []) => {
      const { data, status } = await this._axiosInstance.get(
        `${url}?page=${page}`
      );
      if (status === 200)
        return data.length > 0 ? paginateUTxOs(page + 1, [
          ...utxos,
          ...await Promise.all(
            data.map((utxo) => this.toUTxO(utxo, utxo.tx_hash))
          )
        ]) : utxos;
      throw parseHttpError(data);
    };
    try {
      return await paginateUTxOs();
    } catch (error) {
      return [];
    }
  }
  async fetchAssetAddresses(asset) {
    const paginateAddresses = async (page = 1, addresses = []) => {
      const { policyId, assetName } = parseAssetUnit(asset);
      const { data, status } = await this._axiosInstance.get(
        `assets/${policyId}${assetName}/addresses?page=${page}`
      );
      if (status === 200)
        return data.length > 0 ? paginateAddresses(page + 1, [...addresses, ...data]) : addresses;
      throw parseHttpError(data);
    };
    try {
      return await paginateAddresses();
    } catch (error) {
      return [];
    }
  }
  async fetchAssetMetadata(asset) {
    try {
      const { policyId, assetName } = parseAssetUnit(asset);
      const { data, status } = await this._axiosInstance.get(
        `assets/${policyId}${assetName}`
      );
      if (status === 200)
        return {
          ...data.onchain_metadata
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchBlockInfo(hash) {
    try {
      const { data, status } = await this._axiosInstance.get(`blocks/${hash}`);
      if (status === 200)
        return {
          confirmations: data.confirmations,
          epoch: data.epoch,
          epochSlot: data.epoch_slot.toString(),
          fees: data.fees,
          hash: data.hash,
          nextBlock: data.next_block ?? "",
          operationalCertificate: data.op_cert,
          output: data.output ?? "0",
          previousBlock: data.previous_block,
          size: data.size,
          slot: data.slot.toString(),
          slotLeader: data.slot_leader ?? "",
          time: data.time,
          txCount: data.tx_count,
          VRFKey: data.block_vrf
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchCollectionAssets(policyId, cursor = 1) {
    try {
      const { data, status } = await this._axiosInstance.get(
        `assets/policy/${policyId}?page=${cursor}`
      );
      if (status === 200)
        return {
          assets: data.map((asset) => ({
            unit: asset.asset,
            quantity: asset.quantity
          })),
          next: data.length === 100 ? cursor + 1 : null
        };
      throw parseHttpError(data);
    } catch (error) {
      return { assets: [], next: null };
    }
  }
  async fetchHandle(handle) {
    throw new Error("Method not implemented.");
  }
  async fetchHandleAddress(handle) {
    try {
      const assetName = fromUTF85(handle.replace("$", ""));
      const { data, status } = await this._axiosInstance.get(
        `assets/${SUPPORTED_HANDLES4[1]}${assetName}/addresses`
      );
      if (status === 200) return data[0].address;
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchProtocolParameters(epoch = Number.NaN) {
    try {
      const { data, status } = await this._axiosInstance.get(
        `epochs/${isNaN(epoch) ? "latest" : epoch}/parameters`
      );
      if (status === 200)
        return castProtocol6({
          coinsPerUtxoSize: data.coins_per_utxo_size,
          collateralPercent: data.collateral_percent,
          decentralisation: data.decentralisation_param,
          epoch: data.epoch,
          keyDeposit: data.key_deposit,
          maxBlockExMem: data.max_block_ex_mem,
          maxBlockExSteps: data.max_block_ex_steps,
          maxBlockHeaderSize: data.max_block_header_size,
          maxBlockSize: data.max_block_size,
          maxCollateralInputs: data.max_collateral_inputs,
          maxTxExMem: data.max_tx_ex_mem,
          maxTxExSteps: data.max_tx_ex_steps,
          maxTxSize: data.max_tx_size,
          maxValSize: data.max_val_size,
          minFeeA: data.min_fee_a,
          minFeeB: data.min_fee_b,
          minPoolCost: data.min_pool_cost,
          poolDeposit: data.pool_deposit,
          priceMem: data.price_mem,
          priceStep: data.price_step
        });
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchTxInfo(hash) {
    try {
      const { data, status } = await this._axiosInstance.get(`txs/${hash}`);
      if (status === 200)
        return {
          block: data.block,
          deposit: data.deposit,
          fees: data.fees,
          hash: data.hash,
          index: data.index,
          invalidAfter: data.invalid_hereafter ?? "",
          invalidBefore: data.invalid_before ?? "",
          slot: data.slot.toString(),
          size: data.size
        };
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchUTxOs(hash, index) {
    try {
      const { data, status } = await this._axiosInstance.get(
        `txs/${hash}/utxos`
      );
      if (status === 200) {
        const bfOutputs = data.outputs;
        const outputsPromises = [];
        bfOutputs.forEach((output) => {
          outputsPromises.push(this.toUTxO(output, hash));
        });
        const outputs = await Promise.all(outputsPromises);
        if (index !== void 0) {
          return outputs.filter((utxo) => utxo.input.outputIndex === index);
        }
        return outputs;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchGovernanceProposal(txHash, certIndex) {
    throw new Error("Method not implemented by Maestro");
  }
  async get(url) {
    try {
      const { data, status } = await this._axiosInstance.get(url);
      if (status === 200) {
        return data;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  onTxConfirmed(txHash, callback, limit = 100) {
    let attempts = 0;
    const checkTx = setInterval(() => {
      if (attempts >= limit) clearInterval(checkTx);
      this.fetchTxInfo(txHash).then((txInfo) => {
        this.fetchBlockInfo(txInfo.block).then((blockInfo) => {
          if (blockInfo?.confirmations > 0) {
            clearInterval(checkTx);
            callback();
          }
        }).catch(() => {
          attempts += 1;
        });
      }).catch(() => {
        attempts += 1;
      });
    }, 5e3);
  }
  async submitTx(txHex) {
    try {
      const headers = { "Content-Type": "text/plain" };
      const { status, data } = await this._axiosInstance.post(
        "/tx/submit",
        txHex,
        {
          headers
        }
      );
      if (status === 202) {
        return data;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async evaluateTx(txHex) {
    try {
      const headers = { "Content-Type": "application/cbor" };
      const { status, data } = await this._axiosInstance.post(
        "utils/txs/evaluate",
        txHex,
        {
          headers
        }
      );
      if (status === 202 && data.result.EvaluationResult) {
        const tagMap = {
          spend: "SPEND",
          mint: "MINT",
          certificate: "CERT",
          reward: "REWARD"
        };
        const result = [];
        Object.keys(data.result.EvaluationResult).forEach((key) => {
          const [tagKey, index] = key.split(":");
          const { memory, steps } = data.result.EvaluationResult[key];
          result.push({
            tag: tagMap[tagKey],
            index: Number(index),
            budget: { mem: memory, steps }
          });
        });
        return result;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async getDevnetInfo() {
    try {
      if (this._adminAxiosInstance === void 0)
        throw parseHttpError("Admin URL not provided");
      const { status, data } = await this._adminAxiosInstance.get(
        `local-cluster/api/admin/devnet`
      );
      if (status === 200) {
        return data;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async getGenesisByEra(era) {
    try {
      if (this._adminAxiosInstance === void 0)
        throw parseHttpError("Admin URL not provided");
      const { status, data } = await this._adminAxiosInstance.get(
        `local-cluster/api/admin/devnet/genesis/${era}`
      );
      if (status === 200) {
        return data;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Topup address with ADA
   * @param address - Address to topup
   * @param amount - Amount to topup
   */
  async addressTopup(address, amount) {
    try {
      if (this._adminAxiosInstance === void 0)
        throw parseHttpError("Admin URL not provided");
      const headers = { "Content-Type": "application/json", accept: "*/*" };
      const { status, data } = await this._adminAxiosInstance.post(
        "local-cluster/api/addresses/topup",
        JSON.stringify({ address, adaAmount: parseInt(amount) }),
        {
          headers
        }
      );
      if (status === 200) {
        return data;
      }
      throw parseHttpError(data);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  async fetchPlutusScriptCBOR(scriptHash) {
    const { data, status } = await this._axiosInstance.get(
      `scripts/${scriptHash}/cbor`
    );
    if (status === 200) return data.cbor;
    throw parseHttpError(data);
  }
  async fetchNativeScriptJSON(scriptHash) {
    const { data, status } = await this._axiosInstance.get(
      `scripts/${scriptHash}/json`
    );
    if (status === 200) return data.json;
    throw parseHttpError(data);
  }
};

// src/offline/offline-fetcher.ts
import {
  fromUTF8 as fromUTF86,
  SUPPORTED_HANDLES as SUPPORTED_HANDLES5
} from "@meshsdk/common";
var OfflineFetcher = class _OfflineFetcher {
  accounts = {};
  utxos = {};
  assetAddresses = {};
  assetMetadata = {};
  blocks = {};
  collections = {};
  protocolParameters = {};
  transactions = {};
  paginate(items, cursor, pageSize = 20) {
    const startIndex = cursor != null ? parseInt(String(cursor), 10) : 0;
    const paginatedItems = items.slice(startIndex, startIndex + pageSize);
    const nextCursor = startIndex + pageSize < items.length ? startIndex + pageSize : void 0;
    return { paginatedItems, nextCursor };
  }
  /**
   * Fetches account information for a given address.
   * @param address - Address to fetch info for
   * @returns Promise resolving to account information
   * @throws Error if account not found
   */
  async fetchAccountInfo(address) {
    const account = this.accounts[address];
    if (!account) throw new Error(`Account not found: ${address}`);
    return account;
  }
  /**
   * Fetches UTXOs for a given address, optionally filtered by asset.
   * @param address - Address to fetch UTXOs for
   * @param asset - Optional asset ID to filter UTXOs
   * @returns Promise resolving to array of UTXOs
   */
  async fetchAddressUTxOs(address, asset) {
    const addressUtxos = this.utxos[address] || [];
    return asset ? addressUtxos.filter((utxo) => utxo.output.amount.some((a) => a.unit === asset)) : addressUtxos;
  }
  /**
   * Fetches addresses holding a specific asset.
   * @param asset - Asset identifier
   * @returns Promise resolving to array of asset addresses and quantities
   */
  async fetchAssetAddresses(asset) {
    if (!_OfflineFetcher.isValidHex(asset)) {
      throw new Error("Invalid asset: must be a hex string");
    }
    const addressMap = /* @__PURE__ */ new Map();
    const registryAddresses = this.assetAddresses[asset] || [];
    for (const addr of registryAddresses) {
      addressMap.set(addr.address, BigInt(addr.quantity));
    }
    for (const [address, utxos] of Object.entries(this.utxos)) {
      for (const utxo of utxos) {
        const assetAmount = utxo.output.amount.find((amt) => amt.unit === asset);
        if (assetAmount) {
          const currentAmount = addressMap.get(address) || BigInt(0);
          addressMap.set(address, currentAmount + BigInt(assetAmount.quantity));
        }
      }
    }
    return Array.from(addressMap.entries()).filter(([_, quantity]) => quantity > BigInt(0)).map(([address, quantity]) => ({
      address,
      quantity: quantity.toString()
    }));
  }
  /**
   * Fetches all assets associated with an address.
   * @param address - Address to fetch assets for
   * @returns Promise resolving to array of assets held by the address
   */
  async fetchAddressAssets(address) {
    if (!_OfflineFetcher.isValidAddress(address)) {
      throw new Error("Invalid address: must be a valid Bech32 or Base58 address");
    }
    const assetMap = /* @__PURE__ */ new Map();
    const addressUtxos = this.utxos[address] || [];
    for (const utxo of addressUtxos) {
      for (const amount of utxo.output.amount) {
        const currentAmount = assetMap.get(amount.unit) || BigInt(0);
        assetMap.set(amount.unit, currentAmount + BigInt(amount.quantity));
      }
    }
    for (const [assetId, addresses] of Object.entries(this.assetAddresses)) {
      const assetAddress = addresses.find((addr) => addr.address === address);
      if (assetAddress) {
        const currentAmount = assetMap.get(assetId) || BigInt(0);
        assetMap.set(assetId, currentAmount + BigInt(assetAddress.quantity));
      }
    }
    return Array.from(assetMap.entries()).map(([unit, quantity]) => ({
      unit,
      quantity: quantity.toString()
    }));
  }
  /**
   * Fetches metadata for a specific asset.
   * @param asset - Asset identifier
   * @returns Promise resolving to asset metadata
   * @throws Error if asset metadata not found
   */
  async fetchAssetMetadata(asset) {
    const metadata = this.assetMetadata[asset];
    if (!metadata) throw new Error(`Asset metadata not found: ${asset}`);
    return metadata;
  }
  /**
   * Fetches information about a specific block.
   * @param hash - Block hash
   * @returns Promise resolving to block information
   * @throws Error if block not found
   */
  async fetchBlockInfo(hash) {
    const block = this.blocks[hash];
    if (!block) throw new Error(`Block not found: ${hash}`);
    return block;
  }
  /**
   * Fetches assets in a collection (by policy ID) with pagination.
   * @param policyId - Policy ID of the collection
   * @param cursor - Optional pagination cursor
   * @returns Promise resolving to paginated assets and next cursor
   * @throws Error if collection not found or invalid cursor
   */
  async fetchCollectionAssets(policyId, cursor) {
    const assets = this.collections[policyId];
    if (!assets) throw new Error(`Collection not found: ${policyId}`);
    if (cursor && !_OfflineFetcher.isIntegerString(String(cursor))) {
      throw new Error("Invalid cursor: must be a string of digits");
    }
    const { paginatedItems, nextCursor } = this.paginate(assets, cursor);
    return { assets: paginatedItems, next: nextCursor };
  }
  /**
   * Fetches metadata for a handle.
   * @param handle - Handle to fetch metadata for
   * @returns Promise resolving to handle metadata
   * @throws Error if handle not found or invalid
   */
  async fetchHandle(handle) {
    try {
      const assetName = fromUTF86(handle.replace("$", ""));
      const handleAsset = `${SUPPORTED_HANDLES5[1]}000de140${assetName}`;
      return await this.fetchAssetMetadata(handleAsset);
    } catch (error) {
      throw parseHttpError(error);
    }
  }
  /**
   * Fetches address associated with a handle.
   * @param handle - Handle to fetch address for
   * @returns Promise resolving to address
   * @throws Error if no address found for handle
   */
  async fetchHandleAddress(handle) {
    const assetName = fromUTF86(handle.replace("$", ""));
    const policyId = SUPPORTED_HANDLES5[1];
    const addresses = await this.fetchAssetAddresses(`${policyId}${assetName}`);
    const address = addresses[0]?.address;
    if (!address) {
      throw new Error(`No addresses found for handle: ${handle}`);
    }
    return address;
  }
  /**
   * Fetches protocol parameters for a specific epoch.
   * @param epoch - Epoch number
   * @returns Promise resolving to protocol parameters
   * @throws Error if parameters not found for epoch
   */
  async fetchProtocolParameters(epoch) {
    if (!epoch) {
      const maxEpochNumber = Math.max(...Object.keys(this.protocolParameters).map(Number));
      return this.protocolParameters[maxEpochNumber];
    }
    const parameters = this.protocolParameters[epoch];
    if (!parameters) throw new Error(`Protocol parameters not found for epoch: ${epoch}`);
    return parameters;
  }
  /**
   * Fetches information about a specific transaction.
   * @param hash - Transaction hash
   * @returns Promise resolving to transaction information
   * @throws Error if transaction not found
   */
  async fetchTxInfo(hash) {
    const transaction = this.transactions[hash];
    if (!transaction) throw new Error(`Transaction not found: ${hash}`);
    return transaction;
  }
  /**
   * Fetches all UTXOs associated with a specific transaction hash.
   * @param hash - Transaction hash to fetch UTXOs for
   * @returns Promise resolving to array of UTXOs associated with the transaction
   * @throws Error if no UTXOs found for the transaction hash
   */
  async fetchUTxOs(hash) {
    const utxos = Object.values(this.utxos).flat().filter((utxo) => utxo.input.txHash === hash);
    if (!utxos.length) throw new Error(`No UTxOs found for transaction hash: ${hash}`);
    return utxos;
  }
  async fetchGovernanceProposal(txHash, certIndex) {
    throw new Error("Method not implemented");
  }
  /**
   * HTTP GET method required by IFetcher interface but not implemented in OfflineFetcher.
   * @param url - URL to fetch from
   * @throws Error always, as this fetcher operates offline
   */
  async get(url) {
    throw new Error("Method not implemented in OfflineFetcher.");
  }
  /**
   * Serializes fetcher data to JSON string.
   * @returns JSON string containing all fetcher data
   */
  toJSON() {
    return JSON.stringify({
      accounts: this.accounts,
      utxos: this.utxos,
      assetAddresses: this.assetAddresses,
      assetMetadata: this.assetMetadata,
      blocks: this.blocks,
      collections: this.collections,
      protocolParameters: this.protocolParameters,
      transactions: this.transactions
    });
  }
  /**
   * Creates an OfflineFetcher instance from JSON data.
   * @param json - JSON string containing fetcher data
   * @returns New OfflineFetcher instance
   */
  static fromJSON(json) {
    const data = JSON.parse(json);
    const fetcher = new _OfflineFetcher();
    Object.entries(data.accounts || {}).forEach(([address, info]) => fetcher.addAccount(address, info));
    Object.entries(data.utxos || {}).forEach(([address, utxos]) => fetcher.addUTxOs(utxos));
    Object.entries(data.assetAddresses || {}).forEach(([asset, addresses]) => fetcher.addAssetAddresses(asset, addresses));
    Object.entries(data.assetMetadata || {}).forEach(([asset, metadata]) => fetcher.addAssetMetadata(asset, metadata));
    Object.entries(data.blocks || {}).forEach(([_, info]) => fetcher.addBlock(info));
    Object.entries(data.collections || {}).forEach(([policyId, assets]) => fetcher.addCollectionAssets(assets));
    Object.entries(data.protocolParameters || {}).forEach(([_, params]) => fetcher.addProtocolParameters(params));
    Object.entries(data.transactions || {}).forEach(([_, info]) => fetcher.addTransaction(info));
    return fetcher;
  }
  static isValidHex(str, length) {
    if (length !== void 0 && str.length !== length) {
      return false;
    }
    return /^[0-9a-fA-F]+$/.test(str);
  }
  static isValidAddress(address) {
    return _OfflineFetcher.isValidBech32Address(address) || _OfflineFetcher.isValidBase58(address);
  }
  static isValidBase58(input) {
    const base58Regex = /^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]+$/;
    if (!base58Regex.test(input)) {
      return false;
    }
    return true;
  }
  static isValidBech32(input, prefix) {
    if (input !== input.toLowerCase() && input !== input.toUpperCase()) {
      return false;
    }
    const pattern = new RegExp(`^${prefix}1[02-9ac-hj-np-z]+$`, "i");
    return pattern.test(input);
  }
  static isValidBech32Address(address) {
    return _OfflineFetcher.isValidBech32(address, "(addr|addr_test)");
  }
  static isValidBech32Pool(poolId) {
    return _OfflineFetcher.isValidBech32(poolId, "pool");
  }
  static isValidBech32VrfVk(vrfKey) {
    return _OfflineFetcher.isValidBech32(vrfKey, "vrf_vk");
  }
  static isIntegerString(str) {
    return /^\d+$/.test(str);
  }
  static isValidAssetOrLovelace(asset) {
    if (asset === "lovelace") {
      return true;
    }
    if (asset.length < 56) {
      return false;
    }
    return _OfflineFetcher.isValidHex(asset);
  }
  /**
   * Adds account information to the fetcher.
   * @param address - Account address
   * @param accountInfo - Account information
   * @throws Error if address or account info invalid
   */
  addAccount(address, accountInfo) {
    if (!_OfflineFetcher.isValidAddress(address)) {
      throw new Error("Invalid address: must be a valid Bech32 or Base58 address");
    }
    if (accountInfo.poolId !== void 0) {
      if (!_OfflineFetcher.isValidBech32Pool(accountInfo.poolId)) {
        throw new Error("Invalid 'poolId': must be a valid Bech32 pool address");
      }
    }
    if (!_OfflineFetcher.isIntegerString(accountInfo.balance)) {
      throw new Error("Invalid 'balance': must be a string of digits");
    }
    if (!_OfflineFetcher.isIntegerString(accountInfo.rewards)) {
      throw new Error("Invalid 'rewards': must be a string of digits");
    }
    if (!_OfflineFetcher.isIntegerString(accountInfo.withdrawals)) {
      throw new Error("Invalid 'withdrawals': must be a string of digits");
    }
    this.accounts[address] = accountInfo;
  }
  /**
   * Adds UTXOs to the fetcher.
   * @param utxos - Array of UTXOs
   * @throws Error if UTXOs invalid
   */
  addUTxOs(utxos) {
    if (!Array.isArray(utxos) || utxos.length === 0) {
      throw new Error("Invalid utxos: must be a non-empty array");
    }
    utxos.forEach((utxo, index) => {
      if (!Number.isInteger(utxo.input.outputIndex) || utxo.input.outputIndex < 0) {
        throw new Error(`Invalid outputIndex for UTxO at index ${index}: must be a non-negative integer`);
      }
      if (!_OfflineFetcher.isValidHex(utxo.input.txHash, 64)) {
        throw new Error(`Invalid txHash for UTxO at index ${index}: must be a 64-character hexadecimal string`);
      }
      if (!_OfflineFetcher.isValidAddress(utxo.output.address)) {
        throw new Error(`Invalid address in output for UTxO at index ${index}: must be a valid Bech32 or Base58 address`);
      }
      if (!Array.isArray(utxo.output.amount) || utxo.output.amount.length === 0) {
        throw new Error(`Invalid amount for UTxO at index ${index}: must be a non-empty array of assets`);
      }
      utxo.output.amount.forEach((asset, assetIndex) => {
        if (!_OfflineFetcher.isValidAssetOrLovelace(asset.unit)) {
          throw new Error(`Invalid unit for asset at index ${assetIndex} in UTxO at index ${index}`);
        }
        if (!_OfflineFetcher.isIntegerString(asset.quantity)) {
          throw new Error(`Invalid quantity for asset at index ${assetIndex} in UTxO at index ${index}: must be a string of digits`);
        }
      });
      if (utxo.output.dataHash !== void 0 && !_OfflineFetcher.isValidHex(utxo.output.dataHash, 64)) {
        throw new Error(`Invalid dataHash for UTxO at index ${index}: must be a 64-character hexadecimal string or undefined`);
      }
      if (utxo.output.plutusData !== void 0 && !_OfflineFetcher.isValidHex(utxo.output.plutusData)) {
        throw new Error(`Invalid plutusData for UTxO at index ${index}: must be a hexadecimal string or undefined`);
      }
      if (utxo.output.scriptRef !== void 0 && !_OfflineFetcher.isValidHex(utxo.output.scriptRef)) {
        throw new Error(`Invalid scriptRef for UTxO at index ${index}: must be a hexadecimal string or undefined`);
      }
      if (utxo.output.scriptHash !== void 0 && !_OfflineFetcher.isValidHex(utxo.output.scriptHash, 56)) {
        throw new Error(`Invalid scriptHash for UTxO at index ${index}: must be a 56-character hexadecimal string or undefined`);
      }
    });
    for (const utxo of utxos) {
      if (!this.utxos[utxo.output.address]) {
        this.utxos[utxo.output.address] = [];
      }
      this.utxos[utxo.output.address].push(utxo);
    }
  }
  /**
   * Adds asset address information to the fetcher.
   * @param asset - Asset identifier
   * @param addresses - Array of asset addresses
   * @throws Error if asset or addresses invalid
   */
  addAssetAddresses(asset, addresses) {
    if (!_OfflineFetcher.isValidHex(asset)) {
      throw new Error("Invalid asset: must be a hex string");
    }
    if (addresses.length === 0) {
      throw new Error("Invalid addresses: must be a non-empty array");
    }
    addresses.forEach((item, index) => {
      if (!_OfflineFetcher.isValidAddress(item.address)) {
        throw new Error(`Invalid 'address' field at index ${index}, should be bech32 string`);
      }
      if (!_OfflineFetcher.isIntegerString(item.quantity)) {
        throw new Error(`Invalid 'quantity' field at index ${index}, should be a string of digits`);
      }
    });
    this.assetAddresses[asset] = addresses;
  }
  /**
   * Adds asset metadata to the fetcher.
   * @param asset - Asset identifier
   * @param metadata - Asset metadata
   * @throws Error if asset or metadata invalid
   */
  addAssetMetadata(asset, metadata) {
    if (asset.length < 56) {
      throw new Error(`Invalid asset ${asset}: must be a string longer than 56 characters`);
    }
    if (!_OfflineFetcher.isValidHex(asset)) {
      throw new Error("Invalid asset: must be a hex string");
    }
    if (typeof metadata !== "object" || metadata === null) {
      throw new Error("Invalid metadata object");
    }
    this.assetMetadata[asset] = metadata;
  }
  /**
   * Adds collection assets to the fetcher.
   * @param assets - Array of assets
   * @throws Error if assets invalid
   */
  addCollectionAssets(assets) {
    if (!Array.isArray(assets) || assets.length === 0) {
      throw new Error("Invalid assets: must be a non-empty array");
    }
    const groupedAssets = {};
    assets.forEach((asset, index) => {
      if (asset.unit.length < 56) {
        throw new Error(`Invalid unit for asset at index ${index}: must be a string longer than 56 characters`);
      }
      if (!_OfflineFetcher.isValidHex(asset.unit)) {
        throw new Error(`Invalid unit for asset at index ${index}: must be a hexadecimal string`);
      }
      const policyId = asset.unit.slice(0, 56);
      if (!_OfflineFetcher.isValidHex(policyId, 56)) {
        throw new Error(`Invalid policyId in asset unit at index ${index}: must be a 56-character hexadecimal string`);
      }
      if (!_OfflineFetcher.isIntegerString(asset.quantity)) {
        throw new Error(`Invalid quantity for asset at index ${index}: must be a string of digits`);
      }
      if (!groupedAssets[policyId]) {
        groupedAssets[policyId] = [];
      }
      groupedAssets[policyId].push(asset);
    });
    for (const [policyId, policyAssets] of Object.entries(groupedAssets)) {
      if (!this.collections[policyId]) {
        this.collections[policyId] = [];
      }
      this.collections[policyId] = this.collections[policyId].concat(policyAssets);
    }
  }
  /**
   * Adds protocol parameters to the fetcher.
   * @param parameters - Protocol parameters
   * @throws Error if parameters invalid
   */
  addProtocolParameters(parameters) {
    if (parameters.epoch < 0 || !Number.isInteger(parameters.epoch)) {
      throw new Error("Invalid epoch: must be a non-negative integer");
    }
    if (parameters.minFeeA < 0 || !Number.isInteger(parameters.minFeeA)) {
      throw new Error("Invalid 'minFeeA': must be a non-negative integer");
    }
    if (parameters.minFeeB < 0 || !Number.isInteger(parameters.minFeeB)) {
      throw new Error("Invalid 'minFeeB': must be a non-negative integer");
    }
    if (parameters.maxBlockSize <= 0 || !Number.isInteger(parameters.maxBlockSize)) {
      throw new Error("Invalid 'maxBlockSize': must be a positive integer");
    }
    if (parameters.maxTxSize <= 0 || !Number.isInteger(parameters.maxTxSize)) {
      throw new Error("Invalid 'maxTxSize': must be a positive integer");
    }
    if (parameters.maxBlockHeaderSize <= 0 || !Number.isInteger(parameters.maxBlockHeaderSize)) {
      throw new Error("Invalid 'maxBlockHeaderSize': must be a positive integer");
    }
    if (parameters.keyDeposit < 0 || !Number.isInteger(parameters.keyDeposit)) {
      throw new Error("Invalid 'keyDeposit': must be a non-negative integer");
    }
    if (parameters.poolDeposit < 0 || !Number.isInteger(parameters.poolDeposit)) {
      throw new Error("Invalid 'poolDeposit': must be a non-negative integer");
    }
    if (parameters.decentralisation < 0 || parameters.decentralisation > 1) {
      throw new Error("Invalid 'decentralisation': must be between 0 and 1");
    }
    if (parameters.priceMem < 0) {
      throw new Error("Invalid 'priceMem': must be non-negative");
    }
    if (parameters.priceStep < 0) {
      throw new Error("Invalid 'priceStep': must be non-negative");
    }
    if (parameters.maxValSize < 0 || !Number.isInteger(parameters.maxValSize)) {
      throw new Error("Invalid 'maxValSize': must be a non-negative integer");
    }
    if (parameters.collateralPercent < 0) {
      throw new Error("Invalid 'collateralPercent': must be a non-negative integer");
    }
    if (parameters.maxCollateralInputs < 0 || !Number.isInteger(parameters.maxCollateralInputs)) {
      throw new Error("Invalid 'maxCollateralInputs': must be a non-negative integer");
    }
    if (parameters.coinsPerUtxoSize < 0) {
      throw new Error("Invalid 'coinsPerUtxoSize': must be non-negative");
    }
    if (parameters.minFeeRefScriptCostPerByte < 0) {
      throw new Error("Invalid 'minFeeRefScriptCostPerByte': must be non-negative");
    }
    if (!_OfflineFetcher.isIntegerString(parameters.minPoolCost)) {
      throw new Error("Invalid 'minPoolCost': must be a string of digits");
    }
    if (!_OfflineFetcher.isIntegerString(parameters.maxTxExMem)) {
      throw new Error("Invalid 'maxTxExMem': must be a string of digits");
    }
    if (!_OfflineFetcher.isIntegerString(parameters.maxTxExSteps)) {
      throw new Error("Invalid 'maxTxExSteps': must be a string of digits");
    }
    if (!_OfflineFetcher.isIntegerString(parameters.maxBlockExMem)) {
      throw new Error("Invalid 'maxBlockExMem': must be a string of digits");
    }
    if (!_OfflineFetcher.isIntegerString(parameters.maxBlockExSteps)) {
      throw new Error("Invalid 'maxBlockExSteps': must be a string of digits");
    }
    this.protocolParameters[parameters.epoch] = parameters;
  }
  /**
   * Adds transaction information to the fetcher.
   * @param txInfo - Transaction information
   * @throws Error if transaction info invalid
   */
  addTransaction(txInfo) {
    if (!_OfflineFetcher.isValidHex(txInfo.hash, 64)) {
      throw new Error("Invalid transaction hash: must be a 64-character hexadecimal string");
    }
    if (!Number.isInteger(txInfo.index) || txInfo.index < 0) {
      throw new Error("Invalid 'index': must be a non-negative integer");
    }
    if (!_OfflineFetcher.isValidHex(txInfo.block, 64)) {
      throw new Error("Invalid 'block': must be a 64-character hexadecimal string");
    }
    if (!_OfflineFetcher.isIntegerString(txInfo.slot)) {
      throw new Error("Invalid 'slot': must be a string of digits");
    }
    if (!_OfflineFetcher.isIntegerString(txInfo.fees)) {
      throw new Error("Invalid 'fees': must be a string of digits");
    }
    if (!Number.isInteger(txInfo.size) || txInfo.size <= 0) {
      throw new Error("Invalid 'size': must be a positive integer");
    }
    if (!/^-?\d+$/.test(txInfo.deposit)) {
      throw new Error("Invalid 'deposit': must be a string representing an integer (positive or negative)");
    }
    if (txInfo.invalidBefore !== "" && !_OfflineFetcher.isIntegerString(txInfo.invalidBefore)) {
      throw new Error("Invalid 'invalidBefore': must be a string of digits or empty string");
    }
    if (txInfo.invalidAfter !== "" && !_OfflineFetcher.isIntegerString(txInfo.invalidAfter)) {
      throw new Error("Invalid 'invalidAfter': must be a string of digits or empty string");
    }
    this.transactions[txInfo.hash] = txInfo;
  }
  /**
   * Adds block information to the fetcher.
   * @param blockInfo - Block information
   * @throws Error if block info invalid
   */
  addBlock(blockInfo) {
    if (!_OfflineFetcher.isValidHex(blockInfo.hash, 64)) {
      throw new Error("Invalid block hash: must be a 64-character hexadecimal string");
    }
    if (!Number.isInteger(blockInfo.time) || blockInfo.time < 0) {
      throw new Error("Invalid 'time': must be a non-negative integer");
    }
    if (!_OfflineFetcher.isIntegerString(blockInfo.slot)) {
      throw new Error("Invalid 'slot': must be a string of digits");
    }
    if (!Number.isInteger(blockInfo.epoch) || blockInfo.epoch < 0) {
      throw new Error("Invalid 'epoch': must be a non-negative integer");
    }
    if (!_OfflineFetcher.isIntegerString(blockInfo.epochSlot)) {
      throw new Error("Invalid 'epochSlot': must be a string of digits");
    }
    if (!_OfflineFetcher.isValidBech32Pool(blockInfo.slotLeader)) {
      throw new Error("Invalid 'slotLeader': must be a bech32 string with pool prefix");
    }
    if (!Number.isInteger(blockInfo.size) || blockInfo.size <= 0) {
      throw new Error("Invalid 'size': must be a positive integer");
    }
    if (!Number.isInteger(blockInfo.txCount) || blockInfo.txCount < 0) {
      throw new Error("Invalid 'txCount': must be a non-negative integer");
    }
    if (!_OfflineFetcher.isIntegerString(blockInfo.output)) {
      throw new Error("Invalid 'output': must be a string of digits");
    }
    if (!_OfflineFetcher.isValidHex(blockInfo.operationalCertificate, 64)) {
      throw new Error("Invalid 'operationalCertificate': must be a 64-character hexadecimal string");
    }
    if (!_OfflineFetcher.isValidHex(blockInfo.previousBlock, 64)) {
      throw new Error("Invalid 'previousBlock': must be a 64-character hexadecimal string");
    }
    if (!_OfflineFetcher.isValidBech32VrfVk(blockInfo.VRFKey)) {
      throw new Error("Invalid 'VRFKey': must be a bech32 string with vrf_vk1 prefix");
    }
    this.blocks[blockInfo.hash] = blockInfo;
  }
};
export {
  BeginProvider,
  BlockfrostProvider,
  HydraProvider,
  KoiosProvider,
  MaestroProvider,
  OfflineFetcher,
  OgmiosProvider,
  U5CProvider,
  YaciProvider
};
