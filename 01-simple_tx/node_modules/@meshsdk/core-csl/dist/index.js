// src/utils/address.ts
import {
  pubKeyAddress,
  scriptAddress
} from "@meshsdk/common";

// src/deser/csl.ts
import * as csl from "@sidan-lab/sidan-csl-rs-nodejs";

// src/deser/constants.ts
var LANGUAGE_VERSIONS = {
  V1: csl.Language.new_plutus_v1(),
  V2: csl.Language.new_plutus_v2(),
  V3: csl.Language.new_plutus_v3()
};
var REDEEMER_TAGS = {
  CERT: csl.RedeemerTag.new_cert(),
  MINT: csl.RedeemerTag.new_mint(),
  REWARD: csl.RedeemerTag.new_reward(),
  SPEND: csl.RedeemerTag.new_spend()
};
var POLICY_ID_LENGTH = 56;

// src/deser/converter.ts
import JSONbig from "json-bigint";
var toAddress = (bech322) => csl.Address.from_bech32(bech322);
var toBaseAddress = (bech322) => csl.BaseAddress.from_address(toAddress(bech322));
var toEnterpriseAddress = (bech322) => csl.EnterpriseAddress.from_address(toAddress(bech322));
var toRewardAddress = (bech322) => csl.RewardAddress.from_address(toAddress(bech322));
var fromBytes = (bytes) => Buffer.from(bytes).toString("hex");
var toBytes = (hex) => {
  if (hex.length % 2 === 0 && /^[0-9A-F]*$/i.test(hex))
    return Buffer.from(hex, "hex");
  return Buffer.from(hex, "utf-8");
};
var fromUTF8 = (utf8) => {
  if (utf8.length % 2 === 0 && /^[0-9A-F]*$/i.test(utf8)) return utf8;
  return fromBytes(Buffer.from(utf8, "utf-8"));
};
var toUTF8 = (hex) => Buffer.from(hex, "hex").toString("utf-8");
var fromLovelace = (lovelace) => lovelace / 1e6;
var toLovelace = (ada) => ada * 1e6;
var toScriptRef = (script) => {
  if ("code" in script) {
    const plutusScript = deserializePlutusScript(script.code, script.version);
    return csl.ScriptRef.new_plutus_script(plutusScript);
  }
  return csl.ScriptRef.new_native_script(toNativeScript(script));
};
var toPlutusData = (data) => {
  const toPlutusList = (dataArray) => {
    const plutusList = csl.PlutusList.new();
    dataArray.forEach((element) => {
      plutusList.add(toPlutusData(element));
    });
    return plutusList;
  };
  switch (typeof data) {
    case "string":
      return csl.PlutusData.new_bytes(toBytes(data));
    case "number":
      return csl.PlutusData.new_integer(csl.BigInt.from_str(data.toString()));
    case "bigint":
      return csl.PlutusData.new_integer(csl.BigInt.from_str(data.toString()));
    case "object":
      if (data instanceof Array) {
        const plutusList = toPlutusList(data);
        return csl.PlutusData.new_list(plutusList);
      }
      if (data instanceof Map) {
        const plutusMap = csl.PlutusMap.new();
        data.forEach((value, key) => {
          const plutusMapValue = csl.PlutusMapValues.new();
          plutusMapValue.add(toPlutusData(value));
          plutusMap.insert(toPlutusData(key), plutusMapValue);
        });
        return csl.PlutusData.new_map(plutusMap);
      }
      return csl.PlutusData.new_constr_plutus_data(
        csl.ConstrPlutusData.new(
          csl.BigNum.from_str(data.alternative.toString()),
          toPlutusList(data.fields)
        )
      );
  }
};
var castRawDataToJsonString = (rawData) => {
  if (typeof rawData === "object") {
    return JSONbig.stringify(rawData);
  }
  return rawData;
};
var castDataToPlutusData = ({
  type,
  content
}) => {
  if (type === "Mesh") {
    return toPlutusData(content);
  }
  if (type === "CBOR") {
    return csl.PlutusData.from_hex(content);
  }
  return csl.PlutusData.from_json(
    content,
    csl.PlutusDatumSchema.DetailedSchema
  );
};
var toNativeScript = (script) => {
  const toNativeScripts = (scripts) => {
    const nativeScripts = csl.NativeScripts.new();
    scripts.forEach((script2) => {
      nativeScripts.add(toNativeScript(script2));
    });
    return nativeScripts;
  };
  switch (script.type) {
    case "all":
      return csl.NativeScript.new_script_all(
        csl.ScriptAll.new(toNativeScripts(script.scripts))
      );
    case "any":
      return csl.NativeScript.new_script_any(
        csl.ScriptAny.new(toNativeScripts(script.scripts))
      );
    case "atLeast":
      return csl.NativeScript.new_script_n_of_k(
        csl.ScriptNOfK.new(script.required, toNativeScripts(script.scripts))
      );
    case "after":
      return csl.NativeScript.new_timelock_start(
        csl.TimelockStart.new_timelockstart(csl.BigNum.from_str(script.slot))
      );
    case "before":
      return csl.NativeScript.new_timelock_expiry(
        csl.TimelockExpiry.new_timelockexpiry(csl.BigNum.from_str(script.slot))
      );
    case "sig":
      return csl.NativeScript.new_script_pubkey(
        csl.ScriptPubkey.new(deserializeEd25519KeyHash(script.keyHash))
      );
  }
};

// src/deser/deserializer.ts
var deserializeAddress = (address) => csl.Address.from_bytes(toBytes(address));
var deserializeBip32PrivateKey = (bip32PrivateKey) => csl.Bip32PrivateKey.from_bytes(toBytes(bip32PrivateKey));
var deserializeDataHash = (dataHash) => csl.DataHash.from_bytes(toBytes(dataHash));
var deserializeEd25519KeyHash = (ed25519KeyHash) => csl.Ed25519KeyHash.from_bytes(toBytes(ed25519KeyHash));
var deserializeEd25519Signature = (ed25519Signature) => csl.Ed25519Signature.from_bytes(toBytes(ed25519Signature));
var deserializeNativeScript = (nativeScript) => csl.NativeScript.from_bytes(toBytes(nativeScript));
var deserializePublicKey = (publicKey) => csl.PublicKey.from_bytes(toBytes(publicKey));
var deserializePlutusData = (plutusData) => csl.PlutusData.from_bytes(toBytes(plutusData));
var deserializePlutusScript = (plutusScript, version) => csl.PlutusScript.from_hex_with_version(
  plutusScript,
  LANGUAGE_VERSIONS[version]
);
var deserializeScriptRef = (scriptRef) => csl.ScriptRef.from_bytes(toBytes(scriptRef));
var deserializeScriptHash = (scriptHash) => csl.ScriptHash.from_bytes(toBytes(scriptHash));
var deserializeTx = (tx) => csl.Transaction.from_bytes(toBytes(tx));
var deserializeTxBody = (txBody) => csl.TransactionBody.from_bytes(toBytes(txBody));
var deserializeTxHash = (txHash) => csl.TransactionHash.from_bytes(toBytes(txHash));
var deserializeTxUnspentOutput = (txUnspentOutput) => csl.TransactionUnspentOutput.from_bytes(toBytes(txUnspentOutput));
var deserializeTxWitnessSet = (txWitnessSet) => csl.TransactionWitnessSet.from_bytes(toBytes(txWitnessSet));
var deserializeValue = (value) => csl.Value.from_bytes(toBytes(value));

// src/deser/resolver.ts
import {
  mnemonicToEntropy
} from "@meshsdk/common";
var resolveStakeKeyHash = (bech322) => {
  try {
    const stakeKeyHash = [
      toBaseAddress(bech322)?.stake_cred().to_keyhash(),
      toRewardAddress(bech322)?.payment_cred().to_keyhash()
    ].find((kh) => kh !== void 0);
    if (stakeKeyHash !== void 0) return stakeKeyHash.to_hex();
    throw new Error(`Couldn't resolve stake key hash from address: ${bech322}`);
  } catch (error) {
    throw new Error(`An error occurred during resolveStakeKeyHash: ${error}.`);
  }
};
var resolvePrivateKey = (words) => {
  const buildBip32PrivateKey = (entropy2, password = "") => {
    return csl.Bip32PrivateKey.from_bip39_entropy(
      toBytes(entropy2),
      toBytes(fromUTF8(password))
    );
  };
  const entropy = mnemonicToEntropy(words.join(" "));
  const bip32PrivateKey = buildBip32PrivateKey(entropy);
  const bech32PrivateKey = bip32PrivateKey.to_bech32();
  bip32PrivateKey.free();
  return bech32PrivateKey;
};
var resolveNativeScriptAddress = (script, networkId = 0) => {
  const nativeScript = toNativeScript(script);
  const enterpriseAddress = csl.EnterpriseAddress.new(
    networkId,
    csl.Credential.from_scripthash(nativeScript.hash())
  );
  return enterpriseAddress.to_address().to_bech32();
};
var resolvePlutusScriptAddress = (script, networkId = 0) => {
  const plutusScript = deserializePlutusScript(script.code, script.version);
  const enterpriseAddress = csl.EnterpriseAddress.new(
    networkId,
    csl.Credential.from_scripthash(plutusScript.hash())
  );
  return enterpriseAddress.to_address().to_bech32();
};
var resolveNativeScriptHash = (script) => {
  return toNativeScript(script).hash().to_hex();
};
var resolveScriptHashDRepId = (scriptHash) => {
  return csl.DRep.new_script_hash(
    csl.ScriptHash.from_hex(scriptHash)
  ).to_bech32();
};
var resolveRewardAddress = (bech322) => {
  const buildRewardAddress = (networkId, stakeKeyHash) => {
    return csl.RewardAddress.new(
      networkId,
      csl.Credential.from_keyhash(stakeKeyHash)
    );
  };
  try {
    const address = toAddress(bech322);
    const baseAddress = toBaseAddress(bech322);
    const stakeKeyHash = baseAddress?.stake_cred().to_keyhash();
    if (stakeKeyHash !== void 0)
      return buildRewardAddress(address.network_id(), stakeKeyHash).to_address().to_bech32();
    throw new Error(`Couldn't resolve reward address from address: ${bech322}`);
  } catch (error) {
    throw new Error(`An error occurred during resolveRewardAddress: ${error}.`);
  }
};
var resolveDataHash = (data) => {
  const plutusData = toPlutusData(data);
  const dataHash = csl.hash_plutus_data(plutusData);
  return dataHash.to_hex();
};
var resolveNativeScriptHex = (script) => {
  return toNativeScript(script).to_hex();
};
var serializePoolId = (hash) => {
  return csl.Ed25519KeyHash.from_hex(hash).to_bech32("pool1");
};
var resolveScriptRef = (script) => {
  return toScriptRef(script).to_hex();
};
var resolveEd25519KeyHash = (bech322) => {
  return csl.Ed25519KeyHash.from_bech32(bech322).to_hex();
};

// src/utils/scripts.ts
var getV2ScriptHash = (script) => csl.get_v2_script_hash(script);

// src/utils/address.ts
var serialzeAddress = (deserializedAddress, networkId = 0) => {
  const {
    pubKeyHash,
    scriptHash,
    stakeCredentialHash,
    stakeScriptCredentialHash
  } = deserializedAddress;
  const isPaymentScript = !pubKeyHash;
  const isStakeScript = !stakeCredentialHash;
  const paymentHash = isPaymentScript ? scriptHash : pubKeyHash;
  const stakeHash = isStakeScript ? stakeScriptCredentialHash : stakeCredentialHash;
  if (!paymentHash)
    throw new Error(
      "Error: serializeAddress: Address must contain a payment part"
    );
  const addressObj = isPaymentScript ? scriptAddress(paymentHash, stakeHash, isStakeScript) : pubKeyAddress(paymentHash, stakeHash, isStakeScript);
  return serializeAddressObj(addressObj, networkId);
};
var addrBech32ToHex = (bech322) => {
  const hexAddress = csl.Address.from_bech32(bech322).to_hex();
  const cslAddress = csl.Address.from_hex(hexAddress);
  const hex = csl.PlutusData.from_address(cslAddress).to_hex();
  return hex;
};
var addrBech32ToObj = (bech322) => {
  const hexAddress = csl.Address.from_bech32(bech322).to_hex();
  const cslAddress = csl.Address.from_hex(hexAddress);
  const json = JSON.parse(csl.PlutusData.from_address(cslAddress).to_json(1));
  return json;
};
var serializeAddressObj = (plutusDataAddressObject, networkId = 0) => {
  const bech32Addr = csl.parse_plutus_address_obj_to_bech32(
    JSON.stringify(plutusDataAddressObject),
    networkId
  );
  return bech32Addr;
};
var serializePlutusAddressToBech32 = (plutusHex, networkId = 0) => {
  const cslPlutusDataAddress = csl.PlutusData.from_hex(plutusHex);
  const plutusDataAddressObject = JSON.parse(
    cslPlutusDataAddress.to_json(csl.PlutusDatumSchema.DetailedSchema)
  );
  return serializeAddressObj(plutusDataAddressObject, networkId);
};
var deserializeBech32Address = (bech32Addr) => {
  const deserializedAddress = csl.deserialize_bech32_address(bech32Addr);
  return {
    pubKeyHash: deserializedAddress.get_pub_key_hash(),
    scriptHash: deserializedAddress.get_script_hash(),
    stakeCredentialHash: deserializedAddress.get_stake_key_hash(),
    stakeScriptCredentialHash: deserializedAddress.get_stake_key_script_hash()
  };
};
var scriptHashToBech32 = (scriptHash, stakeCredentialHash, networkId = 0, isScriptStakeCredentialHash = false) => csl.wasm_script_to_address(
  networkId,
  scriptHash,
  stakeCredentialHash,
  isScriptStakeCredentialHash
);
var v2ScriptToBech32 = (scriptCbor, stakeCredential, networkId = 0, isScriptStakeCredential = false) => scriptHashToBech32(
  getV2ScriptHash(scriptCbor),
  stakeCredential,
  networkId,
  isScriptStakeCredential
);

// src/utils/datum.ts
var parseInlineDatum = (utxo) => {
  const datumCbor = utxo.inline_datum || "";
  const parsedDatum = csl.PlutusData.from_hex(datumCbor);
  const datum = JSON.parse(parsedDatum.to_json(1));
  return datum;
};
var parseDatumCbor = (datumCbor) => {
  const parsedDatum = csl.PlutusData.from_hex(datumCbor);
  const datum = JSON.parse(parsedDatum.to_json(1));
  return datum;
};

// src/utils/credentials.ts
var skeyToPubKeyHash = (skeyHex) => {
  const isHexUnclean = skeyHex.slice(0, 4) === "5820" && skeyHex.length === 68;
  const cleanHex = isHexUnclean ? skeyHex.slice(4) : skeyHex;
  return csl.PrivateKey.from_hex(cleanHex).to_public().hash().to_hex();
};

// src/utils/staking.ts
var poolIdHexToBech32 = (poolIdHash) => {
  const cslPoolIdHash = csl.Ed25519KeyHash.from_hex(poolIdHash);
  return cslPoolIdHash.to_bech32("pool");
};
var poolIdBech32ToHex = (poolIdBech32) => {
  const cslPoolIdHash = csl.Ed25519KeyHash.from_bech32(poolIdBech32);
  return Buffer.from(cslPoolIdHash.to_bytes()).toString("hex");
};
var baseAddressToStakeAddress = (baseAddressBech32, network = 1) => {
  const networkId = network === 1 ? csl.NetworkId.mainnet().kind() : csl.NetworkId.testnet().kind();
  const stakeCred = csl.BaseAddress.from_address(
    csl.Address.from_bech32(baseAddressBech32)
  )?.stake_cred();
  if (stakeCred) {
    const stakeAddress = csl.RewardAddress.new(networkId, stakeCred).to_address().to_bech32();
    return stakeAddress;
  }
  return "";
};
var rewardAddressToKeyHash = (rewardBech32) => {
  return toRewardAddress(rewardBech32)?.payment_cred().to_keyhash()?.to_hex();
};
var scriptHashToRewardAddress = (scriptHashHex, network = 1) => {
  const networkId = network === 1 ? csl.NetworkId.mainnet().kind() : csl.NetworkId.testnet().kind();
  const scriptHash = csl.ScriptHash.from_hex(scriptHashHex);
  const credential = csl.Credential.from_scripthash(scriptHash);
  const rewardAddress = csl.RewardAddress.new(networkId, credential).to_address().to_bech32();
  return rewardAddress;
};
var keyHashToRewardAddress = (keyHashHex, network = 1) => {
  const networkId = network === 1 ? csl.NetworkId.mainnet().kind() : csl.NetworkId.testnet().kind();
  const keyHash = csl.Ed25519KeyHash.from_hex(keyHashHex);
  const credential = csl.Credential.from_scripthash(keyHash);
  const rewardAddress = csl.RewardAddress.new(networkId, credential).to_address().to_bech32();
  return rewardAddress;
};

// src/wasm.ts
var parseWasmResult = (result) => {
  if (result.get_status() !== "success") {
    throw new Error(result.get_data());
  }
  return result.get_data();
};

// src/utils/transaction.ts
function isSuccessAction(action) {
  return action.success !== void 0;
}
function isErrorAction(action) {
  return action.error !== void 0;
}
var calculateTxHash = (txHex) => {
  const result = csl.js_calculate_tx_hash(txHex);
  return parseWasmResult(result);
};
var signTransaction = (txHex, signingKeys) => {
  const cslSigningKeys = csl.JsVecString.new();
  signingKeys.forEach((key) => {
    cslSigningKeys.add(key);
  });
  const result = csl.js_sign_transaction(txHex, cslSigningKeys);
  return parseWasmResult(result);
};
var evaluateTransaction = (txHex, resolvedUtxos, network) => {
  const additionalTxs = csl.JsVecString.new();
  const mappedUtxos = csl.JsVecString.new();
  for (const utxo of resolvedUtxos) {
    mappedUtxos.add(JSON.stringify(utxo));
  }
  const result = csl.evaluate_tx_scripts_js(
    txHex,
    mappedUtxos,
    additionalTxs,
    network
  );
  const unwrappedResult = parseWasmResult(result);
  const actions = JSON.parse(unwrappedResult);
  let parsedSuccessActions = [];
  let parsedErrorActions = [];
  actions.map((action) => {
    if (isSuccessAction(action)) {
      parsedSuccessActions.push(action.success);
    } else if (isErrorAction(action)) {
      parsedErrorActions.push(action.error);
    } else {
      throw new Error("Invalid action type found");
    }
  });
  if (parsedErrorActions.length > 0) {
    throw new Error(JSON.stringify(parsedErrorActions));
  }
  return parsedSuccessActions.map(mapAction);
};
var mapAction = (action) => {
  return {
    index: action.index,
    budget: mapBudget(action.budget),
    tag: mapRedeemerTag(action.tag)
  };
};
var mapBudget = (budget) => {
  return {
    mem: budget.mem,
    steps: budget.steps
  };
};
var mapRedeemerTag = (tag) => {
  switch (tag) {
    case "cert":
      return "CERT";
    case "mint":
      return "MINT";
    case "reward":
      return "REWARD";
    case "spend":
      return "SPEND";
    case "vote":
      return "VOTE";
    case "propose":
      return "PROPOSE";
    default:
      throw new Error(`Unknown RedeemerTag: ${tag}`);
  }
};
var getTransactionInputs = (txHex) => {
  const inputs = [];
  const deserializedTx = deserializeTx(txHex);
  const body = deserializedTx.body();
  const cslInputs = body.inputs();
  for (let i = 0; i < cslInputs.len(); i++) {
    const input = cslInputs.get(i);
    inputs.push({
      txHash: input.transaction_id().to_hex(),
      index: input.index()
    });
  }
  const cslCollaterals = body.collateral();
  if (cslCollaterals) {
    for (let i = 0; i < cslCollaterals.len(); i++) {
      const collateral = cslCollaterals.get(i);
      inputs.push({
        txHash: collateral.transaction_id().to_hex(),
        index: collateral.index()
      });
    }
  }
  const cslRefInputs = body.reference_inputs();
  if (cslRefInputs) {
    for (let i = 0; i < cslRefInputs.len(); i++) {
      const refInput = cslRefInputs.get(i);
      inputs.push({
        txHash: refInput.transaction_id().to_hex(),
        index: refInput.index()
      });
    }
  }
  return inputs;
};

// src/utils/aiken.ts
var applyParamsToScript = (rawScript, params, type = "Mesh") => {
  const cslParams = csl.JsVecString.new();
  let paramType = csl.BuilderDataType.CBOR;
  switch (type) {
    case "JSON":
      paramType = csl.BuilderDataType.JSON;
      params.forEach((param) => {
        if (typeof param === "object") {
          cslParams.add(JSON.stringify(param));
        } else if (typeof param === "string") {
          cslParams.add(param);
        }
      });
      break;
    case "Mesh":
      params.forEach((param) => {
        const paramCbor = toPlutusData(param);
        cslParams.add(paramCbor.to_hex());
      });
      break;
    default:
      params.forEach((param) => {
        cslParams.add(param);
      });
      break;
  }
  return csl.js_apply_params_to_script(rawScript, cslParams, paramType);
};
var applyCborEncoding = (rawScript) => {
  return csl.js_apply_params_to_script(
    rawScript,
    csl.JsVecString.new(),
    csl.BuilderDataType.CBOR
  );
};

// src/utils/drep.ts
import base32 from "base32-encoding";
import { bech32 } from "bech32";
var getDRepIds = (dRepId) => {
  let result = {
    cip105: "",
    cip129: ""
  };
  if (dRepId.length === 58) {
    result.cip129 = dRepId;
    const { prefix, words } = bech32.decode(dRepId);
    if (prefix !== "drep") {
      throw new Error("Malformed CIP129 DRepId");
    }
    const bytes = base32.decode(new Uint8Array(words));
    if (bytes[0] === 34) {
      result.cip105 = csl.DRep.new_key_hash(
        csl.Ed25519KeyHash.from_hex(bytes.subarray(1).toString("hex"))
      ).to_bech32();
    } else if (bytes[0] === 35) {
      result.cip105 = csl.DRep.new_script_hash(
        csl.ScriptHash.from_hex(bytes.subarray(1).toString("hex"))
      ).to_bech32();
    } else {
      throw new Error("Malformed CIP129 DRepId");
    }
  } else {
    result.cip105 = dRepId;
    try {
      const cslDRep = csl.DRep.from_bech32(dRepId);
      if (cslDRep.kind() === csl.DRepKind.KeyHash) {
        let rawBytes = cslDRep.to_key_hash()?.to_bytes();
        if (!rawBytes) {
          throw new Error("Malformed key hash in DRepId");
        }
        let rawBytesWithPrefix = new Uint8Array(rawBytes.length + 1);
        rawBytesWithPrefix.set([34]);
        rawBytesWithPrefix.set(rawBytes, 1);
        let base32RawBytes = base32.encode(rawBytesWithPrefix);
        result.cip129 = bech32.encode("drep", base32RawBytes);
      } else if (cslDRep.kind() === csl.DRepKind.ScriptHash) {
        let rawBytes = cslDRep.to_script_hash()?.to_bytes();
        if (!rawBytes) {
          throw new Error("Malformed script hash in DRepId");
        }
        let rawBytesWithPrefix = new Uint8Array(rawBytes.length + 1);
        rawBytesWithPrefix.set([35]);
        rawBytesWithPrefix.set(rawBytes, 1);
        let base32RawBytes = base32.encode(rawBytesWithPrefix);
        result.cip129 = bech32.encode("drep", base32RawBytes);
      } else {
        throw new Error("Can only calculate DRepIds for script/key DReps");
      }
    } catch (e) {
      console.error(e);
      throw new Error("Malformed DRepId");
    }
  }
  return result;
};

// src/core/serializer.ts
import JSONbig3 from "json-bigint";
import {
  DEFAULT_PROTOCOL_PARAMETERS,
  emptyTxBuilderBody
} from "@meshsdk/common";

// src/core/adaptor/index.ts
import { validityRangeToObj } from "@meshsdk/common";

// src/core/adaptor/data.ts
var builderDataToCbor = ({ type, content }) => {
  if (type === "Mesh") {
    return toPlutusData(content).to_hex();
  }
  if (type === "CBOR") {
    return csl.PlutusData.from_hex(content).to_hex();
  }
  return csl.PlutusData.from_json(
    content,
    csl.PlutusDatumSchema.DetailedSchema
  ).to_hex();
};
var redeemerToObj = (redeemer) => {
  return {
    data: builderDataToCbor(redeemer.data),
    exUnits: redeemer.exUnits
  };
};

// src/core/adaptor/script.ts
var scriptSourceToObj = (scriptSource) => {
  if (scriptSource.type === "Provided") {
    return {
      providedScriptSource: {
        scriptCbor: scriptSource.script.code,
        languageVersion: scriptSource.script.version.toLocaleLowerCase()
      }
    };
  }
  return {
    inlineScriptSource: {
      refTxIn: {
        txHash: scriptSource.txHash,
        txIndex: scriptSource.txIndex
      },
      scriptHash: scriptSource.scriptHash ?? "",
      languageVersion: scriptSource.version.toLocaleLowerCase(),
      scriptSize: BigInt(scriptSource.scriptSize ?? "0")
    }
  };
};
var simpleScriptSourceToObj = (scriptSource) => {
  if (scriptSource.type === "Provided") {
    return {
      providedSimpleScriptSource: {
        scriptCbor: scriptSource.scriptCode
      }
    };
  }
  return {
    inlineSimpleScriptSource: {
      refTxIn: {
        txHash: scriptSource.txHash,
        txIndex: scriptSource.txIndex
      },
      simpleScriptHash: scriptSource.simpleScriptHash ?? ""
    }
  };
};

// src/core/adaptor/certificate.ts
var certificateToObj = (certificate) => {
  const baseCert = certificate.certType;
  switch (certificate.type) {
    case "BasicCertificate":
      return {
        basicCertificate: baseCertToObj(baseCert)
      };
    case "ScriptCertificate":
      return {
        scriptCertificate: {
          cert: baseCertToObj(baseCert),
          redeemer: certificate.redeemer ? redeemerToObj(certificate.redeemer) : null,
          scriptSource: certificate.scriptSource ? scriptSourceToObj(certificate.scriptSource) : null
        }
      };
    case "SimpleScriptCertificate":
      return {
        simpleScriptCertificate: {
          cert: baseCertToObj(baseCert),
          simpleScriptSource: certificate.simpleScriptSource ? simpleScriptSourceToObj(certificate.simpleScriptSource) : null
        }
      };
  }
};
var baseCertToObj = (baseCert) => {
  switch (baseCert.type) {
    case "RegisterPool":
      return {
        registerPool: {
          poolParams: poolParamsToObj(baseCert.poolParams)
        }
      };
    case "RegisterStake":
      return {
        registerStake: {
          stakeKeyAddress: baseCert.stakeKeyAddress,
          coin: 2e6
          // TODO: change in conway era (this should become an argument)
        }
      };
    case "DelegateStake":
      return {
        delegateStake: {
          stakeKeyAddress: baseCert.stakeKeyAddress,
          poolId: baseCert.poolId
        }
      };
    case "DeregisterStake":
      return {
        deregisterStake: {
          stakeKeyAddress: baseCert.stakeKeyAddress
        }
      };
    case "RetirePool":
      return {
        retirePool: {
          poolId: baseCert.poolId,
          epoch: baseCert.epoch
        }
      };
    case "VoteDelegation":
      return {
        voteDelegation: {
          stakeKeyAddress: baseCert.stakeKeyAddress,
          drep: baseCert.drep
        }
      };
    case "StakeAndVoteDelegation":
      return {
        stakeAndVoteDelegation: {
          stakeKeyAddress: baseCert.stakeKeyAddress,
          poolKeyHash: baseCert.poolKeyHash,
          drep: baseCert.drep
        }
      };
    case "StakeRegistrationAndDelegation":
      return {
        stakeRegistrationAndDelegation: {
          stakeKeyAddress: baseCert.stakeKeyAddress,
          poolKeyHash: baseCert.poolKeyHash,
          coin: baseCert.coin
        }
      };
    case "VoteRegistrationAndDelegation":
      return {
        voteRegistrationAndDelegation: {
          stakeKeyAddress: baseCert.stakeKeyAddress,
          drep: baseCert.drep,
          coin: baseCert.coin
        }
      };
    case "StakeVoteRegistrationAndDelegation":
      return {
        stakeVoteRegistrationAndDelegation: {
          stakeKeyAddress: baseCert.stakeKeyAddress,
          poolKeyHash: baseCert.poolKeyHash,
          drep: baseCert.drep,
          coin: baseCert.coin
        }
      };
    case "CommitteeHotAuth":
      return {
        committeeHotAuth: {
          committeeColdKeyAddress: baseCert.committeeColdKeyAddress,
          committeeHotKeyAddress: baseCert.committeeHotKeyAddress
        }
      };
    case "CommitteeColdResign":
      return {
        committeeColdResign: {
          committeeColdKeyAddress: baseCert.committeeColdKeyAddress,
          anchor: baseCert.anchor ?? null
        }
      };
    case "DRepRegistration":
      return {
        dRepRegistration: {
          drepId: baseCert.drepId,
          coin: baseCert.coin,
          anchor: baseCert.anchor ?? null
        }
      };
    case "DRepDeregistration":
      return {
        dRepDeregistration: {
          drepId: baseCert.drepId,
          coin: baseCert.coin
        }
      };
    case "DRepUpdate":
      return {
        dRepUpdate: {
          drepId: baseCert.drepId,
          anchor: baseCert.anchor
        }
      };
  }
};
var poolParamsToObj = (poolParams) => {
  return {
    vrfKeyHash: poolParams.vrfKeyHash,
    operator: poolParams.operator,
    pledge: poolParams.pledge,
    cost: poolParams.cost,
    margin: poolParams.margin,
    relays: poolParams.relays.map((relay) => relayToObj(relay)),
    owners: poolParams.owners,
    rewardAddress: poolParams.rewardAddress,
    metadata: poolParams.metadata ? poolMetadataToObj(poolParams.metadata) : void 0
  };
};
var poolMetadataToObj = (poolMetadata) => {
  return {
    url: poolMetadata.URL,
    metadata: poolMetadata.hash
  };
};
var relayToObj = (relay) => {
  switch (relay.type) {
    case "SingleHostAddr":
      return {
        singleHostAddr: {
          ipv4: relay.IPV4,
          ipv6: relay.IPV6,
          port: relay.port
        }
      };
    case "SingleHostName":
      return {
        singleHostName: {
          hostname: relay.domainName,
          port: relay.port
        }
      };
    case "MultiHostName":
      return {
        multiHostName: {
          dnsName: relay.domainName
        }
      };
  }
};

// src/core/adaptor/mint.ts
var mintItemToObj = (mintItem) => {
  switch (mintItem.type) {
    case "Plutus":
      return {
        scriptMint: plutusMintItemToObj(mintItem)
      };
    case "Native":
      return {
        simpleScriptMint: nativeMintItemToObj(
          mintItem
        )
      };
  }
};
var plutusMintItemToObj = (mintItem) => {
  let scriptSource = scriptSourceToObj(
    mintItem.scriptSource
  );
  return {
    mint: mintParametersObj(mintItem),
    redeemer: mintItem.redeemer ? redeemerToObj(mintItem.redeemer) : null,
    scriptSource
  };
};
var nativeMintItemToObj = (mintItem) => {
  return {
    mint: mintParametersObj(mintItem),
    scriptSource: simpleScriptSourceToObj(
      mintItem.scriptSource
    )
  };
};
var mintParametersObj = (mintItem) => {
  return {
    policyId: mintItem.policyId,
    assetName: mintItem.assetName,
    amount: BigInt(mintItem.amount)
  };
};

// src/core/adaptor/network.ts
var networkToObj = (network) => {
  if (typeof network === "string") {
    return network;
  } else {
    return {
      custom: network
    };
  }
};

// src/core/adaptor/output.ts
var outputToObj = (output) => {
  let datum = null;
  if (output.datum) {
    switch (output.datum.type) {
      case "Inline":
        datum = { inline: builderDataToCbor(output.datum.data) };
        break;
      case "Hash":
        datum = { hash: builderDataToCbor(output.datum.data) };
        break;
      case "Embedded":
        datum = { embedded: builderDataToCbor(output.datum.data) };
        break;
    }
  }
  const refScript = output.referenceScript;
  return {
    address: output.address,
    amount: output.amount,
    datum,
    referenceScript: output.referenceScript ? {
      providedScriptSource: {
        scriptCbor: refScript.code,
        languageVersion: refScript.version.toLocaleLowerCase()
      }
    } : null
  };
};

// src/core/adaptor/metadata.ts
import JSONbig2 from "json-bigint";
var txMetadataToObj = (metadata) => {
  const result = [];
  metadata.forEach((value, key) => {
    result.push({
      tag: key.toString(),
      metadata: JSONbig2.stringify(metadatumToObj(value))
    });
  });
  return result;
};
var metadatumToObj = (metadatum) => {
  if (typeof metadatum === "number" || typeof metadatum === "string") {
    return metadatum;
  } else if (typeof metadatum === "bigint") {
    return metadatum.toString();
  } else if (metadatum instanceof Uint8Array) {
    return uint8ArrayToHex(metadatum);
  } else if (metadatum instanceof Map) {
    const result = {};
    metadatum.forEach((value, key) => {
      result[metadatumToObj(key)] = metadatumToObj(value);
    });
    return result;
  } else if (Array.isArray(metadatum)) {
    return metadatum.map(metadatumToObj);
  } else {
    throw new Error("metadatumToObj: Unsupported Metadatum type");
  }
};
var uint8ArrayToHex = (bytes) => {
  return Array.from(bytes).map((byte) => byte.toString(16).padStart(2, "0")).join("");
};

// src/core/adaptor/txIn.ts
var txInToObj = (txIn) => {
  switch (txIn.type) {
    case "PubKey":
      return {
        pubKeyTxIn: {
          txIn: txInParameterToObj(txIn.txIn)
        }
      };
    case "Script":
      return {
        scriptTxIn: {
          txIn: txInParameterToObj(txIn.txIn),
          scriptTxIn: scriptTxInParameterToObj(txIn.scriptTxIn)
        }
      };
    case "SimpleScript":
      return {
        simpleScriptTxIn: {
          txIn: txInParameterToObj(txIn.txIn),
          simpleScriptTxIn: simpleScriptTxInParameterToObj(
            txIn.simpleScriptTxIn
          )
        }
      };
  }
};
var collateralTxInToObj = (txIn) => {
  return {
    txIn: txInParameterToObj(txIn.txIn)
  };
};
var txInParameterToObj = (txInParameter) => {
  return {
    txHash: txInParameter.txHash,
    txIndex: txInParameter.txIndex,
    amount: txInParameter.amount ?? null,
    address: txInParameter.address ?? null
  };
};
var scriptTxInParameterToObj = (scriptTxInParameter) => {
  let scriptSource = null;
  let datumSource = null;
  if (scriptTxInParameter.scriptSource) {
    scriptSource = scriptSourceToObj(scriptTxInParameter.scriptSource);
  }
  if (scriptTxInParameter.datumSource) {
    switch (scriptTxInParameter.datumSource.type) {
      case "Provided":
        datumSource = {
          providedDatumSource: {
            data: builderDataToCbor(scriptTxInParameter.datumSource.data)
          }
        };
        break;
      case "Inline":
        datumSource = {
          inlineDatumSource: {
            txHash: scriptTxInParameter.datumSource.txHash,
            txIndex: scriptTxInParameter.datumSource.txIndex
          }
        };
        break;
    }
  }
  return {
    scriptSource,
    datumSource,
    redeemer: scriptTxInParameter.redeemer ? redeemerToObj(scriptTxInParameter.redeemer) : null
  };
};
var simpleScriptTxInParameterToObj = (simpleScriptTxInParameter) => {
  if (simpleScriptTxInParameter.scriptSource) {
    let scriptSource = null;
    switch (simpleScriptTxInParameter.scriptSource.type) {
      case "Inline":
        scriptSource = {
          inlineSimpleScriptSource: {
            refTxIn: {
              txHash: simpleScriptTxInParameter.scriptSource.txHash,
              txIndex: simpleScriptTxInParameter.scriptSource.txIndex
            },
            simpleScriptHash: simpleScriptTxInParameter.scriptSource.simpleScriptHash ?? "",
            scriptSize: BigInt(
              simpleScriptTxInParameter.scriptSource.scriptSize ?? "0"
            )
          }
        };
        break;
      case "Provided":
        scriptSource = {
          providedSimpleScriptSource: {
            scriptCbor: simpleScriptTxInParameter.scriptSource.scriptCode
          }
        };
        break;
    }
    return scriptSource;
  }
};

// src/core/adaptor/vote.ts
var voteToObj = (vote) => {
  if (vote.type === "BasicVote") {
    return {
      basicVote: voteTypeToObj(vote.vote)
    };
  } else if (vote.type === "ScriptVote") {
    if (!vote.scriptSource) {
      throw new Error("voteToObj: missing scriptSource in plutusScriptVote.");
    }
    if (!vote.redeemer) {
      throw new Error("voteToObj: missing redeemer in plutusScriptVote.");
    }
    return {
      scriptVote: {
        vote: voteTypeToObj(vote.vote),
        redeemer: redeemerToObj(vote.redeemer),
        scriptSource: scriptSourceToObj(vote.scriptSource)
      }
    };
  } else {
    if (!vote.simpleScriptSource) {
      throw new Error("voteToObj: missing script source in simpleScriptVote");
    }
    return {
      simpleScriptVote: {
        vote: voteTypeToObj(vote.vote),
        simpleScriptSource: simpleScriptSourceToObj(vote.simpleScriptSource)
      }
    };
  }
};
var voteTypeToObj = (voteType) => {
  let voter = {};
  switch (voteType.voter.type) {
    case "ConstitutionalCommittee": {
      let ccCred = {};
      switch (voteType.voter.hotCred.type) {
        case "ScriptHash": {
          ccCred = {
            scriptHash: voteType.voter.hotCred.scriptHash
          };
          break;
        }
        case "KeyHash": {
          ccCred = {
            keyHash: voteType.voter.hotCred.keyHash
          };
          break;
        }
      }
      voter = {
        constitutionalCommitteeHotCred: ccCred
      };
      break;
    }
    case "DRep": {
      voter = {
        dRepId: voteType.voter.drepId
      };
      break;
    }
    case "StakingPool": {
      voter = {
        stakingPoolKeyHash: voteType.voter.keyHash
      };
      break;
    }
  }
  let votingProcedure = {};
  switch (voteType.votingProcedure.voteKind) {
    case "Yes": {
      votingProcedure = {
        voteKind: "yes",
        anchor: voteType.votingProcedure.anchor ?? null
      };
      break;
    }
    case "No": {
      votingProcedure = {
        voteKind: "no",
        anchor: voteType.votingProcedure.anchor ?? null
      };
      break;
    }
    case "Abstain": {
      votingProcedure = {
        voteKind: "abstain",
        anchor: voteType.votingProcedure.anchor ?? null
      };
      break;
    }
  }
  return {
    voter,
    votingProcedure,
    govActionId: voteType.govActionId
  };
};

// src/core/adaptor/withdrawal.ts
var withdrawalToObj = (withdrawal) => {
  if (withdrawal.type === "PubKeyWithdrawal") {
    return {
      pubKeyWithdrawal: {
        address: withdrawal.address,
        coin: BigInt(withdrawal.coin)
      }
    };
  } else if (withdrawal.type === "ScriptWithdrawal") {
    if (!withdrawal.scriptSource) {
      throw new Error(
        "withdrawalToObj: missing scriptSource in plutusScriptWithdrawal."
      );
    }
    if (!withdrawal.redeemer) {
      throw new Error(
        "withdrawalToObj: missing redeemer in plutusScriptWithdrawal."
      );
    }
    return {
      plutusScriptWithdrawal: {
        address: withdrawal.address,
        coin: BigInt(withdrawal.coin),
        scriptSource: scriptSourceToObj(withdrawal.scriptSource),
        redeemer: redeemerToObj(withdrawal.redeemer)
      }
    };
  } else {
    if (!withdrawal.scriptSource) {
      throw new Error(
        "withdrawalToObj: missing script source in simpleScriptWithdrawal"
      );
    }
    return {
      simpleScriptWithdrawal: {
        address: withdrawal.address,
        coin: BigInt(withdrawal.coin),
        scriptSource: simpleScriptSourceToObj(withdrawal.scriptSource)
      }
    };
  }
};

// src/core/adaptor/utxo.ts
var utxoToObj = ({
  input: { outputIndex, txHash },
  output: { address, amount, dataHash, plutusData, scriptRef, scriptHash }
}) => {
  return {
    input: {
      outputIndex,
      txHash
    },
    output: {
      address,
      amount,
      dataHash: dataHash ?? null,
      plutusData: plutusData ?? null,
      scriptRef: scriptRef ?? null,
      scriptHash: scriptHash ?? null
    }
  };
};

// src/core/adaptor/index.ts
var meshTxBuilderBodyToObj = ({
  inputs,
  outputs,
  collaterals,
  requiredSignatures,
  referenceInputs,
  mints,
  changeAddress,
  metadata,
  validityRange,
  certificates,
  signingKey,
  withdrawals,
  votes,
  fee,
  network
}) => {
  return {
    inputs: inputs.map(txInToObj),
    outputs: outputs.map(outputToObj),
    collaterals: collaterals.map(collateralTxInToObj),
    requiredSignatures,
    referenceInputs,
    mints: mints.map((mint) => mintItemToObj(mint)),
    changeAddress,
    metadata: txMetadataToObj(metadata),
    validityRange: validityRangeToObj(validityRange),
    certificates: certificates.map(certificateToObj),
    signingKey,
    withdrawals: withdrawals.map(withdrawalToObj),
    votes: votes.map(voteToObj),
    fee,
    network: networkToObj(network)
  };
};

// src/core/serializer.ts
var CSLSerializer = class {
  /**
   * Set to true to enable verbose logging for the txBodyJson prior going into build
   */
  verbose;
  protocolParams;
  meshTxBuilderBody = emptyTxBuilderBody();
  constructor(protocolParams, verbose = false) {
    this.protocolParams = protocolParams || DEFAULT_PROTOCOL_PARAMETERS;
    this.verbose = verbose;
  }
  serializeTxBody(txBody, protocolParams) {
    const txBodyJson = JSONbig3.stringify(meshTxBuilderBodyToObj(txBody));
    const params = JSONbig3.stringify(protocolParams || this.protocolParams);
    if (this.verbose) {
      console.log("txBodyJson", txBodyJson);
    }
    const txBuildResult = csl.js_serialize_tx_body(txBodyJson, params);
    if (txBuildResult.get_status() !== "success") {
      throw new Error(`txBuildResult error: ${txBuildResult.get_error()}`);
    }
    return txBuildResult.get_data();
  }
  addSigningKeys(txHex, signingKeys) {
    if (signingKeys.length > 0) {
      return signTransaction(txHex, signingKeys);
    }
    return txHex;
  }
  serializeData(data) {
    return builderDataToCbor(data);
  }
  serializeAddress(address, networkId) {
    return serialzeAddress(address, networkId);
  }
  serializePoolId(hash) {
    return serializePoolId(hash);
  }
  serializeRewardAddress(stakeKeyHash, isScriptHash, network_id) {
    return isScriptHash ? scriptHashToRewardAddress(stakeKeyHash, network_id) : keyHashToRewardAddress(stakeKeyHash, network_id);
  }
  deserializer = {
    key: {
      deserializeAddress: function(bech322) {
        return deserializeBech32Address(bech322);
      }
    },
    script: {
      deserializeNativeScript: function(script) {
        const nativeScript = toNativeScript(script);
        const scriptCbor = nativeScript.to_hex();
        const scriptHash = nativeScript.hash().to_hex();
        return {
          scriptHash,
          scriptCbor
        };
      },
      deserializePlutusScript: function(script) {
        const scriptHash = deserializePlutusScript(script.code, script.version).hash().to_hex();
        return { scriptHash, scriptCbor: script.code };
      }
    },
    cert: {
      deserializePoolId: function(poolId) {
        return resolveEd25519KeyHash(poolId);
      }
    }
  };
  resolver = {
    keys: {
      resolveStakeKeyHash: function(bech322) {
        return rewardAddressToKeyHash(bech322) || deserializeBech32Address(bech322).stakeCredentialHash;
      },
      resolvePrivateKey: function(words) {
        return resolvePrivateKey(words);
      },
      resolveRewardAddress: function(bech322) {
        return resolveRewardAddress(bech322);
      },
      resolveEd25519KeyHash: function(bech322) {
        return resolveEd25519KeyHash(bech322);
      }
    },
    tx: {
      resolveTxHash: function(txHex) {
        return calculateTxHash(txHex);
      }
    },
    data: {
      resolveDataHash: function(data) {
        return resolveDataHash(data);
      }
    },
    script: {
      resolveScriptRef: function(script) {
        return resolveScriptRef(script);
      }
    }
  };
};

// src/offline-providers/offline-evaluator.ts
var OfflineEvaluator = class {
  fetcher;
  network;
  /**
   * Creates a new instance of OfflineEvaluator.
   * @param fetcher - An implementation of IFetcher to resolve transaction UTXOs
   * @param network - The network to evaluate scripts for
   */
  constructor(fetcher, network) {
    this.fetcher = fetcher;
    this.network = network;
  }
  /**
   * Evaluates Plutus scripts in a transaction by resolving its input UTXOs and calculating execution costs.
   *
   * The method performs these steps:
   * 1. Extracts input references from the transaction
   * 2. Resolves the corresponding UTXOs using the fetcher
   * 3. Verifies all required UTXOs are available
   * 4. Evaluates each Plutus script to determine its memory and CPU costs
   *
   * @param tx - Transaction in CBOR hex format
   * @returns Promise resolving to array of script evaluation results, each containing:
   *   - tag: Type of script (CERT | MINT | REWARD | SPEND | VOTE | PROPOSE)
   *   - index: Script execution index
   *   - budget: Memory units and CPU steps required
   * @throws Error if any required UTXOs cannot be resolved or if script evaluation fails
   */
  async evaluateTx(tx) {
    const inputsToResolve = getTransactionInputs(tx);
    const txHashesSet = new Set(inputsToResolve.map((input) => input.txHash));
    const resolvedUTXOs = [];
    for (const txHash of txHashesSet) {
      const utxos = await this.fetcher.fetchUTxOs(txHash);
      for (const utxo of utxos) {
        if (utxo) {
          if (inputsToResolve.find((input) => input.txHash === txHash && input.index === utxo.input.outputIndex)) {
            resolvedUTXOs.push(utxo);
          }
        }
      }
    }
    if (resolvedUTXOs.length !== inputsToResolve.length) {
      const missing = inputsToResolve.filter((input) => !resolvedUTXOs.find((utxo) => utxo.input.txHash === input.txHash && utxo.input.outputIndex === input.index));
      const missingList = missing.map((m) => `${m.txHash}:${m.index}`).join(", ");
      throw new Error(`Can't resolve these UTXOs to execute plutus scripts: ${missingList}`);
    }
    return evaluateTransaction(tx, resolvedUTXOs, this.network);
  }
};
export {
  CSLSerializer,
  LANGUAGE_VERSIONS,
  OfflineEvaluator,
  POLICY_ID_LENGTH,
  REDEEMER_TAGS,
  addrBech32ToHex,
  addrBech32ToObj,
  applyCborEncoding,
  applyParamsToScript,
  baseAddressToStakeAddress,
  baseCertToObj,
  builderDataToCbor,
  calculateTxHash,
  castDataToPlutusData,
  castRawDataToJsonString,
  certificateToObj,
  collateralTxInToObj,
  csl,
  deserializeAddress,
  deserializeBech32Address,
  deserializeBip32PrivateKey,
  deserializeDataHash,
  deserializeEd25519KeyHash,
  deserializeEd25519Signature,
  deserializeNativeScript,
  deserializePlutusData,
  deserializePlutusScript,
  deserializePublicKey,
  deserializeScriptHash,
  deserializeScriptRef,
  deserializeTx,
  deserializeTxBody,
  deserializeTxHash,
  deserializeTxUnspentOutput,
  deserializeTxWitnessSet,
  deserializeValue,
  evaluateTransaction,
  fromBytes,
  fromLovelace,
  fromUTF8,
  getDRepIds,
  getTransactionInputs,
  getV2ScriptHash,
  keyHashToRewardAddress,
  meshTxBuilderBodyToObj,
  mintItemToObj,
  mintParametersObj,
  nativeMintItemToObj,
  outputToObj,
  parseDatumCbor,
  parseInlineDatum,
  plutusMintItemToObj,
  poolIdBech32ToHex,
  poolIdHexToBech32,
  poolMetadataToObj,
  poolParamsToObj,
  redeemerToObj,
  relayToObj,
  resolveDataHash,
  resolveEd25519KeyHash,
  resolveNativeScriptAddress,
  resolveNativeScriptHash,
  resolveNativeScriptHex,
  resolvePlutusScriptAddress,
  resolvePrivateKey,
  resolveRewardAddress,
  resolveScriptHashDRepId,
  resolveScriptRef,
  resolveStakeKeyHash,
  rewardAddressToKeyHash,
  scriptHashToBech32,
  scriptHashToRewardAddress,
  scriptSourceToObj,
  scriptTxInParameterToObj,
  serializeAddressObj,
  serializePlutusAddressToBech32,
  serializePoolId,
  serialzeAddress,
  signTransaction,
  simpleScriptSourceToObj,
  simpleScriptTxInParameterToObj,
  skeyToPubKeyHash,
  toAddress,
  toBaseAddress,
  toBytes,
  toEnterpriseAddress,
  toLovelace,
  toNativeScript,
  toPlutusData,
  toRewardAddress,
  toScriptRef,
  toUTF8,
  txInParameterToObj,
  txInToObj,
  utxoToObj,
  v2ScriptToBech32,
  withdrawalToObj
};
