"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.eqUPLCTerm = exports.getUPLCVarRefsInTerm = exports.hasMultipleRefsInTerm = exports.hasAnyRefsInTerm = exports.prettyUPLC = exports.showUPLC = exports.showConstType = exports.showUPLCConstValue = exports.isClosedTerm = exports.isPureUPLCTerm = exports.isUPLCTerm = void 0;
var UPLCVar_1 = require("../UPLCTerms/UPLCVar/index.js");
var Delay_1 = require("../UPLCTerms/Delay.js");
var Lambda_1 = require("../UPLCTerms/Lambda.js");
var Application_1 = require("../UPLCTerms/Application.js");
var UPLCConst_1 = require("../UPLCTerms/UPLCConst/UPLCConst.js");
var Force_1 = require("../UPLCTerms/Force.js");
var ErrorUPLC_1 = require("../UPLCTerms/ErrorUPLC.js");
var Builtin_1 = require("../UPLCTerms/Builtin/Builtin.js");
var ConstType_1 = require("../UPLCTerms/UPLCConst/ConstType/index.js");
var UPLCBuiltinTag_1 = require("../UPLCTerms/Builtin/UPLCBuiltinTag.js");
var ConstValue_1 = require("../UPLCTerms/UPLCConst/ConstValue/index.js");
var bytestring_1 = require("@harmoniclabs/bytestring");
var pair_1 = require("@harmoniclabs/pair");
var plutus_data_1 = require("@harmoniclabs/plutus-data");
var assert_1 = require("../utils/assert.js");
var Constr_1 = require("../UPLCTerms/Constr.js");
var Case_1 = require("../UPLCTerms/Case.js");
var crypto_1 = require("@harmoniclabs/crypto");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
/**
 * **_O(1)_**
 * @param {UPLCTerm} t ```UPLCTerm``` to check
 * @returns {boolean} ```true``` if the argument is instance of any of the ```UPLCTerm``` constructors, ```false``` otherwise
 */
function isUPLCTerm(t) {
    // only strict instances
    return (t instanceof UPLCVar_1.UPLCVar ||
        t instanceof Delay_1.Delay ||
        t instanceof Lambda_1.Lambda ||
        t instanceof Application_1.Application ||
        t instanceof UPLCConst_1.UPLCConst ||
        t instanceof Force_1.Force ||
        t instanceof ErrorUPLC_1.ErrorUPLC ||
        t instanceof Builtin_1.Builtin ||
        t instanceof Constr_1.Constr ||
        t instanceof Case_1.Case);
}
exports.isUPLCTerm = isUPLCTerm;
/**
 * **_O(n)_**
 * @param {UPLCTerm} t ```UPLCTerm``` to check
 * @returns {boolean} ```true``` if the AST contains only plutus-core terms, ```false``` otherwise
 */
function isPureUPLCTerm(t) {
    if (!isUPLCTerm(t))
        return false;
    if (t instanceof UPLCVar_1.UPLCVar)
        return true;
    if (t instanceof Delay_1.Delay)
        return isPureUPLCTerm(t.delayedTerm);
    if (t instanceof Lambda_1.Lambda)
        return isPureUPLCTerm(t.body);
    if (t instanceof Application_1.Application)
        return (isPureUPLCTerm(t.argTerm) && isPureUPLCTerm(t.funcTerm));
    if (t instanceof UPLCConst_1.UPLCConst)
        return true;
    if (t instanceof Force_1.Force)
        return isPureUPLCTerm(t.termToForce);
    if (t instanceof ErrorUPLC_1.ErrorUPLC)
        return true;
    if (t instanceof Builtin_1.Builtin)
        return true;
    if (t instanceof Constr_1.Constr)
        return t.terms.every(isPureUPLCTerm);
    if (t instanceof Case_1.Case)
        return isPureUPLCTerm(t.constrTerm) && t.continuations.every(isPureUPLCTerm);
    return false;
}
exports.isPureUPLCTerm = isPureUPLCTerm;
function _isClosedTerm(maxDeBruijn, t) {
    (0, assert_1.assert)(isUPLCTerm(t), "'isClosedTerm' functions only works on **raw** UPLCTerms");
    if (t instanceof UPLCVar_1.UPLCVar)
        // deBruijn variables are 0 indexed (as arrays)
        return maxDeBruijn > t.deBruijn;
    else if (t instanceof Delay_1.Delay)
        return _isClosedTerm(maxDeBruijn, t.delayedTerm);
    else if (t instanceof Lambda_1.Lambda)
        // increment max debruijn
        return _isClosedTerm(maxDeBruijn + BigInt(1), t.body);
    else if (t instanceof Application_1.Application)
        return _isClosedTerm(maxDeBruijn, t.funcTerm) && _isClosedTerm(maxDeBruijn, t.argTerm);
    else if (t instanceof UPLCConst_1.UPLCConst)
        // `UPLCConst` has no variables in it, ence always closed
        return true;
    else if (t instanceof Force_1.Force)
        return _isClosedTerm(maxDeBruijn, t.termToForce);
    else if (t instanceof ErrorUPLC_1.ErrorUPLC)
        // `ErrorUPLC` has no variables in it, ence always closed
        return true;
    else if (t instanceof Builtin_1.Builtin)
        // builtin per-se is just the function (ence a valid value),
        // arguments are passed using the `Apply` Term
        // so it is the `t instanceof Apply` case job
        // to be sure the arguments are closed
        return true;
    else if (t instanceof Constr_1.Constr)
        return t.terms.every(function (term) { return _isClosedTerm(maxDeBruijn, term); });
    else if (t instanceof Case_1.Case)
        return (_isClosedTerm(maxDeBruijn, t.constrTerm) &&
            t.continuations.every(function (term) { return _isClosedTerm(maxDeBruijn, term); }));
    else
        throw new Error("unexpected execution flow in 'isClodeTerm'; all possibilieties should have already been handled; input term is: " + t.toString());
}
function isClosedTerm(term) {
    return _isClosedTerm(BigInt(0), term);
}
exports.isClosedTerm = isClosedTerm;
function showUPLCConstValue(v) {
    if (v === undefined)
        return "()";
    if ((0, ConstValue_1.isConstValueInt)(v))
        return v.toString();
    if (typeof v === "string")
        return "\"".concat(v, "\"");
    if (typeof v === "boolean")
        return v ? "True" : "False";
    if (v instanceof bytestring_1.ByteString)
        return "#" + v.toString();
    if ((0, plutus_data_1.isData)(v))
        return v.toString();
    if ((0, crypto_1.isBlsG1)(v))
        return "0x".concat((0, uint8array_utils_1.toHex)((0, crypto_1.bls12_381_G1_compress)(v)));
    if ((0, crypto_1.isBlsG2)(v))
        return "0x".concat((0, uint8array_utils_1.toHex)((0, crypto_1.bls12_381_G2_compress)(v)));
    if ((0, crypto_1.isBlsResult)(v))
        return JSON.stringify(v, function (k, v) { return typeof v === "bigint" ? v.toString() : v; });
    if (Array.isArray(v))
        return "[" + v.map(showUPLCConstValue).join(',') + "]";
    if (v instanceof pair_1.Pair)
        return "(".concat(showUPLCConstValue(v.fst), ",").concat(showUPLCConstValue(v.snd), ")");
    throw new Error("'showUPLCConstValue' did not matched any possible constant value");
}
exports.showUPLCConstValue = showUPLCConstValue;
function showConstType(t) {
    if (t[0] === ConstType_1.ConstTyTag.list) {
        return "(list ".concat(showConstType(ConstType_1.constListTypeUtils.getTypeArgument(t)), ")");
    }
    if (t[0] === ConstType_1.ConstTyTag.pair) {
        return "(pair ".concat(showConstType(ConstType_1.constPairTypeUtils.getFirstTypeArgument(t)), " ").concat(showConstType(ConstType_1.constPairTypeUtils.getSecondTypeArgument(t)), ")");
    }
    return (0, ConstType_1.constTypeToStirng)(t);
}
exports.showConstType = showConstType;
var vars = "abcdefghilmopqrstuvzwxyjkABCDEFGHILJMNOPQRSTUVZWXYJK".split('');
function getVarNameForDbn(dbn) {
    if (dbn < 0)
        return "(".concat(dbn, ")");
    if (dbn < vars.length)
        return vars[dbn];
    return vars[Math.floor(dbn / vars.length)] + getVarNameForDbn(dbn - vars.length);
}
function _showUPLC(t, dbn) {
    if (t instanceof UPLCVar_1.UPLCVar) {
        return getVarNameForDbn(dbn - 1 - Number(t.deBruijn));
    }
    if (t instanceof Delay_1.Delay)
        return "(delay ".concat(_showUPLC(t.delayedTerm, dbn), ")");
    if (t instanceof Lambda_1.Lambda) {
        return "(lam ".concat(getVarNameForDbn(dbn), " ").concat(_showUPLC(t.body, dbn + 1), ")");
    }
    if (t instanceof Application_1.Application)
        return "[".concat(_showUPLC(t.funcTerm, dbn), " ").concat(_showUPLC(t.argTerm, dbn), "]");
    if (t instanceof UPLCConst_1.UPLCConst)
        return "(con ".concat(showConstType(t.type), " ").concat(showUPLCConstValue(t.value), ")");
    if (t instanceof Force_1.Force)
        return "(force ".concat(_showUPLC(t.termToForce, dbn), ")");
    if (t instanceof ErrorUPLC_1.ErrorUPLC)
        return "(error)";
    if (t instanceof Builtin_1.Builtin) {
        var nForces = (0, UPLCBuiltinTag_1.getNRequiredForces)(t.tag);
        return "(force ".repeat(nForces) + "(builtin ".concat((0, UPLCBuiltinTag_1.builtinTagToString)(t.tag), ")") + ')'.repeat(nForces);
    }
    if (t instanceof Constr_1.Constr) {
        return "(constr " + t.index.toString() + " " + t.terms.map(function (term) { return _showUPLC(term, dbn); }).join(" ") + ")";
    }
    if (t instanceof Case_1.Case) {
        return "(case " + _showUPLC(t.constrTerm, dbn) + " " + t.continuations.map(function (term) { return _showUPLC(term, dbn); }).join(" ") + ")";
    }
    return "";
}
function showUPLC(term) {
    return _showUPLC(term, 0);
}
exports.showUPLC = showUPLC;
function prettyUPLC(term, _indent) {
    if (_indent === void 0) { _indent = 2; }
    if (!Number.isSafeInteger(_indent) || _indent < 1)
        return showUPLC(term);
    var indentStr = " ".repeat(_indent);
    function getVarNameForDbn(dbn) {
        if (dbn < 0)
            return "(".concat(dbn, ")");
        if (dbn < vars.length)
            return vars[dbn];
        return vars[Math.floor(dbn / vars.length)] + getVarNameForDbn(dbn - vars.length);
    }
    function _prettyUPLC(t, dbn, depth) {
        var indent = "\n".concat(indentStr.repeat(depth));
        if (t instanceof UPLCVar_1.UPLCVar) {
            return indent + getVarNameForDbn(dbn - 1 - Number(t.deBruijn));
        }
        if (t instanceof Delay_1.Delay)
            return "".concat(indent, "(delay ").concat(_prettyUPLC(t.delayedTerm, dbn, depth + 1)).concat(indent, ")");
        if (t instanceof Lambda_1.Lambda) {
            return "".concat(indent, "(lam ").concat(getVarNameForDbn(dbn), " ").concat(_prettyUPLC(t.body, dbn + 1, depth + 1)).concat(indent, ")");
        }
        if (t instanceof Application_1.Application)
            return "".concat(indent, "[").concat(_prettyUPLC(t.funcTerm, dbn, depth + 1), " ").concat(_prettyUPLC(t.argTerm, dbn, depth + 1)).concat(indent, "]");
        if (t instanceof UPLCConst_1.UPLCConst)
            return "".concat(indent, "(con ").concat(showConstType(t.type), " ").concat(showUPLCConstValue(t.value), ")");
        if (t instanceof Force_1.Force)
            return "".concat(indent, "(force ").concat(_prettyUPLC(t.termToForce, dbn, depth + 1)).concat(indent, ")");
        if (t instanceof ErrorUPLC_1.ErrorUPLC)
            return "(error)";
        if (t instanceof Builtin_1.Builtin) {
            var nForces = (0, UPLCBuiltinTag_1.getNRequiredForces)(t.tag);
            return indent + "(force ".repeat(nForces) + "(builtin ".concat((0, UPLCBuiltinTag_1.builtinTagToString)(t.tag), ")") + ')'.repeat(nForces);
        }
        if (t instanceof Constr_1.Constr) {
            var nextIndent = indent + indentStr;
            return indent + "(constr " + t.index.toString() + "\n" +
                nextIndent + "[" + t.terms.map(function (term) { return _prettyUPLC(term, dbn, depth + 2); }).join(",\n") +
                nextIndent + "]\n" +
                indent + ")";
        }
        if (t instanceof Case_1.Case) {
            var nextIndent = indent + indentStr;
            return indent + "(case\n" +
                _prettyUPLC(t.constrTerm, dbn, depth + 1) + "\n" +
                nextIndent + "[" +
                t.continuations.map(function (term) { return _prettyUPLC(term, dbn, depth + 2); }).join(",\n") +
                nextIndent + "]\n" +
                indent + ")";
        }
        return "";
    }
    return _prettyUPLC(term, 0, 0);
}
exports.prettyUPLC = prettyUPLC;
/**
 *
 * @param {number | bigint} varDeBruijn ```number | bigint```; debruijn level (at the term level) of the variable to search for
 * @param {UPLCTerm} t ```UPLCTerm``` to search in
 * @returns {boolean} ```true``` if the variable has **at least** 1 or more references; ```false``` otherwise
 */
function hasAnyRefsInTerm(varDeBruijn, t) {
    (0, assert_1.assert)(isUPLCTerm(t), "'getUPLCVarRefsInTerm' expects an UPLCTerms");
    var dbn = BigInt(varDeBruijn);
    if (t instanceof UPLCVar_1.UPLCVar)
        return t.deBruijn === dbn;
    if (t instanceof Delay_1.Delay)
        return hasAnyRefsInTerm(dbn, t.delayedTerm);
    if (t instanceof Lambda_1.Lambda)
        return hasAnyRefsInTerm(dbn + BigInt(1), t.body);
    if (t instanceof Application_1.Application)
        return hasAnyRefsInTerm(dbn, t.funcTerm) || hasAnyRefsInTerm(dbn, t.argTerm);
    if (t instanceof UPLCConst_1.UPLCConst)
        return false;
    if (t instanceof Force_1.Force)
        return hasAnyRefsInTerm(dbn, t.termToForce);
    if (t instanceof ErrorUPLC_1.ErrorUPLC)
        return false;
    if (t instanceof Builtin_1.Builtin)
        return false;
    if (t instanceof Constr_1.Constr)
        return t.terms.some(function (term) { return hasAnyRefsInTerm(dbn, term); });
    if (t instanceof Case_1.Case)
        return hasAnyRefsInTerm(dbn, t.constrTerm) || t.continuations.some(function (term) { return hasAnyRefsInTerm(dbn, term); });
    throw new Error("'hasAnyRefsInTerm' did not matched any possible 'UPLCTerm' constructor");
}
exports.hasAnyRefsInTerm = hasAnyRefsInTerm;
/**
 *
 * @param {number | bigint} varDeBruijn ```number | bigint```; debruijn level (at the term level) of the variable to search for
 * @param {UPLCTerm} term ```UPLCTerm``` to search in
 * @returns {boolean} ```true``` if the variable has 2 or more references; ```false``` otherwise
 */
function hasMultipleRefsInTerm(varDeBruijn, t) {
    (0, assert_1.assert)(isUPLCTerm(t), "'getUPLCVarRefsInTerm' expects an UPLCTerms");
    var dbn = BigInt(varDeBruijn);
    if (t instanceof UPLCVar_1.UPLCVar)
        return false; // single ref; case of multple refs is handled in 'Application' using 'hasAnyRefsInTerm'
    if (t instanceof Delay_1.Delay)
        return hasMultipleRefsInTerm(dbn, t.delayedTerm);
    if (t instanceof Lambda_1.Lambda)
        return hasMultipleRefsInTerm(dbn + BigInt(1), t.body);
    if (t instanceof Application_1.Application)
        return ((hasAnyRefsInTerm(dbn, t.funcTerm) && hasAnyRefsInTerm(dbn, t.argTerm)) || // referenced at least once in both terms
            hasMultipleRefsInTerm(dbn, t.funcTerm) || // referenced multiple times in func 
            hasMultipleRefsInTerm(dbn, t.argTerm) // referenced multiple times in arg
        );
    if (t instanceof UPLCConst_1.UPLCConst)
        return false;
    if (t instanceof Force_1.Force)
        return hasMultipleRefsInTerm(dbn, t.termToForce);
    if (t instanceof ErrorUPLC_1.ErrorUPLC)
        return false;
    if (t instanceof Builtin_1.Builtin)
        return false;
    if (t instanceof Constr_1.Constr)
        return termArrayHasManyRefs(dbn, t.terms);
    if (t instanceof Case_1.Case) {
        return ((hasAnyRefsInTerm(dbn, t.constrTerm) &&
            t.continuations.some(function (term) { return hasAnyRefsInTerm(dbn, term); })) ||
            hasMultipleRefsInTerm(dbn, t.constrTerm) ||
            termArrayHasManyRefs(dbn, t.continuations));
    }
    throw new Error("getUPLCVarRefsInTerm did not matched any possible 'UPLCTerm' constructor");
}
exports.hasMultipleRefsInTerm = hasMultipleRefsInTerm;
function termArrayHasManyRefs(dbn, terms) {
    var idx = terms.findIndex(function (term) { return hasAnyRefsInTerm(dbn, term); });
    if (idx < 0)
        return false; // no refs at all;
    return (terms.slice(idx + 1).some(function (term) { return hasAnyRefsInTerm(dbn, term); }) ||
        terms.some(function (term) { return hasMultipleRefsInTerm(dbn, term); }));
}
/**
 *
 * @param {number | bigint} varDeBruijn ```number | bigint```; debruijn level (at the term level) of the variable to search for
 * @param {UPLCTerm} term ```UPLCTerm``` to search in
 * @returns {number} number of references to the variable
 */
function getUPLCVarRefsInTerm(term, varDeBruijn) {
    if (varDeBruijn === void 0) { varDeBruijn = 0; }
    return _getUPLCVarRefsInTerm(BigInt(varDeBruijn), term, 0);
}
exports.getUPLCVarRefsInTerm = getUPLCVarRefsInTerm;
function _getUPLCVarRefsInTerm(dbn, t, countedUntilNow) {
    (0, assert_1.assert)(isUPLCTerm(t), "'getUPLCVarRefsInTerm' expects an UPLCTerms");
    if (t instanceof UPLCVar_1.UPLCVar)
        return countedUntilNow + (t.deBruijn === dbn ? 1 : 0);
    if (t instanceof Delay_1.Delay)
        return _getUPLCVarRefsInTerm(dbn, t.delayedTerm, countedUntilNow);
    if (t instanceof Lambda_1.Lambda)
        return _getUPLCVarRefsInTerm(dbn + BigInt(1), t.body, countedUntilNow);
    if (t instanceof Application_1.Application)
        return _getUPLCVarRefsInTerm(dbn, t.funcTerm, countedUntilNow) + _getUPLCVarRefsInTerm(dbn, t.argTerm, countedUntilNow);
    if (t instanceof UPLCConst_1.UPLCConst)
        return countedUntilNow;
    if (t instanceof Force_1.Force)
        return _getUPLCVarRefsInTerm(dbn, t.termToForce, countedUntilNow);
    if (t instanceof ErrorUPLC_1.ErrorUPLC)
        return countedUntilNow;
    if (t instanceof Builtin_1.Builtin)
        return countedUntilNow;
    if (t instanceof Constr_1.Constr)
        return t.terms.reduce(function (tot, term) { return _getUPLCVarRefsInTerm(dbn, term, tot); }, countedUntilNow);
    if (t instanceof Case_1.Case)
        return t.continuations.reduce(function (tot, term) { return _getUPLCVarRefsInTerm(dbn, term, tot); }, _getUPLCVarRefsInTerm(dbn, t.constrTerm, countedUntilNow));
    throw new Error("getUPLCVarRefsInTerm did not matched any possible 'UPLCTerm' constructor");
}
// type UPLCTerm = UPLCVar | Delay | Lambda | Application | UPLCConst | Force | ErrorUPLC | Builtin | Constr | Case;
function eqUPLCTerm(a, b) {
    if (a instanceof ErrorUPLC_1.ErrorUPLC)
        return b instanceof ErrorUPLC_1.ErrorUPLC;
    if (a instanceof UPLCVar_1.UPLCVar && b instanceof UPLCVar_1.UPLCVar)
        return a.deBruijn === b.deBruijn;
    if (a instanceof Delay_1.Delay && b instanceof Delay_1.Delay)
        return eqUPLCTerm(a.delayedTerm, b.delayedTerm);
    if (a instanceof Lambda_1.Lambda && b instanceof Lambda_1.Lambda)
        return eqUPLCTerm(a.body, b.body);
    if (a instanceof Application_1.Application && b instanceof Application_1.Application)
        return (eqUPLCTerm(a.argTerm, b.argTerm) &&
            eqUPLCTerm(a.funcTerm, b.funcTerm));
    if (a instanceof UPLCConst_1.UPLCConst && b instanceof UPLCConst_1.UPLCConst)
        return ((0, ConstType_1.constTypeEq)(a.type, b.type) &&
            (0, ConstValue_1.canConstValueBeOfConstType)(a.value, a.type) &&
            (0, ConstValue_1.canConstValueBeOfConstType)(b.value, b.type) &&
            (function () {
                try {
                    return (0, ConstValue_1.eqConstValue)(a.value, b.value);
                }
                catch (e) {
                    if (e instanceof RangeError)
                        return false;
                    throw e;
                }
            })());
    if (a instanceof Force_1.Force && b instanceof Force_1.Force)
        return eqUPLCTerm(a.termToForce, b.termToForce);
    if (a instanceof Builtin_1.Builtin && b instanceof Builtin_1.Builtin)
        return a.tag === b.tag;
    if (a instanceof Constr_1.Constr && b instanceof Constr_1.Constr)
        return (a.index === b.index &&
            a.terms.length === b.terms.length &&
            a.terms.every(function (t, i) { return eqUPLCTerm(t, b.terms[i]); }));
    if (a instanceof Case_1.Case && b instanceof Case_1.Case)
        return (eqUPLCTerm(a.constrTerm, b.constrTerm) &&
            a.continuations.length === b.continuations.length &&
            a.continuations.every(function (t, i) { return eqUPLCTerm(t, b.continuations[i]); }));
    return false;
}
exports.eqUPLCTerm = eqUPLCTerm;
