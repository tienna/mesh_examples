"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOffsetToNextClosingBracket = exports.parseUPLCText = exports.parseConstType = exports.parseConstValueOfType = exports._parseUPLCText = void 0;
var bytestring_1 = require("@harmoniclabs/bytestring");
var UPLCTerms_1 = require("../UPLCTerms/index.js");
var plutus_data_1 = require("@harmoniclabs/plutus-data");
var pair_1 = require("@harmoniclabs/pair");
var crypto_1 = require("@harmoniclabs/crypto");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var indexOfNextCommaOutsideParentesis_1 = require("../utils/indexOfNextCommaOutsideParentesis.js");
var indexOfNextUnmatchedParentesis_1 = require("../utils/indexOfNextUnmatchedParentesis.js");
var getTextBetweenMatchingQuotes_1 = require("../utils/getTextBetweenMatchingQuotes.js");
var indexOfMany_1 = require("../utils/indexOfMany.js");
var UPLCProgram_1 = require("../UPLCProgram/index.js");
function _parseUPLCText(str, env, dbn, version) {
    // clone (other branches migh modify vars dbns)
    env = __assign({}, env);
    var offset = 0;
    var sliceTrimIncr = function (n) {
        if (n === void 0) { n = 0; }
        var tmp = str.length;
        str = str.slice(n).trimStart();
        offset += tmp - str.length;
    };
    var throwIllFormed = function () {
        // console.error( str );
        throw new Error("ill formed uplc text");
    };
    var getNextWord = function (s) {
        if (s === void 0) { s = str; }
        var fstSpaceIdx = s.search(/\s/);
        if (fstSpaceIdx < 0)
            fstSpaceIdx = str.length - 1;
        var varName = s.slice(0, fstSpaceIdx).trim();
        while (varName.endsWith(")") ||
            varName.endsWith("]") ||
            varName.endsWith(" ") ||
            varName.endsWith("\n")) {
            varName = varName.slice(0, varName.length - 1);
        }
        return varName;
    };
    sliceTrimIncr(0);
    var ch = str[0];
    // drop the opening bracket;
    if (ch === "[") {
        sliceTrimIncr(1);
        offset += getOffsetToNextClosingBracket(str, "[", "]");
        var fn = _parseUPLCText(str, env, dbn, version);
        str = str.slice(fn.offset + 1);
        var arg = _parseUPLCText(str, env, dbn, version);
        return {
            term: new UPLCTerms_1.Application(fn.term, arg.term),
            offset: offset
        };
    }
    if (ch === "(") {
        sliceTrimIncr(1);
        if (str.startsWith("error")) {
            offset += getOffsetToNextClosingBracket(str, "(", ")");
            return {
                term: new UPLCTerms_1.ErrorUPLC(),
                offset: offset
            };
        }
        if (str.startsWith("delay")) {
            offset += getOffsetToNextClosingBracket(str, "(", ")");
            return {
                term: new UPLCTerms_1.Delay(_parseUPLCText(str.slice(5), env, dbn, version).term),
                offset: offset
            };
        }
        if (str.startsWith("force")) {
            offset += getOffsetToNextClosingBracket(str, "(", ")");
            var directChild = _parseUPLCText(str.slice(5), env, dbn, version).term;
            if (directChild instanceof UPLCTerms_1.Builtin &&
                (0, UPLCTerms_1.getNRequiredForces)(directChild.tag) === 1)
                return {
                    term: directChild,
                    offset: offset
                };
            if (directChild instanceof UPLCTerms_1.Force &&
                directChild.termToForce instanceof UPLCTerms_1.Builtin &&
                (0, UPLCTerms_1.getNRequiredForces)(directChild.termToForce.tag) === 2)
                return {
                    term: directChild.termToForce,
                    offset: offset
                };
            return {
                term: new UPLCTerms_1.Force(directChild),
                offset: offset
            };
        }
        if (str.startsWith("builtin")) {
            offset += getOffsetToNextClosingBracket(str, "(", ")");
            str = str.slice(7).trimStart();
            return {
                term: new UPLCTerms_1.Builtin((0, UPLCTerms_1.builtinTagFromString)(getNextWord())),
                offset: offset
            };
        }
        if (str.startsWith("lam")) {
            offset += getOffsetToNextClosingBracket(str, "(", ")");
            str = str.slice(3).trimStart();
            var varName_1 = getNextWord();
            str = str.slice(varName_1.length).trimStart();
            env[varName_1] = dbn;
            return {
                term: new UPLCTerms_1.Lambda(_parseUPLCText(str, env, dbn + 1, version).term),
                offset: offset
            };
        }
        if (str.startsWith("case")) {
            if (!version.isV3Friendly())
                throw new Error("case uplc node found on program version: " + version.toString());
            sliceTrimIncr(4);
            var closeIdx = (0, indexOfNextUnmatchedParentesis_1.indexOfNextUnmatchedParentesis)(str);
            str = str.slice(0, closeIdx).trim();
            var terms = [];
            while (str.length > 0) {
                var _a = _parseUPLCText(str, env, dbn, version), term = _a.term, offset_1 = _a.offset;
                terms.push(term);
                str = str.slice(offset_1).trim();
            }
            if (terms.length < 1)
                throw new Error("ill formed uplc, missing constr term on case");
            return {
                term: new UPLCTerms_1.Case(terms.shift(), terms),
                offset: offset + closeIdx + 1
            };
        }
        // "constr" MUST BE before "con"
        if (str.startsWith("constr")) {
            if (!version.isV3Friendly())
                throw new Error("case uplc node found on program version: " + version.toString());
            sliceTrimIncr(6);
            var closeIdx = (0, indexOfNextUnmatchedParentesis_1.indexOfNextUnmatchedParentesis)(str);
            str = str.slice(0, closeIdx);
            var _b = parseConstValueOfType(str, UPLCTerms_1.constT.int), idx = _b.value, idxOffset = _b.offset;
            str = str.slice(idxOffset);
            if (typeof idx !== "bigint")
                throw new Error("ill formed uplc; constr expects u64 index");
            var terms = [];
            str = str.trim();
            while (str.length > 0) {
                var _c = _parseUPLCText(str, env, dbn, version), term = _c.term, offset_2 = _c.offset;
                terms.push(term);
                str = str.slice(offset_2).trim();
            }
            return {
                term: new UPLCTerms_1.Constr(idx, terms),
                offset: offset + closeIdx + 1
            };
        }
        if (str.startsWith("con")) {
            offset += getOffsetToNextClosingBracket(str, "(", ")");
            str = str.slice(3).trimStart();
            var t = parseConstType(str);
            str = str.slice(t.offset).trimStart();
            var v = parseConstValueOfType(str, t.type);
            str = str.slice(v.offset).trimStart();
            return {
                term: new UPLCTerms_1.UPLCConst(t.type, v.value),
                offset: offset
            };
        }
    }
    // else var
    offset--;
    var varName = getNextWord();
    offset += varName.length;
    if (varName.startsWith("-")) { // out of bound var
        return {
            term: new UPLCTerms_1.UPLCVar(dbn + parseInt(varName.slice(1)) - 1),
            offset: offset
        };
    }
    var varDbn = env[varName];
    if (varDbn === undefined) {
        // console.log( env, `"${varName}"`, Object.keys( env )[0] === varName )
        // throwIllFormed();
        throw new Error("unbound variable found");
    }
    return {
        term: new UPLCTerms_1.UPLCVar(dbn - 1 - varDbn),
        offset: offset
    };
}
exports._parseUPLCText = _parseUPLCText;
var hexChars = Array.from("0123456789abcdef");
function isHexChar(ch) {
    return hexChars.includes(ch[0].toLowerCase());
}
function isLowestNonNegative(a, b) {
    return a >= 0 && (b < 0 || a < b);
}
function parseConstValueOfType(str, t) {
    var offset = 0;
    var sliceTrimIncr = function (n) {
        if (n === void 0) { n = 0; }
        var tmp = str.length;
        str = str.slice(n).trimStart();
        offset += tmp - str.length;
    };
    sliceTrimIncr(0);
    if ((0, UPLCTerms_1.constTypeEq)(t, UPLCTerms_1.constT.unit)) {
        sliceTrimIncr(str.indexOf("()") + 2);
        return {
            value: undefined,
            offset: offset
        };
    }
    if ((0, UPLCTerms_1.constTypeEq)(t, UPLCTerms_1.constT.int)) {
        var closeIndex = str.indexOf(")");
        var regExpRes = str
            .slice(0, closeIndex < 0 ? undefined : closeIndex)
            // \+?\-?           -> may or may nost start with "+" or "-"
            // (?<!\.)          -> MUST NOT have dots before
            // (?<!(#|x)\d*)    -> MUST NOT have before "#" or "x" with 0 or more digits (escluded bls elements and bytestrings)
            // \d+              -> one or more digits
            // (?!(\.|x))       -> MUST NOT have dots after or "x" (x excludes "0x" which are bls elems)
            .match(/\+?\-?(?<!\.)(?<!(#|x)\d*)\d+(?!(\.|x))/);
        if (regExpRes === null)
            throw new Error("could not find integer for constant uplc");
        var nStr = regExpRes[0];
        var value = BigInt(nStr);
        sliceTrimIncr(str.indexOf(nStr) + nStr.length);
        return {
            value: value,
            offset: offset
        };
    }
    if ((0, UPLCTerms_1.constTypeEq)(t, UPLCTerms_1.constT.str)) {
        var quoteIdx = str.indexOf('"');
        if (!/^\s*$/.test(str.slice(0, quoteIdx)))
            throw new Error("ill formed uplc");
        sliceTrimIncr(quoteIdx);
        var value = (0, getTextBetweenMatchingQuotes_1.getTextBetweenMatchingQuotes)(str);
        if (typeof value !== "string")
            throw new Error("missing constant string value");
        sliceTrimIncr(value.length + 2);
        return {
            value: value,
            offset: offset
        };
    }
    if ((0, UPLCTerms_1.constTypeEq)(t, UPLCTerms_1.constT.bool)) {
        var trueIdx = str.indexOf("True");
        var falseIdx = str.indexOf("False");
        if (trueIdx < 0 && falseIdx < 0)
            throw new Error("expected boolean value; found none");
        var isTrue = isLowestNonNegative(trueIdx, falseIdx);
        if (isTrue) {
            sliceTrimIncr(trueIdx + 4);
            return {
                value: true,
                offset: offset
            };
        }
        else {
            sliceTrimIncr(falseIdx + 5);
            return {
                value: false,
                offset: offset
            };
        }
    }
    if ((0, UPLCTerms_1.constTypeEq)(t, UPLCTerms_1.constT.byteStr)) {
        sliceTrimIncr(str.indexOf("#") + 1);
        var i = 0;
        while (i < str.length && isHexChar(str[i++]))
            ;
        !isHexChar(str[i - 1]) && i--;
        var hex = str.slice(0, i);
        // we can handle it but plutus conformance doesn't allow it
        if (hex.length % 2 === 1) {
            throw new Error("invalid bytestring value: received: " + hex);
        }
        sliceTrimIncr(i);
        return {
            value: new bytestring_1.ByteString(hex),
            offset: offset
        };
    }
    if ((0, UPLCTerms_1.constTypeEq)(t, UPLCTerms_1.constT.data)) {
        sliceTrimIncr(0);
        var _a = (0, plutus_data_1.dataFromStringWithOffset)(str), data = _a.data, dataOffset = _a.offset;
        offset += dataOffset;
        return {
            value: data,
            offset: offset
        };
    }
    if ((0, UPLCTerms_1.constTypeEq)(t, UPLCTerms_1.constT.bls12_381_G1_element)) {
        var original = str;
        str = str.slice(0, str.indexOf(")") + 1).trimStart();
        offset += (original.length - original.indexOf(str)) + 2 /*0x*/ + 96;
        var match = str.match(/^0x[0-9a-fA-F]{96}(?![0-9a-fA-F]+)/); // 48 bytes; 96 hex chars
        if (!match)
            throw new Error("missing bls g1 compressed elem");
        var value = (0, crypto_1.bls12_381_G1_uncompress)((0, uint8array_utils_1.fromHex)(match[0].slice(2)));
        return { value: value, offset: offset };
    }
    if ((0, UPLCTerms_1.constTypeEq)(t, UPLCTerms_1.constT.bls12_381_G2_element)) {
        var original = str;
        str = str.slice(0, str.indexOf(")") + 1).trimStart();
        offset += (original.length - original.indexOf(str)) + 2 /*0x*/ + 192;
        var match = str.match(/^0x[0-9a-fA-F]{192}(?![0-9a-fA-F]+)/); // 96 bytes; 192 hex chars
        if (!match)
            throw new Error("missing bls g2 compressed elem");
        var value = (0, crypto_1.bls12_381_G2_uncompress)((0, uint8array_utils_1.fromHex)(match[0].slice(2)));
        return { value: value, offset: offset };
    }
    if ((0, UPLCTerms_1.constTypeEq)(t, UPLCTerms_1.constT.bls12_381_MlResult)) {
        throw new Error("bls12_381_MlResult const type not supported");
    }
    if (t[0] === UPLCTerms_1.ConstTyTag.pair) {
        sliceTrimIncr(str.indexOf("(") + 1);
        var commaIdx = (0, indexOfNextCommaOutsideParentesis_1.indexOfNextCommaOutsideParentesis)(str);
        var fst = parseConstValueOfType(str.slice(0, commaIdx), UPLCTerms_1.constPairTypeUtils.getFirstTypeArgument(t));
        sliceTrimIncr(commaIdx + 1);
        var closeIdx = (0, indexOfNextUnmatchedParentesis_1.indexOfNextUnmatchedParentesis)(str);
        var snd = parseConstValueOfType(str.slice(0, closeIdx), UPLCTerms_1.constPairTypeUtils.getSecondTypeArgument(t));
        sliceTrimIncr(closeIdx + 1);
        return {
            value: new pair_1.Pair(fst.value, snd.value),
            offset: offset
        };
    }
    if (t[0] === UPLCTerms_1.ConstTyTag.list) {
        sliceTrimIncr(str.indexOf("[") + 1);
        var elemsT = UPLCTerms_1.constListTypeUtils.getTypeArgument(t);
        var elems = [];
        while (!str.startsWith("]")) {
            var elem = parseConstValueOfType(str, elemsT);
            sliceTrimIncr(elem.offset);
            sliceTrimIncr(str.indexOf(",") + 1);
            elems.push(elem.value);
        }
        return {
            value: elems,
            offset: offset
        };
    }
    throw new Error("unknown const type");
}
exports.parseConstValueOfType = parseConstValueOfType;
function parseConstType(str) {
    var offset = 0;
    var sliceTrimIncr = function (n) {
        if (n === void 0) { n = 0; }
        var tmp = str.length;
        str = str.slice(n).trimStart();
        offset += tmp - str.length;
    };
    sliceTrimIncr(0);
    if (str.startsWith("integer")) {
        sliceTrimIncr(7);
        return {
            type: UPLCTerms_1.constT.int,
            offset: offset
        };
    }
    if (str.startsWith("bytestring")) {
        sliceTrimIncr(10);
        return {
            type: UPLCTerms_1.constT.byteStr,
            offset: offset
        };
    }
    if (str.startsWith("string")) {
        sliceTrimIncr(6);
        return {
            type: UPLCTerms_1.constT.str,
            offset: offset
        };
    }
    if (str.startsWith("unit")) {
        sliceTrimIncr(4);
        return {
            type: UPLCTerms_1.constT.unit,
            offset: offset
        };
    }
    if (str.startsWith("bool")) {
        if (str.startsWith("boolean"))
            sliceTrimIncr(7);
        else
            sliceTrimIncr(4);
        return {
            type: UPLCTerms_1.constT.bool,
            offset: offset
        };
    }
    if (str.startsWith("data")) {
        sliceTrimIncr(4);
        return {
            type: UPLCTerms_1.constT.data,
            offset: offset
        };
    }
    if (str.startsWith("bls12_381_G1_element")) {
        sliceTrimIncr("bls12_381_G1_element".length);
        return {
            type: UPLCTerms_1.constT.bls12_381_G1_element,
            offset: offset
        };
    }
    if (str.startsWith("bls12_381_G2_element")) {
        sliceTrimIncr("bls12_381_G2_element".length);
        return {
            type: UPLCTerms_1.constT.bls12_381_G2_element,
            offset: offset
        };
    }
    if (str.startsWith("bls12_381_MlResult"))
        throw new Error("bls12_381_MlResult const not supported in textual UPLC");
    if (str.startsWith("(")) {
        sliceTrimIncr(1);
        var listIdx = str.indexOf("list");
        var pairIdx = str.indexOf("pair");
        if (listIdx < 0 && pairIdx < 0)
            throw new Error("invalid constant type; expected list or pair");
        var isList = isLowestNonNegative(listIdx, pairIdx);
        var isPair = isLowestNonNegative(pairIdx, listIdx);
        if (isList) {
            sliceTrimIncr(listIdx + 4);
            var elems = parseConstType(str);
            sliceTrimIncr(elems.offset);
            while (!str.startsWith(")"))
                sliceTrimIncr(1);
            sliceTrimIncr(1);
            return {
                type: UPLCTerms_1.constT.listOf(elems.type),
                offset: offset
            };
        }
        else if (isPair) {
            sliceTrimIncr(pairIdx + 4);
            var fst = parseConstType(str);
            sliceTrimIncr(fst.offset);
            while (str.startsWith(" ") ||
                str.startsWith("\n"))
                sliceTrimIncr(1);
            var snd = parseConstType(str);
            sliceTrimIncr(snd.offset);
            while (!str.startsWith(")"))
                sliceTrimIncr(1);
            sliceTrimIncr(1);
            return {
                type: UPLCTerms_1.constT.pairOf(fst.type, snd.type),
                offset: offset
            };
        }
        else {
            console.log(str, listIdx, pairIdx);
            throw new Error("invalid constant type; missing list or pair");
        }
    }
    throw new Error("unknown UPLC const type; src: " + str);
}
exports.parseConstType = parseConstType;
function parseUPLCText(str, version) {
    if (version === void 0) { version = UPLCProgram_1.defaultUplcVersion; }
    str = str.trim();
    if (str.startsWith("(program")) {
        str = str.slice(8, str.lastIndexOf(")")).trim();
        var verStr = str.match(/^\d+\.\d+\.\d+(?!\.)/);
        if (!verStr)
            throw new Error("uplc program without version");
        version = UPLCProgram_1.UPLCVersion.fromString(verStr[0]);
        str = str.slice((0, indexOfMany_1.indexOfMany)(str, "(", "["));
    }
    version = version instanceof UPLCProgram_1.UPLCVersion ? version : UPLCProgram_1.defaultUplcVersion;
    return _parseUPLCText(str, {}, 0, version).term;
}
exports.parseUPLCText = parseUPLCText;
/**
 *
 * @param {string} str string removed of the first opening bracket
 * @example
 * ```ts
 * const str = "( hello )";
 * const expectedInput = str.slice(1); // " hello )";
 * const offset = getOffsetToNextClosingBracket( expectedInput ); // 8
 * ```
 * @returns
 */
function getOffsetToNextClosingBracket(str, openCh, closeCh) {
    if (openCh === void 0) { openCh = "("; }
    if (closeCh === void 0) { closeCh = ")"; }
    var nBrackets = 1;
    var offset = 0;
    var ch = '';
    while (nBrackets > 0) {
        ch = str[offset++];
        if (ch === openCh) {
            nBrackets++;
            continue;
        }
        if (ch === closeCh) {
            nBrackets--;
            continue;
        }
    }
    return offset;
}
exports.getOffsetToNextClosingBracket = getOffsetToNextClosingBracket;
// we have `dataFromString` from "@harmoniclabs/plutus-data"
// but no way to reliably retreive the offset
// seo
function myDataFromStringWithOffset(str) {
    var original = str;
    var openIdx = str.indexOf("(");
    if (openIdx < 0)
        throw new Error("missign opening wrapping parentesis for data");
    str = str.slice(openIdx + 1);
    var offset = original.length - str.length;
    var closeIdx = (0, indexOfNextUnmatchedParentesis_1.indexOfNextUnmatchedParentesis)(str);
    if (closeIdx < 0)
        throw new Error("missign closing wrapping parentesis for data");
    offset += closeIdx + 1;
    return {
        data: (0, plutus_data_1.dataFromString)(str.slice(0, closeIdx).trim()),
        offset: offset
    };
}
