"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isInByteOffset = void 0;
var bitstream_1 = require("@harmoniclabs/bitstream");
var BitUtils_1 = __importDefault(require("../BitUtils/index.js"));
var assert_1 = require("../assert.js");
function isInByteOffset(offset) {
    return (offset === 0 ||
        offset === 1 ||
        offset === 2 ||
        offset === 3 ||
        offset === 4 ||
        offset === 5 ||
        offset === 6 ||
        offset === 7);
}
exports.isInByteOffset = isInByteOffset;
/**
 * @static
 */
var UPLCFlatUtils = /** @class */ (function () {
    /**
     * @deprecated this is a @static class, it is not supposed to have instances
     */
    function UPLCFlatUtils() {
    }
    ;
    UPLCFlatUtils.zigzagBigint = function (bigint) {
        return (bigint >>
            (BigInt(BitUtils_1.default.getNOfUsedBits(bigint)))) ^ // XOR
            (bigint << BigInt(1));
    };
    UPLCFlatUtils.unzigzagBigint = function (bigint) {
        return (((bigint >> BigInt(1))) ^ // XOR
            -(bigint & BigInt(1)));
    };
    /**
     * source: https://hydra.iohk.io/build/5988492/download/1/plutus-core-specification.pdf#Variable%20length%20data
     *
     * Non-empty lists are encoded by prefixing the element stored with ‘0’ if this is the last element
     * or ‘1’ if there is more data following.
     *
     * We encode Integers as a non-empty list of chunks, 7 bits each, with the least significant chunk
     * first and the most significant bit first in the chunk.
     */
    UPLCFlatUtils.encodeBigIntAsVariableLengthBitStream = function (integer) {
        (0, assert_1.assert)(typeof integer === "bigint", "expected a bigint as input; got instance of type: " + typeof integer);
        if (integer === BigInt(0))
            return bitstream_1.BitStream.fromBinStr("00000000");
        (0, assert_1.assert)(integer > BigInt(0), "'UPLCFlatUtils.encodeBigIntAsVariableLengthBitStream' can only encode non-negative integers; the given input was: " + integer.toString());
        // store binary string for easy BitStream creation
        var chunks = [];
        var mask = BigInt(127);
        // 1. Converting to binary
        var nBits = BitUtils_1.default.getNOfUsedBits(integer);
        for (var nAddedBits = 0; nAddedBits < nBits; nAddedBits += 7) {
            // 3. Reorder chunks (least significant chunk first)
            // 
            // push at the end because the mask starts from the last signigficat chunk first
            // so chunk[1] is the second least significant and so on
            chunks.push(
            // 2. Split into 7 bit chunks
            // take 7 bits
            ((integer & mask)
                // allign to the start 
                >> BigInt(nAddedBits))
                // translate to biinary
                .toString(2)
                // make sure the bits are 7 in total
                .padStart(7, '0'));
            mask = mask << BigInt(7);
        }
        // 4. Add list constructor tags
        for (var i = 0; i < chunks.length; i++) {
            chunks[i] = (i === chunks.length - 1 ? '0' : '1') + chunks[i];
        }
        return bitstream_1.BitStream.fromBinStr(chunks.join(''));
    };
    UPLCFlatUtils.getPadBitStream = function (n) {
        (0, assert_1.assert)(isInByteOffset(n), "addPadTo only works for pads from 0 inclusive to 7 inclusive");
        if (n === 0) {
            return bitstream_1.BitStream.fromBinStr("1".padStart(8, '0'));
        }
        return bitstream_1.BitStream.fromBinStr("1".padStart(n, '0'));
    };
    /**
     * **_SIDE EFFECT_**: modifies the ```toPad``` ```BitStream``` passed as first argument
     *
     * @param toPad
     * @param n
     * @returns
     */
    UPLCFlatUtils.addPadTo = function (toPad, n) {
        (0, assert_1.assert)(bitstream_1.BitStream.isStrictInstance(toPad), "BitStream strict instance expected as first argument in 'UPLCFlatUtils.addPadTo'");
        toPad.append(UPLCFlatUtils.getPadBitStream(n));
        return;
    };
    Object.defineProperty(UPLCFlatUtils, "padToByteDefaultOptions", {
        get: function () {
            return Object.freeze({
                onByteAllignedAddNewByte: true,
                withOneAsEndPadding: true
            });
        },
        enumerable: false,
        configurable: true
    });
    /**
     * **_SIDE EFFECT_**: modifies the ```toPad``` ```BitStream``` passed as first argument
     *
     * @param toPad
     * @param options
     * @returns
     */
    UPLCFlatUtils.padToByte = function (toPad, options) {
        var opts = __assign(__assign({}, UPLCFlatUtils.padToByteDefaultOptions), (options === undefined ? {} : options));
        var nBitsMissingToByte = toPad.getNBitsMissingToByte();
        if (nBitsMissingToByte === 0) {
            if (opts.onByteAllignedAddNewByte) {
                toPad.append(bitstream_1.BitStream.fromBinStr((opts.withOneAsEndPadding ? "1" : "0").padStart(8, '0')));
            }
            else {
                // do nothing, already alligned
            }
            return;
        }
        toPad.append(bitstream_1.BitStream.fromBinStr((opts.withOneAsEndPadding ? "1" : "0").padStart(nBitsMissingToByte, '0')));
        return;
    };
    return UPLCFlatUtils;
}());
exports.default = UPLCFlatUtils;
