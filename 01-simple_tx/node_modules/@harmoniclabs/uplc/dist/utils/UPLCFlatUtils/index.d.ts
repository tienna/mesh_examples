import { BitStream } from "@harmoniclabs/bitstream";
export type InByteOffset = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7;
export declare function isInByteOffset(offset: InByteOffset): boolean;
export interface BitStreamPadToByteOptions {
    onByteAllignedAddNewByte: boolean;
    withOneAsEndPadding: boolean;
}
/**
 * @static
 */
export default class UPLCFlatUtils {
    /**
     * @deprecated this is a @static class, it is not supposed to have instances
     */
    private constructor();
    static zigzagBigint(bigint: bigint): bigint;
    static unzigzagBigint(bigint: bigint): bigint;
    /**
     * source: https://hydra.iohk.io/build/5988492/download/1/plutus-core-specification.pdf#Variable%20length%20data
     *
     * Non-empty lists are encoded by prefixing the element stored with ‘0’ if this is the last element
     * or ‘1’ if there is more data following.
     *
     * We encode Integers as a non-empty list of chunks, 7 bits each, with the least significant chunk
     * first and the most significant bit first in the chunk.
     */
    static encodeBigIntAsVariableLengthBitStream(integer: Readonly<bigint>): BitStream;
    static getPadBitStream(n: InByteOffset): BitStream;
    /**
     * **_SIDE EFFECT_**: modifies the ```toPad``` ```BitStream``` passed as first argument
     *
     * @param toPad
     * @param n
     * @returns
     */
    static addPadTo(toPad: BitStream, n: InByteOffset): void;
    static get padToByteDefaultOptions(): Readonly<BitStreamPadToByteOptions>;
    /**
     * **_SIDE EFFECT_**: modifies the ```toPad``` ```BitStream``` passed as first argument
     *
     * @param toPad
     * @param options
     * @returns
     */
    static padToByte(toPad: BitStream, options?: Partial<BitStreamPadToByteOptions>): void;
}
