"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseUPLC = exports.UPLCDecoder = void 0;
var UPLCProgram_1 = require("../UPLCProgram/UPLCProgram.js");
var UPLCVersion_1 = require("../UPLCProgram/UPLCVersion.js");
var UPLCTerm_1 = require("../UPLCTerm/UPLCTerm.js");
var Application_1 = require("../UPLCTerms/Application.js");
var Builtin_1 = require("../UPLCTerms/Builtin/Builtin.js");
var UPLCBuiltinTag_1 = require("../UPLCTerms/Builtin/UPLCBuiltinTag.js");
var Delay_1 = require("../UPLCTerms/Delay.js");
var ErrorUPLC_1 = require("../UPLCTerms/ErrorUPLC.js");
var Force_1 = require("../UPLCTerms/Force.js");
var Lambda_1 = require("../UPLCTerms/Lambda.js");
var UPLCVar_1 = require("../UPLCTerms/UPLCVar/index.js");
var UPLCConst_1 = require("../UPLCTerms/UPLCConst/UPLCConst.js");
var ConstType_1 = require("../UPLCTerms/UPLCConst/ConstType/index.js");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var bytestring_1 = require("@harmoniclabs/bytestring");
var cbor_1 = require("@harmoniclabs/cbor");
var UPLCFlatUtils_1 = __importDefault(require("../utils/UPLCFlatUtils/index.js"));
var bigint_utils_1 = require("@harmoniclabs/bigint-utils");
var plutus_data_1 = require("@harmoniclabs/plutus-data");
var pair_1 = require("@harmoniclabs/pair");
var UPLCTermTag_1 = require("../UPLCTerm/UPLCTermTag.js");
var Constr_1 = require("../UPLCTerms/Constr.js");
var Case_1 = require("../UPLCTerms/Case.js");
function isSerializedScriptFormat(str) {
    return (typeof str === "string" &&
        (str === "flat" ||
            str === "cbor"));
}
var UPLCDecoder = /** @class */ (function () {
    function UPLCDecoder() {
    }
    UPLCDecoder.parse = function (serializedScript, format, debugLogs) {
        if (format === void 0) { format = "cbor"; }
        if (debugLogs === void 0) { debugLogs = false; }
        if (!isSerializedScriptFormat(format)) {
            throw new Error("unknown format: " + format.toString());
        }
        if (format === "cbor") {
            var shouldTryParseCbor = true;
            var tmp = undefined;
            while (shouldTryParseCbor) {
                try {
                    tmp = cbor_1.Cbor.parse(serializedScript);
                }
                catch (_a) {
                    shouldTryParseCbor = false;
                }
                if (!(tmp instanceof cbor_1.CborBytes)) {
                    shouldTryParseCbor = false;
                }
                else {
                    serializedScript = tmp.buffer;
                }
            }
            format = "flat";
        }
        // -------------------------- ctx steup -------------------------- //
        var currPtr = 0;
        var nBytes = serializedScript.length;
        var scriptBits = "0000000" + (0, bigint_utils_1.bigintFromBuffer)(serializedScript).toString(2);
        /**
         * dependencies:
         * - currPtr
         * - nBytes
         * - serializedScript
         */
        var version = new UPLCVersion_1.UPLCVersion(readUInt(), readUInt(), readUInt());
        var isV3Friendly = version.isV3Friendly();
        var currDbn = 0;
        function incrementPtrBy(n) {
            currPtr += n;
        }
        function logState(forced) {
            if (forced === void 0) { forced = false; }
            if (forced || debugLogs) {
                console.log("UPLCDecoder state: " + JSON.stringify({
                    currPtr: currPtr,
                    bits: "..." + scriptBits.slice(currPtr - 16, currPtr + 16) + "...",
                    "ptr ": ' '.repeat(19) + '^',
                    currentByteIndex: currByteIndex(),
                    partialUPLC: partialUPLC
                }, undefined, 2));
            }
        }
        // --------------------------------------------------------------- //
        // ------------------------------ partial UPLC stuff ------------------------------ //
        var vars = "abcdefghilmopqrstuvzwxyjkABCDEFGHILJMNOPQRSTUVZWXYJK".split('');
        var partialUPLC = "";
        // -------------------------------------------------------------------------------- //
        /**
         * dependencies:
         * - currPtr
         * - nBytes
         */
        function currByteIndex() {
            var idx = Math.floor(currPtr / 8);
            if (idx >= nBytes)
                throw new Error("pointer out of bound; ptr: " + currPtr + "; n bits: " + nBytes * 8);
            return idx;
        }
        /**
         * dependencies:
         * - currPtr
         * - nBytes
         * - serializedScript
         */
        function currByte() {
            var byte = serializedScript.at(currByteIndex());
            if (byte === undefined)
                throw new Error("pointer out of bound; ptr: " + currPtr + "; n bits: " + nBytes * 8);
            return byte;
        }
        function getByteMask(nBits) {
            var mask = 0;
            for (var _nBits = Math.round(Math.abs(nBits)); _nBits > 0; _nBits--) {
                mask = (mask << 1) + 1;
            }
            return mask;
        }
        function nthBitOfByte(nth, byte) {
            switch (nth) {
                case 0: return ((byte & 128) >> 7);
                case 1: return ((byte & 64) >> 6);
                case 2: return ((byte & 32) >> 5);
                case 3: return ((byte & 16) >> 4);
                case 4: return ((byte & 8) >> 3);
                case 5: return ((byte & 4) >> 2);
                case 6: return ((byte & 2) >> 1);
                case 7: return (byte & 1);
                default: throw new Error("can't access bit n: " + nth);
            }
        }
        /**
         * dependencies:
         * - currPtr
         * - nBytes
         * - serializedScript
         */
        function readNBits(n) {
            if (n <= 0)
                return BigInt(0);
            var currB = currByte();
            var inBytePtr = currPtr % 8;
            if (n === 1) {
                incrementPtrBy(1);
                return BigInt(nthBitOfByte(inBytePtr, currB));
            }
            var missingBitsToByte = 8 - inBytePtr;
            var shift = missingBitsToByte - n;
            if (n <= missingBitsToByte) {
                incrementPtrBy(n);
                return BigInt((currB & (getByteMask(n) << shift)) >> shift);
            }
            incrementPtrBy(missingBitsToByte);
            var result = BigInt(currB & getByteMask(missingBitsToByte));
            var missingBitsToRead = n - missingBitsToByte;
            var nWholeBytes = 0;
            for (; (nWholeBytes + 1) * 8 < missingBitsToRead; nWholeBytes++) {
                result = (result << BigInt(8)) & BigInt(currByte());
                incrementPtrBy(8);
            }
            missingBitsToRead = missingBitsToRead - (nWholeBytes * 8);
            if (missingBitsToRead === 0)
                return result;
            return (result << BigInt(missingBitsToRead)) | readNBits(missingBitsToRead);
        }
        function readPadding() {
            while (Number(readNBits(1)) !== 1) { }
            if ((currPtr % 8) !== 0)
                throw new Error("padding was not alligned to byte; currPtr was: " + currPtr + "; currPtr % 8: " + currPtr % 8);
        }
        /**
         * dependencies:
         * - currPtr
         * - nBytes
         * - serializedScript
         */
        function readUInt() {
            var n = BigInt(0);
            var wasLast = true;
            var nRed = 0;
            do {
                var red = readNBits(8);
                wasLast = (red & BigInt(128)) === BigInt(0);
                n = n | (red & BigInt(127)) << BigInt(nRed * 7);
                nRed++;
            } while (!wasLast);
            return n;
        }
        ;
        function readSignedInt() {
            return UPLCFlatUtils_1.default.unzigzagBigint(readUInt());
        }
        function readTerm() {
            var _a;
            // console.log( "left to read: " + serializedScript.subarray( currByteIndex() ).toString("hex") );
            logState();
            var tag = Number(readNBits(4));
            switch (tag) {
                // serialised debruijn starts form 1;
                // plu-ts debruijn starts from 0
                case UPLCTermTag_1.UPLCTermTag.Var:
                    var _dbn = readUInt();
                    var dbn = Number(_dbn);
                    var idx = currDbn - (dbn - 1);
                    partialUPLC += (_a = vars[idx]) !== null && _a !== void 0 ? _a : "(".concat(idx.toString(), ")");
                    return new UPLCVar_1.UPLCVar(_dbn - BigInt(1));
                case UPLCTermTag_1.UPLCTermTag.Delay:
                    partialUPLC += "(delay ";
                    var delayed = readTerm();
                    partialUPLC += ")";
                    return new Delay_1.Delay(delayed);
                case UPLCTermTag_1.UPLCTermTag.Lambda:
                    partialUPLC += "(lam " + vars[currDbn] + ' ';
                    currDbn++;
                    var lamBody = readTerm();
                    currDbn--;
                    partialUPLC += ")";
                    return new Lambda_1.Lambda(lamBody);
                case UPLCTermTag_1.UPLCTermTag.Application:
                    partialUPLC += '[';
                    var appFn = readTerm();
                    partialUPLC += ' ';
                    var appArg = readTerm();
                    partialUPLC += ']';
                    return new Application_1.Application(appFn, appArg);
                case UPLCTermTag_1.UPLCTermTag.Const: return readConst();
                case UPLCTermTag_1.UPLCTermTag.Force:
                    partialUPLC += "(force ";
                    var forced = readTerm();
                    partialUPLC += ')';
                    if (forced instanceof Builtin_1.Builtin)
                        return forced;
                    if (forced instanceof Force_1.Force && forced.termToForce instanceof Builtin_1.Builtin)
                        return forced.termToForce;
                    return new Force_1.Force(forced);
                case UPLCTermTag_1.UPLCTermTag.Error:
                    partialUPLC += "(error)";
                    return new ErrorUPLC_1.ErrorUPLC(
                    //    "error got from deserialization;",
                    //    {
                    //        debruijnLevel: currDbn,
                    //        byteIndex: currByteIndex(),
                    //        bitIndex: currPtr
                    //    }
                    );
                case UPLCTermTag_1.UPLCTermTag.Builtin:
                    var bn_tag = Number(readNBits(7));
                    partialUPLC += "(builtin ".concat((0, UPLCBuiltinTag_1.builtinTagToString)(bn_tag), ")");
                    return new Builtin_1.Builtin(bn_tag);
                case UPLCTermTag_1.UPLCTermTag.Constr:
                    {
                        if (!isV3Friendly)
                            throw new Error("found 'constr' node in uplc version " + version.toString() +
                                "; lowest supported version is 1.1.0");
                        return new Constr_1.Constr(readUInt(), readTermList());
                    }
                    ;
                case UPLCTermTag_1.UPLCTermTag.Case:
                    {
                        if (!isV3Friendly)
                            throw new Error("found 'case' node in uplc version " + version.toString() +
                                "; lowest supported version is 1.1.0");
                        return new Case_1.Case(readTerm(), readTermList());
                    }
                    ;
                default: throw new Error("unknown tag: " + tag + "; partialUPLC == " + partialUPLC);
            }
        }
        function readTermList() {
            var list = [];
            for (var head = Number(readNBits(1)); head !== 0; head = Number(readNBits(1))) {
                list.push(readTerm());
            }
            return list;
        }
        function readConst() {
            logState();
            var constTy = readConstTy();
            if ((0, ConstType_1.constTypeEq)(constTy, ConstType_1.constT.bls12_381_G1_element) ||
                (0, ConstType_1.constTypeEq)(constTy, ConstType_1.constT.bls12_381_G2_element) ||
                (0, ConstType_1.constTypeEq)(constTy, ConstType_1.constT.bls12_381_MlResult))
                throw new Error("bls constants are not supported in serialized UPLC");
            var val = readConstValueOfType(constTy);
            partialUPLC += "( con ".concat((0, UPLCTerm_1.showConstType)(constTy), " ").concat((0, UPLCTerm_1.showUPLCConstValue)(val), " )");
            return new UPLCConst_1.UPLCConst(constTy, val);
        }
        function readConstTy() {
            var head = Number(readNBits(1));
            if (head === 0)
                throw new Error("empty const type");
            var tyTag;
            var type = [];
            do {
                tyTag = Number(readNBits(4));
                head = Number(readNBits(1));
                if (tyTag === 7)
                    continue;
                type.push(tyTag);
            } while (head !== 0);
            if (!(type.length > 0 &&
                (0, ConstType_1.isWellFormedConstType)(type)))
                throw new Error("invalid constant type");
            return type;
        }
        function readConstValueOfType(t) {
            if ((0, ConstType_1.constTypeEq)(t, ConstType_1.constT.int)) {
                return readSignedInt();
            }
            if ((0, ConstType_1.constTypeEq)(t, ConstType_1.constT.byteStr)) {
                readPadding();
                var hexChunks = [];
                var chunkLen = 1;
                while (chunkLen !== 0) {
                    chunkLen = Number(readNBits(8));
                    for (var i = 0; i < chunkLen; i++) {
                        hexChunks.push(readNBits(8).toString(16).padStart(2, '0'));
                    }
                }
                return new bytestring_1.ByteString((0, uint8array_utils_1.fromHex)(hexChunks.join("")));
            }
            if ((0, ConstType_1.constTypeEq)(t, ConstType_1.constT.str)) {
                return (0, uint8array_utils_1.toUtf8)(readConstValueOfType(ConstType_1.constT.byteStr).toBuffer());
            }
            if ((0, ConstType_1.constTypeEq)(t, ConstType_1.constT.data)) {
                var bytes = readConstValueOfType(ConstType_1.constT.byteStr).toBuffer();
                return (0, plutus_data_1.dataFromCbor)(bytes);
            }
            if ((0, ConstType_1.constTypeEq)(t, ConstType_1.constT.bool))
                return (Number(readNBits(1)) === 1);
            if ((0, ConstType_1.constTypeEq)(t, ConstType_1.constT.unit))
                return undefined;
            if (t[0] === ConstType_1.ConstTyTag.list) {
                var tyArg = ConstType_1.constListTypeUtils.getTypeArgument(t);
                var list = [];
                for (var head = Number(readNBits(1)); head !== 0; head = Number(readNBits(1))) {
                    list.push(readConstValueOfType(tyArg));
                }
                return list;
            }
            if (t[0] === ConstType_1.ConstTyTag.pair) {
                return new pair_1.Pair(readConstValueOfType(ConstType_1.constPairTypeUtils.getFirstTypeArgument(t)), readConstValueOfType(ConstType_1.constPairTypeUtils.getSecondTypeArgument(t)));
            }
            ;
            throw new Error("'readConstValueOfType': no constant type matched");
        }
        return new UPLCProgram_1.UPLCProgram(version, readTerm());
    };
    return UPLCDecoder;
}());
exports.UPLCDecoder = UPLCDecoder;
function parseUPLC(serializedScript, format, debugLogs) {
    if (format === void 0) { format = "cbor"; }
    if (debugLogs === void 0) { debugLogs = false; }
    return UPLCDecoder.parse(serializedScript, format, debugLogs);
}
exports.parseUPLC = parseUPLC;
