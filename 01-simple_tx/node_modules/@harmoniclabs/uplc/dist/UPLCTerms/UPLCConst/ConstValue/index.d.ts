import { ByteString } from "@harmoniclabs/bytestring";
import { Pair } from "@harmoniclabs/pair";
import { Data } from "@harmoniclabs/plutus-data";
import { ConstType } from "../ConstType/index.js";
import { BlsG1, BlsG2, BlsResult } from "@harmoniclabs/crypto";
export type ConstValueList = (number | bigint)[] | ByteString[] | string[] | undefined[] | ConstValueList[] | Pair<ConstValue, ConstValue>[] | Data[] | BlsG1[] | BlsG2[] | BlsResult[];
export type ConstValue = number | bigint | ByteString | string | undefined | boolean | ConstValueList | Pair<ConstValue, ConstValue> | Data | BlsG1 | BlsG2 | BlsResult;
export declare function isConstValueInt(n: any): n is (number | bigint);
export declare function isConstValue(value: any): value is ConstValue;
export declare function eqConstValue(a: ConstValue, b: ConstValue): boolean;
/**
 *
 * @param val
 * @returns the type of the ```ConstValue``` input ```undefined``` if it is not possible to infer the type ( eg. [] :: list ? )
 */
export declare function inferConstTypeFromConstValue(val: ConstValue): (ConstType | undefined);
/**
 * same as ```inferConstTypeFromConstValue``` but with a default Type if it is not possible to infer
 */
export declare function inferConstTypeFromConstValueOrDefault(value: ConstValue, defaultTy: ConstType): ConstType;
export declare function canConstValueBeOfConstType(val: Readonly<ConstValue>, ty: Readonly<ConstType>): boolean;
export declare function isConstValueList(val: any): val is ConstValueList;
