"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isConstValueList = exports.canConstValueBeOfConstType = exports.inferConstTypeFromConstValueOrDefault = exports.inferConstTypeFromConstValue = exports.eqConstValue = exports.isConstValue = exports.isConstValueInt = void 0;
var bytestring_1 = require("@harmoniclabs/bytestring");
var pair_1 = require("@harmoniclabs/pair");
var plutus_data_1 = require("@harmoniclabs/plutus-data");
var ConstType_1 = require("../ConstType/index.js");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var assert_1 = require("../../../utils/assert.js");
var crypto_1 = require("@harmoniclabs/crypto");
function isConstValueInt(n) {
    return (typeof n === "bigint" ||
        (typeof n === "number" && Number.isSafeInteger(n)));
}
exports.isConstValueInt = isConstValueInt;
function isConstValue(value) {
    return (value === undefined ||
        isConstValueInt(value) ||
        (value instanceof bytestring_1.ByteString && bytestring_1.ByteString.isStrictInstance(value)) ||
        typeof value === "string" ||
        typeof value === "boolean" ||
        isConstValueList(value) ||
        (pair_1.Pair.isStrictInstance(value) &&
            isConstValue(value.fst) && isConstValue(value.snd)) ||
        (0, plutus_data_1.isData)(value) ||
        (0, crypto_1.isBlsG1)(value) ||
        (0, crypto_1.isBlsG2)(value) ||
        (0, crypto_1.isBlsResult)(value));
}
exports.isConstValue = isConstValue;
function eqConstValue(a, b) {
    if (a === undefined)
        return b === undefined;
    if (!(isConstValue(a) ||
        isConstValue(b)))
        return false;
    if ((typeof a === "number" || typeof a == "bigint"))
        return ((typeof b === "number" || typeof b == "bigint") &&
            BigInt(a) === BigInt(b));
    if (a instanceof bytestring_1.ByteString)
        return (b instanceof bytestring_1.ByteString &&
            (0, uint8array_utils_1.uint8ArrayEq)(a.toBuffer(), b.toBuffer()));
    if (typeof a === "string")
        return (typeof b === "string" &&
            a === b);
    if (typeof a === "boolean")
        return (typeof b === "boolean" &&
            (a === b));
    if ((0, crypto_1.isBlsG1)(a))
        return (0, crypto_1.isBlsG1)(b) && (0, crypto_1.bls12_381_G1_equal)(a, b);
    if ((0, crypto_1.isBlsG2)(a))
        return (0, crypto_1.isBlsG2)(b) && (0, crypto_1.bls12_381_G2_equal)(a, b);
    if ((0, crypto_1.isBlsResult)(a))
        return (0, crypto_1.isBlsResult)(b) && (0, crypto_1.bls12_381_eqMlResult)(a, b);
    if ((0, plutus_data_1.isData)(a))
        return ((0, plutus_data_1.isData)(b) && (0, plutus_data_1.eqData)(a, b));
    if (a instanceof pair_1.Pair)
        return (b instanceof pair_1.Pair &&
            eqConstValue(a.fst, b.fst) &&
            eqConstValue(a.snd, b.snd));
    if (Array.isArray(a))
        return (Array.isArray(b) &&
            a.length === b.length &&
            a.every(function (v, i) { return eqConstValue(v, b[i]); }));
    return false;
}
exports.eqConstValue = eqConstValue;
// mutually recursive on arrays (list values)
// inferConstTypeFromConstValue -> isConstValue -> isConstValueList (on list element) -> inferConstTypeFromConstValue
/**
 *
 * @param val
 * @returns the type of the ```ConstValue``` input ```undefined``` if it is not possible to infer the type ( eg. [] :: list ? )
 */
function inferConstTypeFromConstValue(val) {
    (0, assert_1.assert)(isConstValue(val), "'inferConstTypeFromConstValue' expects a valid 'ConstValue' type, input was: " + val);
    if (val === undefined)
        return ConstType_1.constT.unit;
    if (isConstValueInt(val))
        return ConstType_1.constT.int;
    if (val instanceof bytestring_1.ByteString && bytestring_1.ByteString.isStrictInstance(val))
        return ConstType_1.constT.byteStr;
    if (typeof val === "string")
        return ConstType_1.constT.str;
    if (typeof val === "boolean")
        return ConstType_1.constT.bool;
    if ((0, crypto_1.isBlsG1)(val))
        return ConstType_1.constT.bls12_381_G1_element;
    if ((0, crypto_1.isBlsG2)(val))
        return ConstType_1.constT.bls12_381_G2_element;
    if ((0, crypto_1.isBlsResult)(val))
        return ConstType_1.constT.bls12_381_MlResult;
    if (Array.isArray(val)) {
        if (val.length === 0)
            return undefined;
        var firstElemTy_1 = undefined;
        for (var i = 0; i < val.length && firstElemTy_1 === undefined; i++) {
            firstElemTy_1 = inferConstTypeFromConstValue(val[i]);
        }
        if (firstElemTy_1 === undefined)
            return undefined;
        (0, assert_1.assert)(val.every(function (listElem) { return canConstValueBeOfConstType(listElem, firstElemTy_1); }), "'inferConstTypeFromConstValue': incongruent elements of constant list");
        return ConstType_1.constT.listOf(firstElemTy_1);
    }
    if (val instanceof pair_1.Pair && pair_1.Pair.isStrictInstance(val)) {
        var fstTy = inferConstTypeFromConstValue(val.fst);
        if (fstTy === undefined)
            return undefined;
        var sndTy = inferConstTypeFromConstValue(val.snd);
        if (sndTy === undefined)
            return undefined;
        return ConstType_1.constT.pairOf(fstTy, sndTy);
    }
    if ((0, plutus_data_1.isData)(val))
        return ConstType_1.constT.data;
    throw new Error("'inferConstTypeFromConstValue' did not match any possible value");
}
exports.inferConstTypeFromConstValue = inferConstTypeFromConstValue;
/**
 * same as ```inferConstTypeFromConstValue``` but with a default Type if it is not possible to infer
 */
function inferConstTypeFromConstValueOrDefault(value, defaultTy) {
    var _a;
    var inferredTy = inferConstTypeFromConstValue(value);
    if (inferredTy !== undefined) {
        return inferredTy;
    }
    // it was not possible to infer the value;
    // assert the provided default can actually have values
    (0, assert_1.assert)((0, ConstType_1.isWellFormedConstType)(defaultTy), "the provided 'defaultTy' is not a well formed constant type; try using the exported 'constT' object to be sure it is well formed");
    // assert the default type is ok for the provided value
    (0, assert_1.assert)(canConstValueBeOfConstType(value, defaultTy), "the provided default ConstType is not adeguate for the provided ConstValue, given inputs: [ " +
        ((_a = value === null || value === void 0 ? void 0 : value.toString()) !== null && _a !== void 0 ? _a : "undefined") + " , " +
        (0, ConstType_1.constTypeToStirng)(defaultTy) + " ]");
    return defaultTy;
}
exports.inferConstTypeFromConstValueOrDefault = inferConstTypeFromConstValueOrDefault;
function canConstValueBeOfConstType(val, ty) {
    if (!(0, ConstType_1.isWellFormedConstType)(ty))
        return false;
    if ((0, ConstType_1.constTypeEq)(ty, ConstType_1.constT.unit))
        return val === undefined;
    if ((0, ConstType_1.constTypeEq)(ty, ConstType_1.constT.bool))
        return typeof val === "boolean";
    if ((0, ConstType_1.constTypeEq)(ty, ConstType_1.constT.byteStr))
        return (val instanceof bytestring_1.ByteString && bytestring_1.ByteString.isStrictInstance(val));
    if ((0, ConstType_1.constTypeEq)(ty, ConstType_1.constT.data))
        return val === undefined ? false : (0, plutus_data_1.isData)(val);
    if ((0, ConstType_1.constTypeEq)(ty, ConstType_1.constT.int))
        return isConstValueInt(val);
    if ((0, ConstType_1.constTypeEq)(ty, ConstType_1.constT.str))
        return typeof val === "string";
    if ((0, ConstType_1.constTypeEq)(ty, ConstType_1.constT.bls12_381_G1_element))
        return (0, crypto_1.isBlsG1)(val);
    if ((0, ConstType_1.constTypeEq)(ty, ConstType_1.constT.bls12_381_G2_element))
        return (0, crypto_1.isBlsG2)(val);
    if ((0, ConstType_1.constTypeEq)(ty, ConstType_1.constT.bls12_381_MlResult))
        return (0, crypto_1.isBlsResult)(val);
    if (ty[0] === ConstType_1.ConstTyTag.list)
        return (Array.isArray(val) &&
            val.every(function (valueElement) {
                return canConstValueBeOfConstType(valueElement, ConstType_1.constListTypeUtils.getTypeArgument(ty));
            }));
    if (ty[0] === ConstType_1.ConstTyTag.pair)
        return (val instanceof pair_1.Pair && pair_1.Pair.isStrictInstance(val) &&
            canConstValueBeOfConstType(val.fst, ConstType_1.constPairTypeUtils.getFirstTypeArgument(ty)) &&
            canConstValueBeOfConstType(val.snd, ConstType_1.constPairTypeUtils.getSecondTypeArgument(ty)));
    throw new Error("'canConstValueBeOfConstType' did not match any type tag");
}
exports.canConstValueBeOfConstType = canConstValueBeOfConstType;
function isConstValueList(val) {
    if (!Array.isArray(val))
        return false;
    // [] is a valid value for any list type
    if (val.length === 0)
        return true;
    var firstElemTy = undefined;
    for (var i = 0; i < val.length && firstElemTy === undefined; i++) {
        firstElemTy = inferConstTypeFromConstValue(val[i]);
    }
    function isArrayOfEmptyArray(arr) {
        if (!Array.isArray(arr))
            return false;
        return arr.every(function (elem) { return Array.isArray(elem) && elem.length === 0 || isArrayOfEmptyArray(elem); });
    }
    if (firstElemTy === undefined) {
        return isArrayOfEmptyArray(val);
    }
    return val.every(function (listElem) { return canConstValueBeOfConstType(listElem, firstElemTy); });
}
exports.isConstValueList = isConstValueList;
