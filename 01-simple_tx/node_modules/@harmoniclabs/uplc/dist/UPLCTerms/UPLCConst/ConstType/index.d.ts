export declare enum ConstTyTag {
    int = 0,
    byteStr = 1,
    str = 2,
    unit = 3,
    bool = 4,
    list = 5,
    pair = 6,
    data = 8,
    /** NEVER ENCODED; still needed for plutus-machine values */
    bls12_381_G1_element = 9,
    bls12_381_G2_element = 10,
    bls12_381_MlResult = 11
}
/**
 * defined as:
 * ```ts
 * type ConstType = ConsTyTag[]
 * ```
 *
 * >**_NOTE:_** the definition used doen't ensures for type correctness
 * > in order to be sure a given ```ConstType``` is valid ```isWellFormedConstType``` (exported in the same module) should still be used
 *
 * >**_PRO TIP:_** to ensure a ```ConstType``` to be created correctly
 * > you should use the ```constT``` object and build a ```ConstType``` only using the object fields
 * > for reference here's the ```constT``` object definition:
 * > ```ts
 * > const constT : Readonly<{
 * >     int: ConstType,
 * >     byteStr: ConstType,
 * >     str: ConstType,
 * >     unit: ConstType
 * >     bool: ConstType
 * >     listOf: ( tyArg: ConstType ) => ConstType
 * >     pairOf: ( tyArg1: ConstType, tyArg2: ConstType ) => ConstType
 * >     data: ConstType
 * >     bls12_381_G1_element: ConstType
 * >     bls12_381_G2_element: ConstType
 * >     bls12_381_MlResult: ConstType
 * > }>
 * > ```
 *
*/
export type ConstType = [ConstTyTag, ...ConstTyTag[]];
export declare function isWellFormedConstType(type: any): type is ConstType;
/**
 * **does NOT require the types to be well-formed**
 *
 * merly checks to have the same tags at the same place
 */
export declare function constTypeEq(a: Readonly<ConstType>, b: Readonly<ConstType>): boolean;
/**
 * well formed types
 */
export declare const constT: Readonly<{
    int: ConstType;
    byteStr: ConstType;
    str: ConstType;
    unit: ConstType;
    bool: ConstType;
    listOf: (tyArg: ConstType) => [ConstTyTag.list, ...ConstType];
    pairOf: (tyArg1: ConstType, tyArg2: ConstType) => [ConstTyTag.pair, ...ConstType, ...ConstType];
    data: ConstType;
    bls12_381_G1_element: ConstType;
    bls12_381_G2_element: ConstType;
    bls12_381_MlResult: ConstType;
}>;
export declare function isConstTypeTag(constTy: Readonly<ConstTyTag>): boolean;
export type ConstTyTagString = "integer" | "bytestring" | "string" | "unit" | "boolean" | "list" | "pair" | "data" | "bls12_381_G1_element" | "bls12_381_G2_element" | "bls12_381_MlResult";
export declare function constTypeTagToStirng(ty: Readonly<ConstTyTag>): ConstTyTagString;
export declare function constTypeToStirng(ty: ConstType): string;
declare function getConstListTypeArgument(listTy: [ConstTyTag.list, ...ConstType]): ConstType;
declare function getNonWellFormedConstListTypeArgument(listTy: [ConstTyTag.list, ...ConstType]): (ConstType | undefined);
export declare const constListTypeUtils: Readonly<{
    getTypeArgument: typeof getConstListTypeArgument;
    nonWellFormed: Readonly<{
        /**
         *
         * @param listTy
         * @returns
         *      ```undefined``` only if the type argument was not complete
         *      returns the sliced type argument if too many where provided
         *      same of ```constListTypeUtils.getTypeArgument``` if the type argument was well formed
         */
        getNonWellFormedTypeArgument: typeof getNonWellFormedConstListTypeArgument;
    }>;
}>;
declare function getConstPairFirstTypeArgument(pairTy: [ConstTyTag.pair, ...ConstType] | ConstType): ConstType;
declare function getConstPairSecondTypeArgument(pairTy: [ConstTyTag.pair, ...ConstType] | ConstType): ConstType;
declare function getNonWellFormedConstPairFirstTypeArgument(pairTy: [ConstTyTag.pair, ...ConstType] | ConstType): (ConstType | undefined);
declare function getNonWellFormedConstPairSecondTypeArgument(pairTy: [ConstTyTag.pair, ...ConstType] | ConstType): (ConstType | undefined);
export declare const constPairTypeUtils: Readonly<{
    getFirstTypeArgument: typeof getConstPairFirstTypeArgument;
    getSecondTypeArgument: typeof getConstPairSecondTypeArgument;
    nonWellFormed: Readonly<{
        /**
         *
         * @param listTy
         * @returns
         *      ```undefined``` only if the type argument was not complete
         *      returns the sliced type argument if too many where provided
         *      same of ```constPairTypeUtils.getFirstTypeArgument``` if the type argument was well formed
         */
        getFirstTypeArgument: typeof getNonWellFormedConstPairFirstTypeArgument;
        /**
         *
         * @param listTy
         * @returns
         *      ```undefined``` only if the type argument was not complete
         *      returns the sliced type argument if too many where provided
         *      same of ```constPairTypeUtils.getSecondTypeArgument``` if the type argument was well formed
         */
        getSecondTypeArgument: typeof getNonWellFormedConstPairSecondTypeArgument;
    }>;
}>;
export {};
