"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.constPairTypeUtils = exports.constListTypeUtils = exports.constTypeToStirng = exports.constTypeTagToStirng = exports.isConstTypeTag = exports.constT = exports.constTypeEq = exports.isWellFormedConstType = exports.ConstTyTag = void 0;
var assert_1 = require("../../../utils/assert.js");
var ConstTyTag;
(function (ConstTyTag) {
    ConstTyTag[ConstTyTag["int"] = 0] = "int";
    ConstTyTag[ConstTyTag["byteStr"] = 1] = "byteStr";
    ConstTyTag[ConstTyTag["str"] = 2] = "str";
    ConstTyTag[ConstTyTag["unit"] = 3] = "unit";
    ConstTyTag[ConstTyTag["bool"] = 4] = "bool";
    ConstTyTag[ConstTyTag["list"] = 5] = "list";
    ConstTyTag[ConstTyTag["pair"] = 6] = "pair";
    // tyApp = 7, // only used internally for types like list and pair
    ConstTyTag[ConstTyTag["data"] = 8] = "data";
    /** NEVER ENCODED; still needed for plutus-machine values */
    ConstTyTag[ConstTyTag["bls12_381_G1_element"] = 9] = "bls12_381_G1_element";
    ConstTyTag[ConstTyTag["bls12_381_G2_element"] = 10] = "bls12_381_G2_element";
    ConstTyTag[ConstTyTag["bls12_381_MlResult"] = 11] = "bls12_381_MlResult";
})(ConstTyTag = exports.ConstTyTag || (exports.ConstTyTag = {}));
function isWellFormedConstType(type /*ConstType | ConstTyTag[]*/) {
    if (!Array.isArray(type))
        return false;
    if (type.length === 0)
        return false;
    if (!type.every(isConstTypeTag))
        return false;
    if (type[0] !== ConstTyTag.list &&
        type[0] !== ConstTyTag.pair)
        return (type.length === 1);
    // keeps track of the missing terms to provide as argument
    // well formed types from this point must start with either 'ConstTyTag.list' of 'ConstTyTag.pair'
    // in any case the stack must count that tag as top level
    var stack = [1];
    if (type[0] !== ConstTyTag.list &&
        type[0] !== ConstTyTag.pair) {
        // returning false anyway, type has too many arguments, not well-formed
        return false;
    }
    function topStackMinusOne() {
        (0, assert_1.assert)(stack.length > 0, new Error("while calling 'topStackMinusOne' in 'ConstEmptyList._isWellFormedListType'; stack was empty"));
        var missingTyArgsToProvide = stack[stack.length - 1] - 1;
        if (missingTyArgsToProvide < 0) {
            throw new Error("while checking for type correctness in empty constant list; stack element was less than 0");
        }
        stack[stack.length - 1] = missingTyArgsToProvide;
    }
    for (var i = 0; i < type.length; i++) {
        var ty = type[i];
        if (ty === ConstTyTag.list) {
            if (!((i + 1) < type.length))
                return false;
            topStackMinusOne();
            stack.push(1); // add new layer
        }
        else if (ty === ConstTyTag.pair) {
            if (!((i + 2) < type.length))
                return false;
            topStackMinusOne();
            stack.push(2); // add new layer for pair
        }
        else {
            topStackMinusOne(); // got an argument
        }
        // clear fulfilled layers
        while (stack.length > 0 &&
            stack[stack.length - 1] === 0) {
            stack.pop(); // clear layer
        }
        if ( // if
        stack.length === 0 && // stack is empty
            i !== (type.length - 1) // and we are not at the end of the type
        ) {
            return false; // addtional types provided
        }
        if ( // if
        i === (type.length - 1) && // we are at the end of the type
            stack.length !== 0 // and the stack expects some more arguments
        ) {
            return false; // missing some arguments
        }
    }
    return true;
}
exports.isWellFormedConstType = isWellFormedConstType;
/**
 * **does NOT require the types to be well-formed**
 *
 * merly checks to have the same tags at the same place
 */
function constTypeEq(a, b) {
    if (a.length !== b.length)
        return false;
    return a.every(function (tyTag, i) { return tyTag === b[i]; });
}
exports.constTypeEq = constTypeEq;
/**
 * well formed types
 */
exports.constT = Object.freeze({
    int: Object.freeze([ConstTyTag.int]),
    byteStr: Object.freeze([ConstTyTag.byteStr]),
    str: Object.freeze([ConstTyTag.str]),
    unit: Object.freeze([ConstTyTag.unit]),
    bool: Object.freeze([ConstTyTag.bool]),
    listOf: function (tyArg) {
        (0, assert_1.assert)(isWellFormedConstType(tyArg), "provided argument to 'constT.listOf' should be a well formed type, try using types exposed by  the 'constT' object itself");
        return Object.freeze(__spreadArray([ConstTyTag.list], __read(tyArg), false));
    },
    pairOf: function (tyArg1, tyArg2) {
        (0, assert_1.assert)(isWellFormedConstType(tyArg1) && isWellFormedConstType(tyArg2), "provided argument to 'constT.pairOf' should be a well formed type, try using types exposed by  the 'constT' object itself");
        return Object.freeze(__spreadArray(__spreadArray([ConstTyTag.pair], __read(tyArg1), false), __read(tyArg2), false));
    },
    data: Object.freeze([ConstTyTag.data]),
    bls12_381_G1_element: Object.freeze([ConstTyTag.bls12_381_G1_element]),
    bls12_381_G2_element: Object.freeze([ConstTyTag.bls12_381_G2_element]),
    bls12_381_MlResult: Object.freeze([ConstTyTag.bls12_381_MlResult])
});
function isConstTypeTag(constTy) {
    constTy = constTy;
    return (constTy === ConstTyTag.int ||
        constTy === ConstTyTag.byteStr ||
        constTy === ConstTyTag.str ||
        constTy === ConstTyTag.unit ||
        constTy === ConstTyTag.bool ||
        constTy === ConstTyTag.list ||
        constTy === ConstTyTag.pair ||
        // (constTyTag as number) === 7   || // uncomment if tyApp should be considered
        constTy === ConstTyTag.data ||
        constTy === ConstTyTag.bls12_381_G1_element ||
        constTy === ConstTyTag.bls12_381_G2_element ||
        constTy === ConstTyTag.bls12_381_MlResult);
}
exports.isConstTypeTag = isConstTypeTag;
function constTypeTagToStirng(ty) {
    switch (ty) {
        case ConstTyTag.int: return "integer";
        case ConstTyTag.byteStr: return "bytestring";
        case ConstTyTag.str: return "string";
        case ConstTyTag.unit: return "unit";
        case ConstTyTag.bool: return "boolean";
        case ConstTyTag.list: return "list";
        case ConstTyTag.pair: return "pair";
        case ConstTyTag.data: return "data";
        case ConstTyTag.bls12_381_G1_element: return "bls12_381_G1_element";
        case ConstTyTag.bls12_381_G2_element: return "bls12_381_G2_element";
        case ConstTyTag.bls12_381_MlResult: return "bls12_381_MlResult";
        default:
            throw new Error("'constTypeTAgToStirng' is supposed to have a member of the 'ConstTy' enum as input but got: " + ty);
    }
}
exports.constTypeTagToStirng = constTypeTagToStirng;
function constTypeToStirng(ty) {
    return ty.map(constTypeTagToStirng).join(' ');
}
exports.constTypeToStirng = constTypeToStirng;
// -------------------------------------------------- ConstListType Utils -------------------------------------------------- //
function getConstListTypeArgument(listTy) {
    (0, assert_1.assert)(listTy.length > 0 && listTy[0] === ConstTyTag.list && isWellFormedConstType(listTy), "in 'constListTypeUtils.getTypeArgument', input type was not a valid list type");
    return listTy.slice(1);
}
;
function getNonWellFormedConstListTypeArgument(listTy) {
    (0, assert_1.assert)(listTy.length > 0 && listTy[0] === ConstTyTag.list, "in 'constListTypeUtils.getTypeArgument', input type was not a valid list type");
    var rawArg = listTy.slice(1);
    if (rawArg.length === 0)
        return undefined;
    if (isWellFormedConstType(rawArg))
        return rawArg;
    if (rawArg[0] !== ConstTyTag.list &&
        rawArg[0] !== ConstTyTag.pair) {
        return [rawArg[0]];
    }
    if (rawArg[0] === ConstTyTag.list) {
        var tyArgOfList = getNonWellFormedConstListTypeArgument(rawArg);
        if (tyArgOfList === undefined)
            return undefined;
        return __spreadArray([ConstTyTag.list], __read(tyArgOfList), false);
    }
    if (rawArg[0] === ConstTyTag.pair) {
        var firstArg = getNonWellFormedConstPairFirstTypeArgument(rawArg);
        if (firstArg === undefined) {
            return undefined;
        }
        var secondArg = getNonWellFormedConstPairSecondTypeArgument(rawArg);
        if (secondArg === undefined) {
            return undefined;
        }
        return exports.constT.pairOf(firstArg, secondArg);
    }
}
exports.constListTypeUtils = Object.freeze({
    getTypeArgument: getConstListTypeArgument,
    nonWellFormed: Object.freeze({
        /**
         *
         * @param listTy
         * @returns
         *      ```undefined``` only if the type argument was not complete
         *      returns the sliced type argument if too many where provided
         *      same of ```constListTypeUtils.getTypeArgument``` if the type argument was well formed
         */
        getNonWellFormedTypeArgument: getNonWellFormedConstListTypeArgument,
    }),
});
// -------------------------------------------------- ConstPairType Utils -------------------------------------------------- //
function getConstPairFirstTypeArgument(pairTy) {
    (0, assert_1.assert)(pairTy.length > 0 && pairTy[0] === ConstTyTag.pair && isWellFormedConstType(pairTy), "in 'constPairTypeUtils.getFirstTypeArgument', input type was not a valid pair type");
    var rawArg = pairTy.slice(1);
    if (rawArg.length === 0) {
        throw new Error("'pairTy' was supposed to be well formed but is missing arguments for 'ConstTyTag.pair'");
    }
    if (rawArg[0] !== ConstTyTag.list &&
        rawArg[0] !== ConstTyTag.pair) {
        // argument takes no more arguments
        return [pairTy[1]];
    }
    if (rawArg[0] === ConstTyTag.list) {
        // non well formed in order to ignore the second argument
        var listTyArg = getNonWellFormedConstListTypeArgument(rawArg);
        if (listTyArg === undefined) {
            throw new Error("in 'getConstPairFirstTypeArgument' (exported as 'constPairTypeUtils.getFirstTypeArgument'); " +
                "'listTyArg' was expected to be a well formed type but was missing some arguments to be well formed; " +
                "this case sould have trown while checking for the 'pairTy' to be well formed");
        }
        return __spreadArray([ConstTyTag.list], __read(listTyArg), false);
    }
    if (rawArg[0] === ConstTyTag.pair) {
        var firstArg = getNonWellFormedConstPairFirstTypeArgument(rawArg);
        if (firstArg === undefined) {
            throw new Error("in 'getConstPairFirstTypeArgument'; " +
                "'firstArg' was expected to be a well formed type but was missing some arguments to be well formed; " +
                "this case sould have trown while checking for the 'pairTy' to be well formed");
        }
        var secondArg = getNonWellFormedConstPairSecondTypeArgument(rawArg);
        if (secondArg === undefined) {
            throw new Error("in 'getConstPairFirstTypeArgument'; " +
                "'secondArg' was expected to be a well formed type but was missing some arguments to be well formed; " +
                "this case sould have trown while checking for the 'pairTy' to be well formed");
        }
        return exports.constT.pairOf(firstArg, secondArg);
    }
    throw new Error("unexpected execution flow; 'getConstPairFirstTypeArgument' did not match any `ConstTyTag` as first argument");
}
function getConstPairSecondTypeArgument(pairTy) {
    /*
    assert(
        pairTy.length > 0 && pairTy[0] === ConstTyTag.pair && isWellFormedConstType( pairTy ),
        "in 'constPairTypeUtils.getFirstTypeArgument', input type was not a valid pair type"
    );*/ // made in the 'getConstPairFirstTypeArgument'call
    // if pairTy is not well formed throws
    // if doesn't throw is well formed
    // if it is well formed the sliced part is the well formed type
    return pairTy.slice(1 + getConstPairFirstTypeArgument(pairTy).length);
}
function getNonWellFormedConstPairFirstTypeArgument(pairTy) {
    (0, assert_1.assert)(pairTy.length > 0 && pairTy[0] === ConstTyTag.pair, "in 'constPairTypeUtils.getFirstTypeArgument', input type was not a valid pair type");
    var rawArg = pairTy.slice(1);
    // at least two tags mus follow in order to be fulfilled
    if (rawArg.length < 2) {
        return undefined;
    }
    if (rawArg[0] !== ConstTyTag.list &&
        rawArg[0] !== ConstTyTag.pair) {
        // argument takes no more arguments
        return [pairTy[1]];
    }
    if (rawArg[0] === ConstTyTag.list) {
        // non well formed in order to ignore the second argument
        var listTyArg = getNonWellFormedConstListTypeArgument(rawArg);
        if (listTyArg === undefined)
            return undefined;
        return __spreadArray([ConstTyTag.list], __read(listTyArg), false);
    }
    if (rawArg[0] === ConstTyTag.pair) {
        var firstArg = getNonWellFormedConstPairFirstTypeArgument(rawArg);
        if (firstArg === undefined) {
            return undefined;
        }
        var secondArg = getNonWellFormedConstPairSecondTypeArgument(rawArg);
        if (secondArg === undefined) {
            return undefined;
        }
        return exports.constT.pairOf(firstArg, secondArg);
    }
    throw new Error("unexpected execution flow; 'getNonWellFormedConstPairFirstTypeArgument' did not match any `ConstTyTag` as first argument");
}
function getNonWellFormedConstPairSecondTypeArgument(pairTy) {
    /*
    assert(
        pairTy.length > 0 && pairTy[0] === ConstTyTag.pair,
        "in 'constPairTypeUtils.getFirstTypeArgument', input type was not a valid pair type"
    );
    */ // made in the 'getNonWellFormedConstPairFirstTypeArgument' call
    var pairFirstTyArg = getNonWellFormedConstPairFirstTypeArgument(pairTy);
    if (pairFirstTyArg === undefined)
        return undefined;
    var rawSecondArg = pairTy.slice(1 + pairFirstTyArg.length);
    if (rawSecondArg.length === 0)
        return undefined;
    if (rawSecondArg[0] !== ConstTyTag.list &&
        rawSecondArg[0] !== ConstTyTag.pair) {
        // argument takes no more arguments
        return [rawSecondArg[0]];
    }
    if (rawSecondArg[0] === ConstTyTag.list) {
        // non well formed in order to ignore the second argument
        var listTyArg = getNonWellFormedConstListTypeArgument(rawSecondArg);
        if (listTyArg === undefined)
            return undefined;
        return __spreadArray([ConstTyTag.list], __read(listTyArg), false);
    }
    if (rawSecondArg[0] === ConstTyTag.pair) {
        var firstArg = getNonWellFormedConstPairFirstTypeArgument(rawSecondArg);
        if (firstArg === undefined) {
            return undefined;
        }
        var secondArg = getNonWellFormedConstPairSecondTypeArgument(rawSecondArg);
        if (secondArg === undefined) {
            return undefined;
        }
        return exports.constT.pairOf(firstArg, secondArg);
    }
    throw new Error("unexpected execution flow; 'getNonWellFormedConstPairFirstTypeArgument' did not match any `ConstTyTag` as first argument");
}
exports.constPairTypeUtils = Object.freeze({
    getFirstTypeArgument: getConstPairFirstTypeArgument,
    getSecondTypeArgument: getConstPairSecondTypeArgument,
    nonWellFormed: Object.freeze({
        /**
         *
         * @param listTy
         * @returns
         *      ```undefined``` only if the type argument was not complete
         *      returns the sliced type argument if too many where provided
         *      same of ```constPairTypeUtils.getFirstTypeArgument``` if the type argument was well formed
         */
        getFirstTypeArgument: getNonWellFormedConstPairFirstTypeArgument,
        /**
         *
         * @param listTy
         * @returns
         *      ```undefined``` only if the type argument was not complete
         *      returns the sliced type argument if too many where provided
         *      same of ```constPairTypeUtils.getSecondTypeArgument``` if the type argument was well formed
         */
        getSecondTypeArgument: getNonWellFormedConstPairSecondTypeArgument
    }),
});
