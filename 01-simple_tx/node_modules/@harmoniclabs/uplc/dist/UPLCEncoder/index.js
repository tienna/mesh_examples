"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeUPLC = exports.compileUPLC = exports.UPLCEncoder = exports.serializeBuiltin = void 0;
var ConstType_1 = require("../UPLCTerms/UPLCConst/ConstType/index.js");
var ConstValue_1 = require("../UPLCTerms/UPLCConst/ConstValue/index.js");
var UPLCBuiltinTag_1 = require("../UPLCTerms/Builtin/UPLCBuiltinTag.js");
var UPLCTerm_1 = require("../UPLCTerm/UPLCTerm.js");
var Application_1 = require("../UPLCTerms/Application.js");
var Builtin_1 = require("../UPLCTerms/Builtin/Builtin.js");
var UPLCConst_1 = require("../UPLCTerms/UPLCConst/UPLCConst.js");
var Delay_1 = require("../UPLCTerms/Delay.js");
var ErrorUPLC_1 = require("../UPLCTerms/ErrorUPLC.js");
var Force_1 = require("../UPLCTerms/Force.js");
var Lambda_1 = require("../UPLCTerms/Lambda.js");
var UPLCVar_1 = require("../UPLCTerms/UPLCVar/index.js");
var UPLCSerializationContext_1 = require("./UPLCSerializationContext.js");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var bitstream_1 = require("@harmoniclabs/bitstream");
var bytestring_1 = require("@harmoniclabs/bytestring");
var cbor_1 = require("@harmoniclabs/cbor");
var pair_1 = require("@harmoniclabs/pair");
var plutus_data_1 = require("@harmoniclabs/plutus-data");
var UPLCFlatUtils_1 = __importDefault(require("../utils/UPLCFlatUtils/index.js"));
var assert_1 = require("../utils/assert.js");
var Constr_1 = require("../UPLCTerms/Constr.js");
var Case_1 = require("../UPLCTerms/Case.js");
var crypto_1 = require("@harmoniclabs/crypto");
/*
 * --------------------------- [encode vs serialize methods] ---------------------------
 *
 *  in the ```UPLCEncoder``` class are present various methods of which name starts with "encode" or "serialize"
 *  directly followed by the type of the expected argument.
 *
 *  all the "serialize" functions are **PURE**; meaning given the expected input those will return the output without executing side-effects;
 *
 *  all the "encode" methods have the side effect to update the context before and always return the equivalent of the "serialize" counterpart;
 *
 *  for this reason, when it is common the pattern
 *  ```ts
 *  encode( uplcObj: UPLC ): BitStream
 *  {
 *      const serialized = serilize( uplcObj );
 *      this._ctx.incrementLengthBy( serialized.length );
 *      return serialized;
 *  }
 *  ```
*/
function serializeUInt(uint) {
    return UPLCFlatUtils_1.default.encodeBigIntAsVariableLengthBitStream(BigInt(uint));
}
function serializeInt(int) {
    (0, assert_1.assert)(typeof int === "number" || typeof int === "bigint", "'serializeInt' only works for Signed Integer; " +
        "try using int.toSigned() if you are using a derived class; inpout was: " + int);
    int = typeof int === "number" ? BigInt(int) : int;
    return serializeUInt(UPLCFlatUtils_1.default.zigzagBigint(int));
}
function serializeVersion(version) {
    var result = serializeUInt(version.major);
    result.append(serializeUInt(version.minor));
    result.append(serializeUInt(version.patch));
    return result;
}
function serializeUPLCVar(uplcVar) {
    var result = UPLCVar_1.UPLCVar.UPLCTag;
    result.append(serializeUInt(
    // no idea why deBruijn indicies start form 1...s
    // can devs do something?
    uplcVar.deBruijn + BigInt(1)));
    return result;
}
function serializeConstType(type) {
    (0, assert_1.assert)((0, ConstType_1.isWellFormedConstType)(type), "cannot serialize an UPLC constant type if it is not well formed");
    /**
     *
     * Source: plutus-core-specification-june2022.pdf; section D.3.3; page 31
     *
     *  We define the encoder and decoder for types by combining ùñæ ùóçùóíùóâùñæ and ùñΩ ùóçùóíùóâùñæ with ùñ§
     *  and decoder for lists of four-bit integers (see Section D.2).
     *
     * Section D.2 ( D.2.2 )
     *
     * Suppose that we have a set ùëã for which we have defined an encoder ùñ§ ùëã and a decoder ùñ£ ùëã ; we define an
‚Éñ‚Éó     * ùëã which encodes lists of elements of ùëã by emitting the encodings of the elements of the list,
     * encoder ùñ§
     * **each preceded by a ùü∑ bit, then emitting a ùü∂ bit to mark the end of the list.**
     *
     */
    function _serializeConstTyTagToUPLCBinaryString(typeTag) {
        if (typeTag === ConstType_1.ConstTyTag.list) {
            return ("1" + "0111" + // cons + (7).toString(2).padStart( 4, '0' ) // type application
                "1" + "0101" // cons + (5).toString(2).padStart( 4, '0' ) // list
            // "0"                        // nil // not needed (well formed) types do expects other tags after list
            );
        }
        else if (typeTag === ConstType_1.ConstTyTag.pair) {
            return ("1" + "0111" + // cons + (7).toString(2).padStart( 4, '0' ) // type application
                "1" + "0111" + // cons + (7).toString(2).padStart( 4, '0' ) // type application
                "1" + "0110" // cons + (5).toString(2).padStart( 4, '0' ) // pair
            // "0"            // nil // not needed (well formed) types do expects other tags after pairs
            );
        }
        else if (typeTag === ConstType_1.ConstTyTag.bls12_381_G1_element ||
            typeTag === ConstType_1.ConstTyTag.bls12_381_G2_element ||
            typeTag === ConstType_1.ConstTyTag.bls12_381_MlResult)
            throw new Error("bls constants are not allowed in serialized UPLC");
        else {
            return ("1" + typeTag.toString(2).padStart(4, '0'));
        }
    }
    return bitstream_1.BitStream.fromBinStr(type.map(_serializeConstTyTagToUPLCBinaryString).join('') + "0");
}
/**
 * exported for testing purposes
 */
function serializeBuiltin(bn) {
    (0, assert_1.assert)((0, UPLCBuiltinTag_1.isUPLCBuiltinTag)(bn.tag), "while serializing a Builtin 'bn.tag' is not a valid builtin tag: bn.tag: " + bn.tag);
    var nRequiredForces = (0, UPLCBuiltinTag_1.getNRequiredForces)(bn.tag);
    var result = nRequiredForces === 0 ? new bitstream_1.BitStream(undefined) :
        bitstream_1.BitStream.fromBinStr("0101".repeat(nRequiredForces) // "force" tag repeated as necessary
        );
    result.append(Builtin_1.Builtin.UPLCTag);
    result.append(bitstream_1.BitStream.fromBinStr(bn.tag.toString(2).padStart(7, '0') // builtin tag takes 7 bits
    ));
    return result;
}
exports.serializeBuiltin = serializeBuiltin;
// ------------------------------------------------------------------------------------------------------------------- //
// --------------------------------------------------- UPLCEncoder --------------------------------------------------- //
// ------------------------------------------------------------------------------------------------------------------- //
var UPLCEncoder = /** @class */ (function () {
    function UPLCEncoder() {
        this._ctx = new UPLCSerializationContext_1.UPLCSerializationContex({
            currLength: 0
        });
    }
    UPLCEncoder.prototype.compile = function (program) {
        var v = program.version;
        this._ctx.updateVersion(v);
        var uplc = program.body;
        if (!(0, UPLCTerm_1.isPureUPLCTerm)(uplc)) {
            throw new Error("'replaceHoisteTerm' did not return an 'UPLCTerm'");
        }
        // might modify version if necessary
        var encodedProgram = this.encodeTerm(uplc);
        // version is always byte-alligned
        var result = this.encodeVersion(this._ctx.version);
        result.append(encodedProgram);
        UPLCFlatUtils_1.default.padToByte(result);
        return result;
    };
    Object.defineProperty(UPLCEncoder, "compile", {
        get: function () {
            return function (program) {
                return (new UPLCEncoder()).compile(program);
            };
        },
        enumerable: false,
        configurable: true
    });
    /** always byte-alligned */
    UPLCEncoder.prototype.encodeVersion = function (version) {
        var serialized = serializeVersion(version);
        this._ctx.incrementLengthBy(serialized.length);
        return serialized;
    };
    /** might modify version if necessary */
    UPLCEncoder.prototype.encodeTerm = function (term) {
        if (term instanceof UPLCVar_1.UPLCVar)
            return this.encodeUPLCVar(term);
        if (term instanceof Delay_1.Delay)
            return this.encodeDelayTerm(term);
        if (term instanceof Lambda_1.Lambda)
            return this.encodeLambdaTerm(term);
        if (term instanceof Application_1.Application)
            return this.encodeApplicationTerm(term);
        if (term instanceof UPLCConst_1.UPLCConst)
            return this.encodeConstTerm(term);
        if (term instanceof Force_1.Force)
            return this.encodeForceTerm(term);
        if (term instanceof ErrorUPLC_1.ErrorUPLC)
            return this.encodeUPLCError(term);
        if (term instanceof Builtin_1.Builtin)
            return this.encodeBuiltin(term);
        if (term instanceof Constr_1.Constr)
            return this.encodeConstr(term);
        if (term instanceof Case_1.Case)
            return this.encodeCase(term);
        throw new Error("'UPLCEncoder.encodeTerm' did not match any 'PureUPLCTerm'");
    };
    UPLCEncoder.prototype.encodeUPLCVar = function (uplcVar) {
        var serialized = serializeUPLCVar(uplcVar);
        this._ctx.incrementLengthBy(serialized.length);
        return serialized;
    };
    UPLCEncoder.prototype.encodeDelayTerm = function (delayed) {
        var result = Delay_1.Delay.UPLCTag;
        this._ctx.incrementLengthBy(result.length);
        result.append(this.encodeTerm(delayed.delayedTerm));
        return result;
    };
    UPLCEncoder.prototype.encodeLambdaTerm = function (lam) {
        var result = Lambda_1.Lambda.UPLCTag;
        this._ctx.incrementLengthBy(result.length);
        /*
        only the body of the lambda is encoded since the new variable is implicit
        this is not referencied in any current specification but it is present in the `plutus` source code:

        Here is where they called encode with the binder while encoding a Lambda Term

        https://github.com/input-output-hk/plutus/blob/c8d4364d0e639fef4d5b93f7d6c0912d992b54f9/plutus-core/untyped-plutus-core/src/UntypedPlutusCore/Core/Instance/Flat.hs#L110


        Here is where binder is defined

        https://github.com/input-output-hk/plutus/blob/c8d4364d0e639fef4d5b93f7d6c0912d992b54f9/plutus-core/plutus-core/src/PlutusCore/Core/Type.hs#L228


        And (most importantly) where flat encoding for binder is derived

        https://github.com/input-output-hk/plutus/blob/c8d4364d0e639fef4d5b93f7d6c0912d992b54f9/plutus-core/plutus-core/src/PlutusCore/Flat.hs#L354
        */
        result.append(this.encodeTerm(lam.body));
        return result;
    };
    UPLCEncoder.prototype.encodeApplicationTerm = function (app) {
        // if can use case/constr terms
        if (this._ctx.is_v3_friendly) {
            var args = [];
            var term = app;
            while (term instanceof Application_1.Application) {
                // prepend element to keep same order
                args.unshift(term.argTerm);
                term = term.funcTerm;
            }
            // and we have more than 2 consecutive applications
            if (args.length > 2) {
                // use case and constr so that it costs
                // as much as only 2 applications
                return this.encodeCase(new Case_1.Case(new Constr_1.Constr(BigInt(0), args), 
                // only one continutation; the last func term
                // (the one that expects the arguments)
                [term]));
            }
            // else continue with normal application encoding
        }
        // normal application encoding
        // always used in v1 and v2
        var result = Application_1.Application.UPLCTag;
        this._ctx.incrementLengthBy(result.length);
        result.append(this.encodeTerm(app.funcTerm));
        result.append(this.encodeTerm(app.argTerm));
        return result;
    };
    UPLCEncoder.prototype.encodeConstTerm = function (uplcConst) {
        var result = UPLCConst_1.UPLCConst.UPLCTag;
        result.append(serializeConstType(uplcConst.type));
        // tag and type where both context indipendent
        this._ctx.incrementLengthBy(result.length);
        result.append(this.encodeConstValue(uplcConst.value));
        return result;
    };
    UPLCEncoder.prototype.encodeConstValue = function (value) {
        (0, assert_1.assert)((0, ConstValue_1.isConstValue)(value), "a 'ConstValue' instance was expected; got" + value);
        if ((0, crypto_1.isBlsG1)(value) ||
            (0, crypto_1.isBlsG2)(value) ||
            (0, crypto_1.isBlsResult)(value))
            throw new Error("bls constants are not allowed in serialized UPLC");
        if (value === undefined)
            return new bitstream_1.BitStream();
        if ((0, ConstValue_1.isConstValueInt)(value)) {
            var _i = serializeInt(value);
            // ints are always serialized in chunks of 8 bits
            // this should be irrelevant but still good to have
            this._ctx.incrementLengthBy(_i.length);
            return _i;
        }
        if (value instanceof bytestring_1.ByteString &&
            (bytestring_1.ByteString.isStrictInstance(value))) {
            // padding is added based on context
            return this.encodeConstValueByteString(value);
        }
        if (typeof value === "string") {
            /*
            Section D.2.6 Strings (page 28)
    
            We have defined values of the string type to be sequences of Unicode characters. As mentioned earlier
            we do not specify any particular internal representation of Unicode characters, but for serialisation we use
            the UTF-8 representation to convert between strings and bytestrings
            
            **and then use the bytestring encoder and decoder**:
            */
            return this.encodeConstValue(new bytestring_1.ByteString((0, uint8array_utils_1.fromUtf8)(value)));
        }
        if (typeof value === "boolean") {
            var _b = bitstream_1.BitStream.fromBinStr(value === true ? "1" : "0");
            this._ctx.incrementLengthBy(_b.length);
            return _b;
        }
        if ((0, ConstValue_1.isConstValueList)(value)) {
            var result = new bitstream_1.BitStream();
            /*
            operations on bigints (BitStream underlying type) are O(n)
            appending first to this BitStream and then to the effective result
            should give us some performace improvements
            */
            var listElem = void 0;
            for (var i = 0; i < value.length; i++) {
                // cons
                listElem = bitstream_1.BitStream.fromBinStr("1");
                this._ctx.incrementLengthBy(1);
                // set list element
                listElem.append(this.encodeConstValue(value[i]));
                // append element
                // length already updated since using an "encode" function
                result.append(listElem);
            }
            // nil
            result.append(bitstream_1.BitStream.fromBinStr("0"));
            this._ctx.incrementLengthBy(1);
            return result;
        }
        if (value instanceof pair_1.Pair) {
            var result = this.encodeConstValue(value.fst);
            result.append(this.encodeConstValue(value.snd));
            return result;
        }
        if (value instanceof cbor_1.CborString) {
            value = (0, plutus_data_1.dataFromCbor)(value);
        }
        if ((0, plutus_data_1.isData)(value)) {
            return this.encodeConstValueData(value);
        }
        throw new Error("'this.encodeConstValue' did not matched any 'ConstValue' possible type; input was: " + value);
    };
    /**
     * ### Section D.3.5
     * The ```data``` type
     *
     * The ùöçùöäùöùùöä type is encoded by converting to a bytestring using the CBOR encoding described in Note 1 of
     * Appendix B.2 and then using ùñ§ ùïå ‚àó . The decoding process is the opposite of this: a bytestring is obtained
     * using ùñ£ ùïå ‚àó and this is then decoded from CBOR to obtain a ùöçùöäùöùùöä object.
     *
     * ### Section B.2
     *
     * **Note 1.** Serialising ùöçùöäùöùùöä objects. The ```serialiseData``` function takes a ùöçùöäùöùùöä object and converts it
     * into a CBOR (Bormann and Hoffman [2020]) object. The encoding is based on the Haskell Data type
     * described in Section A.1. A detailed description of the encoding will appear here at a later date, but for
     * the time being see the Haskell code in
     * [plutus-core/plutus-core/src/PlutusCore/Data.hs](https://github.com/input-output-hk/plutus/blob/master/plutus-core/plutus-core/src/PlutusCore/Data.hs)
     * ([```encodeData``` line](https://github.com/input-output-hk/plutus/blob/9ef6a65067893b4f9099215ff7947da00c5cd7ac/plutus-core/plutus-core/src/PlutusCore/Data.hs#L139))
     * in the Plutus GitHub repository IOHK [2019] for a definitive implementation.
     *
     * from the `encodeData` source:
     *
     * {- Note [The 64-byte limit]
     *    We impose a 64-byte *on-the-wire* limit on the leaves of a serialized 'Data'. This prevents people from inserting
     *    Mickey Mouse entire.
     *
     *    The simplest way of doing this is to check during deserialization that we never deserialize something that uses
     *    more than 64-bytes, and this is largely what we do. Then it's the user's problem to not produce something too big.
     *
     *    But this is quite inconvenient, so see Note [Evading the 64-byte limit] for how we get around this.
     * -}
     * {- Note [Evading the 64-byte limit]
     *  Implementing Note [The 64-byte limit] naively would be quite annoying:
     *  - Users would be responsible for not creating Data values with leaves that were too big.
     *  - If a script *required* such a thing (e.g. a counter that somehow got above 64 bytes), then the user is totally
     *  stuck: the script demands something they cannot represent.
     *
     *  This is unpleasant and introduces limits. Probably limits that nobody will hit, but it's nicer to just not have them.
     *  And it turns out that we can evade the problem with some clever encoding.
     *
     *  The fundamental
     *  trick is that an *indefinite-length* CBOR bytestring is just as obfuscated as a list of bytestrings,
     *  since it consists of a list of definite-length chunks, and each definite-length chunk must be *tagged* (at least with the size).
     *  So we get a sequence like:
     *
     *  <list start>
     *  <chunk length metadata>
     *  <chunk>
     *  <chunk length metadata>
     *  ...
     *  <list end>
     *
     *  The chunk length metadata has a prescribed format, such that it's difficult to manipulate it so that it
     *  matches your "desired" data.
     *  So this effectively breaks up the bytestring in much the same way as a list of <64 byte bytestrings.
     *
     *  So that solves the problem for bytestrings on the encoding side:
     *  - if they are <=64 bytes, we can just encode them as a normal bytestring
     *  - if they are >64 bytes, we encode them as indefinite-length bytestrings with 64-byte chunks
     *
     *  On the decoding side, we need to check when we decode that we never decode a definite-length
     *  bytestring of >64 bytes. That covers our two cases:
     *  - Short definite-length bytestrings are fine
     *  - Long indefinite-length bytestrings are just made of short definite-length bytestings.
     *
     *   *  Unfortunately this all means that we have to write our own encoders/decoders so we can produce
     *   *  chunks of the right size and check the sizes when we decode, but that's okay. Users need to do the same
     *   *  thing: anyone encoding `Data` with their own encoders who doesn't split up big bytestrings in this way
     *   *  will get failures when we decode them.
     *
     *  For integers, we have two cases. Small integers (<=64bits) can be encoded normally. Big integers are already
     *  encoded *with a byte string*. The spec allows this to be an indefinite-length bytestring (although cborg doesn't
     *  like it), so we can reuse our trick. Again, we need to write some manual encoders/decoders.
     *  -}
     */
    UPLCEncoder.prototype.encodeConstValueData = function (data) {
        var cborBytes = (0, plutus_data_1.dataToCbor)(data).toBuffer();
        /*
        **NOTE**

        large data encoding

        Before we thought this was only an UPLC serialization problem;
        and that the UPLC builtin `serialiseData` would have just resulted
        in a normal CBOR bytestring, no matter the length.

        section 4.3.2 (Note 1) is instead clear that the above was not the case
        and that the `serialiseData` is subject to the same serialization with
        hard coded limit on bytestrings length

        `dataToCbor` was fixed accordingly since `@harmoniclabs/plutus-data@^1.2.0`
        so we can rely on that function both in UPLC serialization
        and on-chain builtin `serialiseData` execution
        */
        return this.encodeConstValueByteString(new bytestring_1.ByteString(cborBytes));
    };
    /**
     * latest specification (**_section D.2.5 Bytestrings; page 27_**)
     * specifies how bytestrings are byte-alligned before and the first byte indicates the length
     *
     * **this function takes care of the length AND padding**
     *
     */
    UPLCEncoder.prototype.encodeConstValueByteString = function (bs) {
        var missingBytes = bs.toString();
        var hexChunks = [];
        while ((missingBytes.length / 2) > 255) {
            hexChunks.push("ff" + missingBytes.slice(0, 255 * 2));
            missingBytes = missingBytes.slice(255 * 2);
        }
        if (missingBytes.length !== 0) {
            hexChunks.push((missingBytes.length / 2).toString(16).padStart(2, '0') +
                missingBytes);
        }
        // end chunk
        hexChunks.push("00");
        var nPadBits = 8 - (this._ctx.currLength % 8);
        // add initial padding as needed by context
        var result = bitstream_1.BitStream.fromBinStr("1".padStart(nPadBits, '0'));
        // append chunks
        result.append(new bitstream_1.BitStream((0, uint8array_utils_1.fromHex)(hexChunks.join('')), 0));
        this._ctx.incrementLengthBy(result.length);
        return result;
    };
    UPLCEncoder.prototype.encodeForceTerm = function (force) {
        if (force.termToForce instanceof Delay_1.Delay) {
            // cancels direct delays
            return this.encodeTerm(force.termToForce.delayedTerm);
        }
        var result = Force_1.Force.UPLCTag;
        this._ctx.incrementLengthBy(result.length);
        result.append(this.encodeTerm(force.termToForce));
        return result;
    };
    UPLCEncoder.prototype.encodeUPLCError = function (_term) {
        var errTag = ErrorUPLC_1.ErrorUPLC.UPLCTag;
        this._ctx.incrementLengthBy(errTag.length);
        return errTag.clone();
    };
    UPLCEncoder.prototype.encodeBuiltin = function (bn) {
        var result = serializeBuiltin(bn);
        this._ctx.incrementLengthBy(result.length);
        return result;
    };
    UPLCEncoder.prototype.encodeConstr = function (constr) {
        if (!this._ctx.is_v3_friendly)
            throw new Error("'Constr' term found using UPLC version " +
                this._ctx.version.toString() +
                "; maybe you wanted to use version 1.1.0 or higher?");
        var result = Constr_1.Constr.UPLCTag;
        result.append(serializeUInt(constr.index));
        this._ctx.incrementLengthBy(result.length);
        result.append(this.encodeTermList(constr.terms));
        return result;
    };
    UPLCEncoder.prototype.encodeCase = function (caseTerm) {
        if (!this._ctx.is_v3_friendly)
            throw new Error("'Case' term found using UPLC version " +
                this._ctx.version.toString() +
                "; maybe you wanted to use version 1.1.0 or higher?");
        var result = Case_1.Case.UPLCTag;
        this._ctx.incrementLengthBy(result.length);
        result.append(this.encodeTerm(caseTerm.constrTerm));
        result.append(this.encodeTermList(caseTerm.continuations));
        return result;
    };
    UPLCEncoder.prototype.encodeTermList = function (list) {
        var _this = this;
        if (list.length === 0) {
            this._ctx.incrementLengthBy(1);
            return bitstream_1.BitStream.fromBinStr("0");
        }
        ;
        var ctx = this._ctx;
        var result = list
            .reduce(function (accum, elem) {
            var result = bitstream_1.BitStream.fromBinStr("1");
            // increment BEFORE `this.encodeTerm`
            ctx.incrementLengthBy(1);
            result.append(_this.encodeTerm(elem));
            accum.append(result);
            return accum;
        }, new bitstream_1.BitStream(undefined));
        ctx.incrementLengthBy(1);
        result.append(bitstream_1.BitStream.fromBinStr("0"));
        return result;
    };
    return UPLCEncoder;
}());
exports.UPLCEncoder = UPLCEncoder;
function compileUPLC(program) {
    return (new UPLCEncoder()).compile(program);
}
exports.compileUPLC = compileUPLC;
/**
 * alias for `compileUPLC`
 */
exports.encodeUPLC = compileUPLC;
