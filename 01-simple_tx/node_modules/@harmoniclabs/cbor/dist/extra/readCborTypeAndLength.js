"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readCborTypeAndLength = void 0;
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var Constants_1 = require("../Cbor/Constants/index.js");
function readCborTypeAndLength(bytes) {
    if (bytes.length < 1)
        return undefined;
    var headerByte = bytes[0];
    var major = headerByte >> 5;
    var addInfos = headerByte & 31;
    if (major === Constants_1.MajorType.float_or_simple) {
        if (addInfos === 25) {
            var float = getFloat16(bytes);
            if (float === undefined)
                return undefined;
            return {
                type: major,
                length: float
            };
        }
        if (addInfos === 26) {
            var float = getFloat32(bytes);
            if (float === undefined)
                return undefined;
            return {
                type: major,
                length: float
            };
        }
        if (addInfos === 27) {
            var float = getFloat64(bytes);
            if (float === undefined)
                return undefined;
            return {
                type: major,
                length: float
            };
        }
        return {
            type: major,
            length: addInfos
        };
    }
    var length = getLength(addInfos, bytes);
    if (typeof length !== "bigint")
        return undefined;
    if (length < 0)
        return {
            type: major,
            length: undefined // indefinite length
        };
    else
        return {
            type: major,
            length: length
        };
    // if( length < 0 &&
    //     ( major < 2 || major > 6 )
    // )
    // {
    //     throw new BaseCborError( "unexpected indefinite length element while parsing CBOR" );
    // }
}
exports.readCborTypeAndLength = readCborTypeAndLength;
function getLength(addInfos, bytes) {
    if (addInfos < 24)
        return BigInt(addInfos);
    if (addInfos === 24) {
        if (bytes.length < 2)
            return undefined;
        return BigInt((0, uint8array_utils_1.readUint8)(bytes, 1));
    }
    if (addInfos === 25) {
        if (bytes.length < 3)
            return undefined;
        return BigInt((0, uint8array_utils_1.readUint16BE)(bytes, 1));
    }
    if (addInfos === 26) {
        if (bytes.length < 5)
            return undefined;
        return BigInt((0, uint8array_utils_1.readUint32BE)(bytes, 1));
    }
    if (addInfos === 27) {
        if (bytes.length < 9)
            return undefined;
        return BigInt((0, uint8array_utils_1.readBigUInt64BE)(bytes, 1));
    }
    if (addInfos === 31)
        return BigInt(-1); // indefinite length element follows
    // throw new BaseCborError( "Invalid length encoding while parsing CBOR" );
    return undefined;
}
function getFloat16(bytes) {
    if (bytes.length < 3)
        return undefined;
    // increments the offset here
    var floatBits = (0, uint8array_utils_1.readUint16BE)(bytes, 1);
    var tempArrayBuffer = new ArrayBuffer(4);
    var tempDataView = new DataView(tempArrayBuffer);
    var sign = floatBits & 32768;
    var exponent = floatBits & 31744;
    var fraction = floatBits & 1023;
    if (exponent === 0x7c00)
        exponent = 0xff << 10;
    else if (exponent !== 0)
        exponent += (127 - 15) << 10;
    else if (fraction !== 0)
        return (sign !== 0 ? -1 : 1) * fraction * 5.960464477539063e-8;
    tempDataView.setUint32(0, sign << 16 | exponent << 13 | fraction << 13);
    return tempDataView.getFloat32(0);
}
function getFloat32(bytes) {
    if (bytes.length < 5)
        return undefined;
    return (0, uint8array_utils_1.readFloat32BE)(bytes, 1);
}
function getFloat64(bytes) {
    if (bytes.length < 9)
        return undefined;
    return (0, uint8array_utils_1.readFloat64BE)(bytes, 1);
}
