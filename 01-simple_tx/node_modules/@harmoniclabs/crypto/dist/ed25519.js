"use strict";
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ed25519bigint = exports.verifyEd25519Signature = exports.getEd25519Signature = exports.signExtendedEd25519 = exports.signEd25519 = exports.extendedToPublic = exports.deriveEd25519PublicKey = exports.scalarMultBase = exports.scalarFromBytes = exports.pointFromBytes = exports.bigpointToUint8Array = exports.encodeInt = exports.scalarMul = exports.addPointsEdwards = void 0;
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var sha2_512_1 = require("./sha2_512.js");
var types_1 = require("./types.js");
var positiveMod_1 = require("./utils/positiveMod.js");
var assert_1 = require("./utils/assert.js");
var bigintToBuffer_1 = require("./utils/bigintToBuffer.js");
var Q = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"); // ipowi(255) - 19
var Q38 = BigInt("7237005577332262213973186563042994240829374041602535252466099000494570602494"); // (Q + 3)/8
var CURVE_ORDER = BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"); // ipow2(252) + 27742317777372353535851937790883648493;
var D = -BigInt("4513249062541557337682894930092624173785641285191125241628941591882900924598840740"); // -121665 * invert(121666);
var I = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752"); // expMod(BigInt( 2 ), (Q - BigInt( 1 ))/4, Q);
var BASE = Object.freeze([
    BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
    BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960") // (4*invert(5)) % Q
]);
/**
 *
 * @param {bigint} b
 * @param {bigint} e
 * @param {bigint} m
 * @returns {bigint}
 */
function expMod(b, e, m) {
    if (e == BigInt(0)) {
        return BigInt(1);
    }
    else {
        var t = expMod(b, e / BigInt(2), m);
        t = (t * t) % m;
        if ((e % BigInt(2)) != BigInt(0)) {
            t = (0, positiveMod_1.positiveMod)(t * b, m);
        }
        return t;
    }
}
function invert(n) {
    var a = (0, positiveMod_1.positiveMod)(n, Q);
    var b = Q;
    var x = BigInt(0);
    var y = BigInt(1);
    var u = BigInt(1);
    var v = BigInt(0);
    while (a !== BigInt(0)) {
        var q = b / a;
        var r = b % a;
        var m = x - u * q;
        var n_1 = y - v * q;
        b = a;
        a = r;
        x = u;
        y = v;
        u = m;
        v = n_1;
    }
    return (0, positiveMod_1.positiveMod)(x, Q);
}
/**
 * @param {bigint} y
 * @returns {bigint}
 */
function recoverX(y) {
    var yy = y * y;
    var xx = (yy - BigInt(1)) * invert(D * yy + BigInt(1));
    var x = expMod(xx, Q38, Q);
    if (((x * x - xx) % Q) !== BigInt(0)) {
        x = (x * I) % Q;
    }
    if ((x % BigInt(2)) !== BigInt(0)) {
        x = Q - x;
    }
    return x;
}
/**
 * Curve point 'addition'
 * Note: this is probably the bottleneck of this Ed25519 implementation
 */
function addPointsEdwards(a, b) {
    var x1 = a[0];
    var y1 = a[1];
    var x2 = b[0];
    var y2 = b[1];
    var dxxyy = D * x1 * x2 * y1 * y2;
    var x3 = (x1 * y2 + x2 * y1) * invert(BigInt(1) + dxxyy);
    var y3 = (y1 * y2 + x1 * x2) * invert(BigInt(1) - dxxyy);
    return [(0, positiveMod_1.positiveMod)(x3, Q), (0, positiveMod_1.positiveMod)(y3, Q)];
}
exports.addPointsEdwards = addPointsEdwards;
function scalarMul(point, n) {
    if (n === BigInt(0)) {
        return [BigInt(0), BigInt(1)];
    }
    else {
        var sum = scalarMul(point, n / BigInt(2));
        sum = addPointsEdwards(sum, sum);
        if ((n % BigInt(2)) !== BigInt(0)) {
            sum = addPointsEdwards(sum, point);
        }
        return sum;
    }
}
exports.scalarMul = scalarMul;
/**
 * Curve point 'multiplication'
 */
function encodeInt(y) {
    var bytes = Array.from((0, bigintToBuffer_1.bigintToBuffer)(y)).reverse();
    while (bytes.length < 32) {
        bytes.push(0);
    }
    return bytes;
}
exports.encodeInt = encodeInt;
function decodeInt(s) {
    return BigInt("0x" + (0, types_1.byteArrToHex)(s.reverse()));
}
function bigpointToByteArray(point) {
    var _a = __read(point, 2), x = _a[0], y = _a[1];
    var bytes = encodeInt(y);
    // last bit is determined by x
    bytes[31] = ((bytes[31] & 255) | (Number(x & BigInt(1)) * 128));
    return bytes;
}
function bigpointToUint8Array(point) {
    return new Uint8Array(bigpointToByteArray(point));
}
exports.bigpointToUint8Array = bigpointToUint8Array;
function getBit(bytes, i) {
    return ((bytes[Math.floor(i / 8)] >> i % 8) & 1);
}
function isOnCurve(point) {
    var x = point[0];
    var y = point[1];
    var xx = x * x;
    var yy = y * y;
    return (-xx + yy - BigInt(1) - D * xx * yy) % Q == BigInt(0);
}
function pointFromBytes(s) {
    if (s instanceof Uint8Array)
        s = asBytes(s);
    (0, assert_1.assert)(s.length == 32, "point must have length of 32");
    var bytes = s.slice();
    bytes[31] = (bytes[31] & 127);
    var y = decodeInt(bytes);
    var x = recoverX(y);
    if (Number(x & BigInt(1)) != getBit(s, 255)) {
        x = Q - x;
    }
    var point = [x, y];
    if (!isOnCurve(point)) {
        throw new Error("point isn't on curve");
    }
    return point;
}
exports.pointFromBytes = pointFromBytes;
var ipow2_253 = BigInt("28948022309329048855892746252171976963317496166410141009864396001978282409984"); // ipow2(253)
function scalarFromBytes(h) {
    var bytes = h.slice(0, 32);
    bytes[0] = (bytes[0] & 248);
    bytes[31] = (bytes[31] & 63);
    return ipow2_253 + BigInt("0x" + (0, types_1.byteArrToHex)(bytes.reverse()));
}
exports.scalarFromBytes = scalarFromBytes;
function ihash(m) {
    return decodeInt((0, sha2_512_1.sha2_512)(m));
}
function forceUint8Array(stuff) {
    if (typeof stuff === "string")
        return (0, uint8array_utils_1.fromHex)(stuff);
    return (0, uint8array_utils_1.isUint8Array)(stuff) ? stuff : new Uint8Array(stuff);
}
function scalarMultBase(scalar) {
    return scalarMul(BASE, scalar);
}
exports.scalarMultBase = scalarMultBase;
function deriveEd25519PublicKey(privateKey) {
    var extended = (0, sha2_512_1.sha2_512)(privateKey);
    var a = scalarFromBytes(extended);
    var A = scalarMul(BASE, a);
    return bigpointToByteArray(A);
}
exports.deriveEd25519PublicKey = deriveEd25519PublicKey;
function extendedToPublic(extended) {
    if (extended instanceof Uint8Array)
        extended = Array.from(extended);
    var a = scalarFromBytes(extended);
    var A = scalarMul(BASE, a);
    return new Uint8Array(bigpointToByteArray(A));
}
exports.extendedToPublic = extendedToPublic;
function asBytes(stuff) {
    if (typeof stuff === "string")
        return asBytes((0, uint8array_utils_1.fromHex)(stuff));
    return Array.from(stuff);
}
function signEd25519(message, privateKey) {
    message = forceUint8Array(message);
    privateKey = forceUint8Array(privateKey);
    return signExtendedEd25519(message, (0, sha2_512_1.sha2_512)(asBytes(privateKey)));
}
exports.signEd25519 = signEd25519;
function signExtendedEd25519(message, extendedKey) {
    var _a;
    message = forceUint8Array(message);
    extendedKey = forceUint8Array(extendedKey);
    if (extendedKey.length !== 64)
        throw new Error('signExtendedEd25519:: extended key must have length 64');
    var privateKeyHash = asBytes(extendedKey);
    var a = scalarFromBytes(privateKeyHash);
    // for convenience getulate publicKey here:
    var publicKey = bigpointToByteArray(scalarMul(BASE, a));
    var r = ihash(privateKeyHash.slice(32, 64).concat(asBytes(message)));
    var R = scalarMul(BASE, r);
    var S = (0, positiveMod_1.positiveMod)(r + ihash(bigpointToByteArray(R).concat(publicKey).concat(asBytes(message))) * a, CURVE_ORDER);
    var pubKey = new Uint8Array(publicKey);
    var signature = new Uint8Array(bigpointToByteArray(R).concat(encodeInt(S)));
    return _a = {
            0: pubKey,
            1: signature,
            length: 2
        },
        _a[Symbol.iterator] = function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, pubKey];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, signature];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        },
        _a.pubKey = pubKey,
        _a.signature = signature,
        _a;
}
exports.signExtendedEd25519 = signExtendedEd25519;
function getEd25519Signature(message, privateKey) {
    return signEd25519(message, privateKey).signature;
}
exports.getEd25519Signature = getEd25519Signature;
function verifyEd25519Signature(signature, message, publicKey) {
    if (signature.length !== 64 || publicKey.length != 32) {
        throw new Error("unexpected signature length ".concat(signature.length));
    }
    if ((0, uint8array_utils_1.isUint8Array)(signature)) {
        signature = (0, types_1.buffToByteArr)(signature);
    }
    if ((0, uint8array_utils_1.isUint8Array)(message)) {
        message = (0, types_1.buffToByteArr)(message);
    }
    if ((0, uint8array_utils_1.isUint8Array)(publicKey)) {
        publicKey = (0, types_1.buffToByteArr)(publicKey);
    }
    var R = pointFromBytes(asBytes(signature).slice(0, 32));
    var A = pointFromBytes(asBytes(publicKey));
    var S = decodeInt(asBytes(signature).slice(32, 64));
    var h = ihash(asBytes(signature).slice(0, 32).concat(asBytes(publicKey)).concat(asBytes(message)));
    var left = scalarMul(BASE, S);
    var right = addPointsEdwards(R, scalarMul(A, h));
    return (left[0] == right[0]) && (left[1] == right[1]);
}
exports.verifyEd25519Signature = verifyEd25519Signature;
var _0n = BigInt(0);
var ED25519_ORDER = BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949');
function mod(a, b) {
    var result = a % b;
    return result >= _0n ? result : b + result;
}
function ed25519bigint(n) {
    return mod(n, ED25519_ORDER);
}
exports.ed25519bigint = ed25519bigint;
