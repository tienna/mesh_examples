"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.Keccak = exports.keccakP = void 0;
/*
THIS IMPLEMENTATION WAS TAKEN FROM `@noble/hashes`

original source: https://github.com/paulmillr/noble-hashes/blob/6ae82e75d4c354d53a488e95b1bfe9cba90bd6ff/src/sha3.ts#L1

it was modified and adapted to this repository to re-use already defined stuff

the main reason for copying over and not using as dependency is because of different target in the `tsconfig.json`

`@noble/hashes` targets es2020, which tends to cause problems with some other (older) packages sometimes

this repo targets ES5+
*/
var _u64_1 = require("./_u64.js");
var utils_1 = require("./utils.js");
var assert_1 = require("../utils/assert.js");
// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
// It's called a sponge function.
// Various per round constants calculations
var SHA3_PI = [];
var SHA3_ROTL = [];
var _SHA3_IOTA = [];
var _0n = /** @__PURE__ */ BigInt(0);
var _1n = /** @__PURE__ */ BigInt(1);
var _2n = /** @__PURE__ */ BigInt(2);
var _7n = /** @__PURE__ */ BigInt(7);
var _256n = /** @__PURE__ */ BigInt(256);
var _0x71n = /** @__PURE__ */ BigInt(0x71);
for (var round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    _a = __read([y, (2 * x + 3 * y) % 5], 2), x = _a[0], y = _a[1];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    var t = _0n;
    for (var j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << /** @__PURE__ */ BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
var _b = __read(/** @__PURE__ */ (0, _u64_1.split)(_SHA3_IOTA, true), 2), SHA3_IOTA_H = _b[0], SHA3_IOTA_L = _b[1];
// Left rotation (without 0, 32, 64)
var rotlH = function (h, l, s) { return (s > 32 ? (0, _u64_1.rotlBH)(h, l, s) : (0, _u64_1.rotlSH)(h, l, s)); };
var rotlL = function (h, l, s) { return (s > 32 ? (0, _u64_1.rotlBL)(h, l, s) : (0, _u64_1.rotlSL)(h, l, s)); };
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds) {
    if (rounds === void 0) { rounds = 24; }
    var B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (var round = 24 - rounds; round < 24; round++) {
        // Theta θ
        for (var x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (var x = 0; x < 10; x += 2) {
            var idx1 = (x + 8) % 10;
            var idx0 = (x + 2) % 10;
            var B0 = B[idx0];
            var B1 = B[idx0 + 1];
            var Th = rotlH(B0, B1, 1) ^ B[idx1];
            var Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (var y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho (ρ) and Pi (π)
        var curH = s[2];
        var curL = s[3];
        for (var t = 0; t < 24; t++) {
            var shift = SHA3_ROTL[t];
            var Th = rotlH(curH, curL, shift);
            var Tl = rotlL(curH, curL, shift);
            var PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi (χ)
        for (var y = 0; y < 50; y += 10) {
            for (var x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (var x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota (ι)
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
exports.keccakP = keccakP;
var Keccak = /** @class */ (function (_super) {
    __extends(Keccak, _super);
    // NOTE: we accept arguments in bytes instead of bits here.
    function Keccak(blockLen, suffix, outputLen, enableXOF, rounds) {
        if (enableXOF === void 0) { enableXOF = false; }
        if (rounds === void 0) { rounds = 24; }
        var _this = _super.call(this) || this;
        _this.blockLen = blockLen;
        _this.suffix = suffix;
        _this.outputLen = outputLen;
        _this.enableXOF = enableXOF;
        _this.rounds = rounds;
        _this.pos = 0;
        _this.posOut = 0;
        _this.finished = false;
        _this.destroyed = false;
        // Can be passed from user as dkLen
        (0, assert_1.assertPostiveInteger)(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= _this.blockLen || _this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        _this.state = new Uint8Array(200);
        _this.state32 = (0, utils_1.u32)(_this.state);
        return _this;
    }
    Keccak.prototype.keccak = function () {
        if (!utils_1.isLE)
            (0, utils_1.byteSwap32)(this.state32);
        keccakP(this.state32, this.rounds);
        if (!utils_1.isLE)
            (0, utils_1.byteSwap32)(this.state32);
        this.posOut = 0;
        this.pos = 0;
    };
    Keccak.prototype.update = function (data) {
        this.assertExists();
        var _a = this, blockLen = _a.blockLen, state = _a.state;
        data = (0, utils_1.toBytes)(data);
        var len = data.length;
        for (var pos = 0; pos < len;) {
            var take = Math.min(blockLen - this.pos, len - pos);
            for (var i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    };
    Keccak.prototype.finish = function () {
        if (this.finished)
            return;
        this.finished = true;
        var _a = this, state = _a.state, suffix = _a.suffix, pos = _a.pos, blockLen = _a.blockLen;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    };
    Keccak.prototype.writeInto = function (out) {
        this.assertExists(false);
        if (!(out instanceof Uint8Array))
            throw new Error("Uint8Array expected");
        this.finish();
        var bufferOut = this.state;
        var blockLen = this.blockLen;
        for (var pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            var take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    };
    Keccak.prototype.xofInto = function (out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    };
    Keccak.prototype.xof = function (bytes) {
        (0, assert_1.assertPostiveInteger)(bytes);
        return this.xofInto(new Uint8Array(bytes));
    };
    Keccak.prototype.digestInto = function (out) {
        // output(out, this);
        if (!(out instanceof Uint8Array))
            throw new Error("Uint8Array expected");
        var min = this.outputLen;
        if (out.length < min)
            throw new Error("digestInto() expects output buffer of length at least ".concat(min));
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    };
    Keccak.prototype.digest = function () {
        return this.digestInto(new Uint8Array(this.outputLen));
    };
    Keccak.prototype.destroy = function () {
        this.destroyed = true;
        this.state.fill(0);
    };
    Keccak.prototype._cloneInto = function (to) {
        var _a = this, blockLen = _a.blockLen, suffix = _a.suffix, outputLen = _a.outputLen, rounds = _a.rounds, enableXOF = _a.enableXOF;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    };
    Keccak.prototype.assertExists = function (checkFinished) {
        if (checkFinished === void 0) { checkFinished = true; }
        if (this.destroyed)
            throw new Error('Hash instance has been destroyed');
        if (checkFinished && this.finished)
            throw new Error('Hash#digest() has already been called');
    };
    return Keccak;
}(utils_1.Hash));
exports.Keccak = Keccak;
var gen = function (suffix, blockLen, outputLen) {
    return (0, utils_1.wrapConstructor)(function () { return new Keccak(blockLen, suffix, outputLen); });
};
// export const sha3_224 = /** @__PURE__ */ gen(0x06, 144, 224 / 8);
// /**
//  * SHA3-256 hash function
//  * @param message - that would be hashed
//  */
// export const sha3_256 = /** @__PURE__ */ gen(0x06, 136, 256 / 8);
// export const sha3_384 = /** @__PURE__ */ gen(0x06, 104, 384 / 8);
// export const sha3_512 = /** @__PURE__ */ gen(0x06, 72, 512 / 8);
exports.keccak_224 = gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
exports.keccak_256 = gen(0x01, 136, 256 / 8);
exports.keccak_384 = gen(0x01, 104, 384 / 8);
exports.keccak_512 = gen(0x01, 72, 512 / 8);
// const genShake = (suffix: number, blockLen: number, outputLen: number) =>
//   wrapXOFConstructorWithOpts<HashXOF<Keccak>, ShakeOpts>(
//     (opts: ShakeOpts = {}) =>
//       new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true)
//   );
// 
// export const shake128 = /** @__PURE__ */ genShake(0x1f, 168, 128 / 8);
// export const shake256 = /** @__PURE__ */ genShake(0x1f, 136, 256 / 8);
