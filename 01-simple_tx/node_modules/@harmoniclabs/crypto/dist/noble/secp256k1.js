"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifySecp256k1 = exports.signSecp256k1 = exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.verifySchnorr = exports.signSchnorr = exports.Secp256k1Point = exports.secp256k1PointToBytes = exports.secp256k1 = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var sha256_1 = require("./sha256.js");
var utils_1 = require("./utils.js");
var modular_1 = require("./abstract/modular.js");
var weierstrass_1 = require("./abstract/weierstrass.js");
var utils_2 = require("./abstract/utils.js");
var hash_to_curve_1 = require("./abstract/hash-to-curve.js");
var _shortw_utils_1 = require("./_shortw_utils.js");
var secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');
var secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
var _1n = BigInt(1);
var _2n = BigInt(2);
var divNearest = function (a, b) { return (a + b / _2n) / b; };
/**
 * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
 * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
 */
function sqrtMod(y) {
    var P = secp256k1P;
    var _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    var _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    var b2 = (y * y * y) % P; // x^3, 11
    var b3 = (b2 * b2 * y) % P; // x^7
    var b6 = ((0, modular_1.pow2)(b3, _3n, P) * b3) % P;
    var b9 = ((0, modular_1.pow2)(b6, _3n, P) * b3) % P;
    var b11 = ((0, modular_1.pow2)(b9, _2n, P) * b2) % P;
    var b22 = ((0, modular_1.pow2)(b11, _11n, P) * b11) % P;
    var b44 = ((0, modular_1.pow2)(b22, _22n, P) * b22) % P;
    var b88 = ((0, modular_1.pow2)(b44, _44n, P) * b44) % P;
    var b176 = ((0, modular_1.pow2)(b88, _88n, P) * b88) % P;
    var b220 = ((0, modular_1.pow2)(b176, _44n, P) * b44) % P;
    var b223 = ((0, modular_1.pow2)(b220, _3n, P) * b3) % P;
    var t1 = ((0, modular_1.pow2)(b223, _23n, P) * b22) % P;
    var t2 = ((0, modular_1.pow2)(t1, _6n, P) * b2) % P;
    var root = (0, modular_1.pow2)(t2, _2n, P);
    if (!Fp.eql(Fp.sqr(root), y))
        throw new Error('Cannot find square root');
    return root;
}
var Fp = (0, modular_1.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });
exports.secp256k1 = (0, _shortw_utils_1.createCurve)({
    a: BigInt(0),
    b: BigInt(7),
    Fp: Fp,
    n: secp256k1N,
    // Base point (x, y) aka generator point
    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
    h: BigInt(1),
    lowS: true,
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */
    endo: {
        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
        splitScalar: function (k) {
            var n = secp256k1N;
            var a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
            var b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
            var a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
            var b2 = a1;
            var POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)
            var c1 = divNearest(b2 * k, n);
            var c2 = divNearest(-b1 * k, n);
            var k1 = (0, modular_1.mod)(k - c1 * a1 - c2 * a2, n);
            var k2 = (0, modular_1.mod)(-c1 * b1 - c2 * b2, n);
            var k1neg = k1 > POW_2_128;
            var k2neg = k2 > POW_2_128;
            if (k1neg)
                k1 = n - k1;
            if (k2neg)
                k2 = n - k2;
            if (k1 > POW_2_128 || k2 > POW_2_128) {
                throw new Error('splitScalar: Endomorphism failed, k=' + k);
            }
            return { k1neg: k1neg, k1: k1, k2neg: k2neg, k2: k2 };
        },
    },
}, sha256_1.sha256);
// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
var _0n = BigInt(0);
var fe = function (x) { return typeof x === 'bigint' && _0n < x && x < secp256k1P; };
var ge = function (x) { return typeof x === 'bigint' && _0n < x && x < secp256k1N; };
/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag) {
    var messages = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        messages[_i - 1] = arguments[_i];
    }
    var tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === undefined) {
        var tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, function (c) { return c.charCodeAt(0); }));
        tagP = (0, utils_2.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return (0, sha256_1.sha256)(utils_2.concatBytes.apply(void 0, __spreadArray([tagP], __read(messages), false)));
}
// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03
var pointToBytes = function (point) { return point.toRawBytes(true).slice(1); };
exports.secp256k1PointToBytes = pointToBytes;
var numTo32b = function (n) { return (0, utils_2.numberToBytesBE)(n, 32); };
var modP = function (x) { return (0, modular_1.mod)(x, secp256k1P); };
var modN = function (x) { return (0, modular_1.mod)(x, secp256k1N); };
var Point = exports.secp256k1.ProjectivePoint;
exports.Secp256k1Point = exports.secp256k1.ProjectivePoint;
var GmulAdd = function (Q, a, b) {
    return Point.BASE.multiplyAndAddUnsafe(Q, a, b);
};
// Calculate point, scalar and bytes
function schnorrGetExtPubKey(priv) {
    var d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey
    var p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside
    var scalar = p.hasEvenY() ? d_ : modN(-d_);
    return { scalar: scalar, bytes: pointToBytes(p) };
}
/**
 * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.
 * @returns valid point checked for being on-curve
 */
function lift_x(x) {
    if (!fe(x))
        throw new Error('bad x: need 0 < x < p'); // Fail if x ≥ p.
    var xx = modP(x * x);
    var c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.
    var y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.
    if (y % _2n !== _0n)
        y = modP(-y); // Return the unique point P such that x(P) = x and
    var p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.
    p.assertValidity();
    return p;
}
/**
 * Create tagged hash, convert it to bigint, reduce modulo-n.
 */
function challenge() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return modN((0, utils_2.bytesToNumberBE)(taggedHash.apply(void 0, __spreadArray(['BIP0340/challenge'], __read(args), false))));
}
/**
 * Schnorr public key is just `x` coordinate of Point as per BIP340.
 */
function schnorrGetPublicKey(privateKey) {
    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)
}
/**
 * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.
 * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.
 */
function schnorrSign(message, privateKey, auxRand) {
    if (auxRand === void 0) { auxRand = (0, utils_1.randomBytes)(32); }
    var m = (0, utils_2.ensureBytes)('message', message);
    var _a = schnorrGetExtPubKey(privateKey), px = _a.bytes, d = _a.scalar; // checks for isWithinCurveOrder
    var a = (0, utils_2.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array
    var t = numTo32b(d ^ (0, utils_2.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)
    var rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)
    var k_ = modN((0, utils_2.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n
    if (k_ === _0n)
        throw new Error('sign failed: k is zero'); // Fail if k' = 0.
    var _b = schnorrGetExtPubKey(k_), rx = _b.bytes, k = _b.scalar; // Let R = k'⋅G.
    var e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.
    var sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).
    sig.set(rx, 0);
    sig.set(numTo32b(modN(k + e * d)), 32);
    // If Verify(bytes(P), m, sig) (see below) returns failure, abort
    if (!schnorrVerify(sig, m, px))
        throw new Error('sign: Invalid signature produced');
    return sig;
}
/**
 * Verifies Schnorr signature.
 * Will swallow errors & return false except for initial type validation of arguments.
 */
function schnorrVerify(signature, message, publicKey) {
    var sig = (0, utils_2.ensureBytes)('signature', signature, 64);
    var m = (0, utils_2.ensureBytes)('message', message);
    var pub = (0, utils_2.ensureBytes)('publicKey', publicKey, 32);
    try {
        var P = lift_x((0, utils_2.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails
        var r = (0, utils_2.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.
        if (!fe(r))
            return false;
        var s = (0, utils_2.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.
        if (!ge(s))
            return false;
        var e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n
        var R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P
        if (!R || !R.hasEvenY() || R.toAffine().x !== r)
            return false; // -eP == (n-e)P
        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.
    }
    catch (error) {
        return false;
    }
}
exports.signSchnorr = schnorrSign;
exports.verifySchnorr = schnorrVerify;
exports.schnorr = (function () { return ({
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    utils: {
        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
        lift_x: lift_x,
        pointToBytes: pointToBytes,
        numberToBytesBE: utils_2.numberToBytesBE,
        bytesToNumberBE: utils_2.bytesToNumberBE,
        taggedHash: taggedHash,
        mod: modular_1.mod,
    },
}); })();
var isoMap = /* @__PURE__ */ (function () {
    return (0, hash_to_curve_1.isogenyMap)(Fp, [
        // xNum
        [
            '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',
            '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',
            '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',
            '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',
        ],
        // xDen
        [
            '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',
            '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',
            '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
        ],
        // yNum
        [
            '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',
            '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',
            '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',
            '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',
        ],
        // yDen
        [
            '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',
            '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',
            '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',
            '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
        ],
    ].map(function (i) { return i.map(function (j) { return BigInt(j); }); }));
})();
var mapSWU = /* @__PURE__ */ (function () {
    return (0, weierstrass_1.mapToCurveSimpleSWU)(Fp, {
        A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),
        B: BigInt('1771'),
        Z: Fp.create(BigInt('-11')),
    });
})();
var htf = /* @__PURE__ */ (function () {
    return (0, hash_to_curve_1.createHasher)(exports.secp256k1.ProjectivePoint, function (scalars) {
        var _a = mapSWU(Fp.create(scalars[0])), x = _a.x, y = _a.y;
        return isoMap(x, y);
    }, {
        DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',
        encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',
        p: Fp.ORDER,
        m: 1,
        k: 128,
        expand: 'xmd',
        hash: sha256_1.sha256,
    });
})();
exports.hashToCurve = (function () { return htf.hashToCurve; })();
exports.encodeToCurve = (function () { return htf.encodeToCurve; })();
function signSecp256k1(data, privateKey, extraEntropy) {
    return exports.secp256k1.sign(data, privateKey, { extraEntropy: extraEntropy }).toCompactRawBytes();
}
exports.signSecp256k1 = signSecp256k1;
var myDefaultVerOpts = { lowS: true, prehash: false };
function verifySecp256k1(sig, msgHash, pubKey) {
    return exports.secp256k1.verify(sig, msgHash, pubKey, myDefaultVerOpts);
}
exports.verifySecp256k1 = verifySecp256k1;
