"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.add5H = exports.add5L = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
/*
THIS IMPLEMENTATION WAS TAKEN FROM `@noble/hashes`

original source: https://github.com/paulmillr/noble-hashes/blob/6ae82e75d4c354d53a488e95b1bfe9cba90bd6ff/src/_u64.ts#L1

it was modified and adapted to this repository to re-use already defined stuff

the main reason for copying over and not using as dependency is because of different target in the `tsconfig.json`

`@noble/hashes` targets es2020, which tends to cause problems with some other (older) packages sometimes

this repo targets ES5+
*/
var U32_MASK64 = /* @__PURE__ */ BigInt(Math.pow(2, 32) - 1);
var _32n = /* @__PURE__ */ BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le) {
    if (le === void 0) { le = false; }
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
exports.fromBig = fromBig;
function split(lst, le) {
    var _a;
    if (le === void 0) { le = false; }
    var Ah = new Uint32Array(lst.length);
    var Al = new Uint32Array(lst.length);
    for (var i = 0; i < lst.length; i++) {
        var _b = fromBig(lst[i], le), h = _b.h, l = _b.l;
        _a = __read([h, l], 2), Ah[i] = _a[0], Al[i] = _a[1];
    }
    return [Ah, Al];
}
exports.split = split;
var toBig = function (h, l) { return (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0); };
exports.toBig = toBig;
// for Shift in [0, 32)
var shrSH = function (h, _l, s) { return h >>> s; };
exports.shrSH = shrSH;
var shrSL = function (h, l, s) { return (h << (32 - s)) | (l >>> s); };
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
var rotrSH = function (h, l, s) { return (h >>> s) | (l << (32 - s)); };
exports.rotrSH = rotrSH;
var rotrSL = function (h, l, s) { return (h << (32 - s)) | (l >>> s); };
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
var rotrBH = function (h, l, s) { return (h << (64 - s)) | (l >>> (s - 32)); };
exports.rotrBH = rotrBH;
var rotrBL = function (h, l, s) { return (h >>> (s - 32)) | (l << (64 - s)); };
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
var rotr32H = function (_h, l) { return l; };
exports.rotr32H = rotr32H;
var rotr32L = function (h, _l) { return h; };
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
var rotlSH = function (h, l, s) { return (h << s) | (l >>> (32 - s)); };
exports.rotlSH = rotlSH;
var rotlSL = function (h, l, s) { return (l << s) | (h >>> (32 - s)); };
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
var rotlBH = function (h, l, s) { return (l << (s - 32)) | (h >>> (64 - s)); };
exports.rotlBH = rotlBH;
var rotlBL = function (h, l, s) { return (h << (s - 32)) | (l >>> (64 - s)); };
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    var l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / Math.pow(2, 32)) | 0)) | 0, l: l | 0 };
}
exports.add = add;
// Addition with more than 2 elements
var add3L = function (Al, Bl, Cl) { return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0); };
exports.add3L = add3L;
var add3H = function (low, Ah, Bh, Ch) {
    return (Ah + Bh + Ch + ((low / Math.pow(2, 32)) | 0)) | 0;
};
exports.add3H = add3H;
var add4L = function (Al, Bl, Cl, Dl) {
    return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
};
exports.add4L = add4L;
var add4H = function (low, Ah, Bh, Ch, Dh) {
    return (Ah + Bh + Ch + Dh + ((low / Math.pow(2, 32)) | 0)) | 0;
};
exports.add4H = add4H;
var add5L = function (Al, Bl, Cl, Dl, El) {
    return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
};
exports.add5L = add5L;
var add5H = function (low, Ah, Bh, Ch, Dh, Eh) {
    return (Ah + Bh + Ch + Dh + Eh + ((low / Math.pow(2, 32)) | 0)) | 0;
};
exports.add5H = add5H;
