"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HashMD = exports.Maj = exports.Chi = void 0;
var _assert_1 = require("./_assert.js");
var utils_1 = require("./utils.js");
// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    var _32n = BigInt(32);
    var _u32_max = BigInt(0xffffffff);
    var wh = Number((value >> _32n) & _u32_max);
    var wl = Number(value & _u32_max);
    var h = isLE ? 4 : 0;
    var l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
// Choice: a ? b : c
var Chi = function (a, b, c) { return (a & b) ^ (~a & c); };
exports.Chi = Chi;
// Majority function, true if any two inpust is true
var Maj = function (a, b, c) { return (a & b) ^ (a & c) ^ (b & c); };
exports.Maj = Maj;
/**
 * Merkle-Damgard hash construction base class.
 * Could be used to create MD5, RIPEMD, SHA1, SHA2.
 */
var HashMD = /** @class */ (function (_super) {
    __extends(HashMD, _super);
    function HashMD(blockLen, outputLen, padOffset, isLE) {
        var _this = _super.call(this) || this;
        _this.blockLen = blockLen;
        _this.outputLen = outputLen;
        _this.padOffset = padOffset;
        _this.isLE = isLE;
        _this.finished = false;
        _this.length = 0;
        _this.pos = 0;
        _this.destroyed = false;
        _this.buffer = new Uint8Array(blockLen);
        _this.view = (0, utils_1.createView)(_this.buffer);
        return _this;
    }
    HashMD.prototype.update = function (data) {
        (0, _assert_1.exists)(this);
        var _a = this, view = _a.view, buffer = _a.buffer, blockLen = _a.blockLen;
        data = (0, utils_1.toBytes)(data);
        var len = data.length;
        for (var pos = 0; pos < len;) {
            var take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                var dataView = (0, utils_1.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    };
    HashMD.prototype.digestInto = function (out) {
        (0, _assert_1.exists)(this);
        (0, _assert_1.output)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        var _a = this, buffer = _a.buffer, view = _a.view, blockLen = _a.blockLen, isLE = _a.isLE;
        var pos = this.pos;
        // append the bit '1' to the message
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (var i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        var oview = (0, utils_1.createView)(out);
        var len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        var outLen = len / 4;
        var state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (var i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    };
    HashMD.prototype.digest = function () {
        var _a = this, buffer = _a.buffer, outputLen = _a.outputLen;
        this.digestInto(buffer);
        var res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    };
    HashMD.prototype._cloneInto = function (to) {
        to || (to = new this.constructor());
        to.set.apply(to, __spreadArray([], __read(this.get()), false));
        var _a = this, blockLen = _a.blockLen, buffer = _a.buffer, length = _a.length, finished = _a.finished, destroyed = _a.destroyed, pos = _a.pos;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    };
    return HashMD;
}(utils_1.Hash));
exports.HashMD = HashMD;
