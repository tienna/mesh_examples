"use strict";
/*
THIS IMPLEMENTATION WAS TAKEN FROM `@noble/hashes`

original source: https://github.com/paulmillr/noble-curves/blob/38a4ca1e6b0a80c60b11bbb6b3d71e3bfabd5bbb/src/abstract/weierstrass.ts

it was modified and adapted to this repository

the main reason for copying over and not using as dependency is because of different target in the `tsconfig.json`

`@noble/hashes` targets es2020, which tends to cause problems with some other (older) packages sometimes

this repo targets ES5+
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Short Weierstrass curve. The formula is: y² = x³ + ax + b
var mod = __importStar(require("./modular.js"));
var ut = __importStar(require("./utils.js"));
var utils_1 = require("./utils.js");
var curve_1 = require("./curve.js");
function validatePointOpts(curve) {
    var opts = (0, curve_1.validateBasic)(curve);
    ut.validateObject(opts, {
        a: 'field',
        b: 'field',
    }, {
        allowedPrivateKeyLengths: 'array',
        wrapPrivateKey: 'boolean',
        isTorsionFree: 'function',
        clearCofactor: 'function',
        allowInfinityPoint: 'boolean',
        fromBytes: 'function',
        toBytes: 'function',
    });
    var endo = opts.endo, Fp = opts.Fp, a = opts.a;
    if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');
        }
        if (typeof endo !== 'object' ||
            typeof endo.beta !== 'bigint' ||
            typeof endo.splitScalar !== 'function') {
            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');
        }
    }
    return Object.freeze(__assign({}, opts));
}
// ASN.1 DER encoding utilities
var b2n = ut.bytesToNumberBE, h2b = ut.hexToBytes;
exports.DER = {
    // asn.1 DER encoding utils
    Err: /** @class */ (function (_super) {
        __extends(DERErr, _super);
        function DERErr(m) {
            if (m === void 0) { m = ''; }
            return _super.call(this, m) || this;
        }
        return DERErr;
    }(Error)),
    _parseInt: function (data) {
        var E = exports.DER.Err;
        if (data.length < 2 || data[0] !== 0x02)
            throw new E('Invalid signature integer tag');
        var len = data[1];
        var res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
            throw new E('Invalid signature integer: wrong length');
        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
        // since we always use positive integers here. It must always be empty:
        // - add zero byte if exists
        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
        if (res[0] & 128)
            throw new E('Invalid signature integer: negative');
        if (res[0] === 0x00 && !(res[1] & 128))
            throw new E('Invalid signature integer: unnecessary leading zero');
        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left
    },
    toSig: function (hex) {
        // parse DER signature
        var E = exports.DER.Err;
        var data = typeof hex === 'string' ? h2b(hex) : hex;
        ut.abytes(data);
        var l = data.length;
        if (l < 2 || data[0] != 0x30)
            throw new E('Invalid signature tag');
        if (data[1] !== l - 2)
            throw new E('Invalid signature: incorrect length');
        var _a = exports.DER._parseInt(data.subarray(2)), r = _a.d, sBytes = _a.l;
        var _b = exports.DER._parseInt(sBytes), s = _b.d, rBytesLeft = _b.l;
        if (rBytesLeft.length)
            throw new E('Invalid signature: left bytes after parsing');
        return { r: r, s: s };
    },
    hexFromSig: function (sig) {
        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'
        var slice = function (s) { return (Number.parseInt(s[0], 16) & 8 ? '00' + s : s); };
        var h = function (num) {
            var hex = num.toString(16);
            return hex.length & 1 ? "0".concat(hex) : hex;
        };
        var s = slice(h(sig.s));
        var r = slice(h(sig.r));
        var shl = s.length / 2;
        var rhl = r.length / 2;
        var sl = h(shl);
        var rl = h(rhl);
        return "30".concat(h(rhl + shl + 4), "02").concat(rl).concat(r, "02").concat(sl).concat(s);
    },
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
var _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function weierstrassPoints(opts) {
    var CURVE = validatePointOpts(opts);
    var Fp = CURVE.Fp; // All curves has same field / group length as for now, but they can differ
    var toBytes = CURVE.toBytes ||
        (function (_c, point, _isCompressed) {
            var a = point.toAffine();
            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));
        });
    var fromBytes = CURVE.fromBytes ||
        (function (bytes) {
            // const head = bytes[0];
            var tail = bytes.subarray(1);
            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');
            var x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            var y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x: x, y: y };
        });
    /**
     * y² = x³ + ax + b: Short weierstrass curve formula
     * @returns y²
     */
    function weierstrassEquation(x) {
        var a = CURVE.a, b = CURVE.b;
        var x2 = Fp.sqr(x); // x * x
        var x3 = Fp.mul(x2, x); // x2 * x
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b
    }
    // Validate whether the passed curve params are valid.
    // We check if curve equation works for generator point.
    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.
    // ProjectivePoint class has not been initialized yet.
    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error('bad generator point: equation left != right');
    // Valid group elements reside in range 1..n-1
    function isWithinCurveOrder(num) {
        return typeof num === 'bigint' && _0n < num && num < CURVE.n;
    }
    function assertGE(num) {
        if (!isWithinCurveOrder(num))
            throw new Error('Expected valid bigint: 0 < bigint < curve.n');
    }
    // Validates if priv key is valid and converts it to bigint.
    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.
    function normPrivateKeyToScalar(key) {
        var lengths = CURVE.allowedPrivateKeyLengths, nByteLength = CURVE.nByteLength, wrapPrivateKey = CURVE.wrapPrivateKey, n = CURVE.n;
        if (lengths && typeof key !== 'bigint') {
            if (ut.isBytes(key))
                key = ut.bytesToHex(key);
            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes
            if (typeof key !== 'string' || !lengths.includes(key.length))
                throw new Error('Invalid key');
            key = key.padStart(nByteLength * 2, '0');
        }
        var num;
        try {
            num =
                typeof key === 'bigint'
                    ? key
                    : ut.bytesToNumberBE((0, utils_1.ensureBytes)('private key', key, nByteLength));
        }
        catch (error) {
            throw new Error("private key must be ".concat(nByteLength, " bytes, hex or bigint, not ").concat(typeof key));
        }
        if (wrapPrivateKey)
            num = mod.mod(num, n); // disabled by default, enabled for BLS
        assertGE(num); // num in range [1..N-1]
        return num;
    }
    var pointPrecomputes = new Map();
    function assertPrjPoint(other) {
        if (!(other instanceof Point))
            throw new Error('ProjectivePoint expected');
    }
    /**
     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)
     * Default Point works in 2d / affine coordinates: (x, y)
     * We're doing calculations in projective, because its operations don't require costly inversion.
     */
    var Point = /** @class */ (function () {
        function Point(px, py, pz) {
            this.px = px;
            this.py = py;
            this.pz = pz;
            if (px == null || !Fp.isValid(px))
                throw new Error('x required');
            if (py == null || !Fp.isValid(py))
                throw new Error('y required');
            if (pz == null || !Fp.isValid(pz))
                throw new Error('z required');
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        Point.fromAffine = function (p) {
            var _a = p || {}, x = _a.x, y = _a.y;
            if (!p || !Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('invalid affine point');
            if (p instanceof Point)
                throw new Error('projective point not allowed');
            var is0 = function (i) { return Fp.eql(i, Fp.ZERO); };
            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)
            if (is0(x) && is0(y))
                return Point.ZERO;
            return new Point(x, y, Fp.ONE);
        };
        Object.defineProperty(Point.prototype, "x", {
            get: function () {
                return this.toAffine().x;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Point.prototype, "y", {
            get: function () {
                return this.toAffine().y;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        Point.normalizeZ = function (points) {
            var toInv = Fp.invertBatch(points.map(function (p) { return p.pz; }));
            return points.map(function (p, i) { return p.toAffine(toInv[i]); }).map(Point.fromAffine);
        };
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        Point.fromHex = function (hex) {
            var P = Point.fromAffine(fromBytes((0, utils_1.ensureBytes)('pointHex', hex)));
            P.assertValidity();
            return P;
        };
        // Multiplies generator point by privateKey.
        Point.fromPrivateKey = function (privateKey) {
            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        };
        // "Private method", don't use it directly
        Point.prototype._setWindowSize = function (windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
        };
        // A point on curve is valid if it conforms to equation.
        Point.prototype.assertValidity = function () {
            if (this.is0()) {
                // (0, 1, 0) aka ZERO is invalid in most contexts.
                // In BLS, ZERO can be serialized, so we allow it.
                // (0, 0, 0) is wrong representation of ZERO and is always invalid.
                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
                    return;
                throw new Error('bad point: ZERO');
            }
            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
            var _a = this.toAffine(), x = _a.x, y = _a.y;
            // Check if x, y are valid field elements
            if (!Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('bad point: x or y not FE');
            var left = Fp.sqr(y); // y²
            var right = weierstrassEquation(x); // x³ + ax + b
            if (!Fp.eql(left, right))
                throw new Error('bad point: equation left != right');
            if (!this.isTorsionFree())
                throw new Error('bad point: not in prime-order subgroup');
        };
        Point.prototype.hasEvenY = function () {
            var y = this.toAffine().y;
            if (Fp.isOdd)
                return !Fp.isOdd(y);
            throw new Error("Field doesn't support isOdd");
        };
        /**
         * Compare one point to another.
         */
        Point.prototype.equals = function (other) {
            assertPrjPoint(other);
            var _a = this, X1 = _a.px, Y1 = _a.py, Z1 = _a.pz;
            var X2 = other.px, Y2 = other.py, Z2 = other.pz;
            var U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            var U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        };
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        Point.prototype.negate = function () {
            return new Point(this.px, Fp.neg(this.py), this.pz);
        };
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        Point.prototype.double = function () {
            var a = CURVE.a, b = CURVE.b;
            var b3 = Fp.mul(b, _3n);
            var _a = this, X1 = _a.px, Y1 = _a.py, Z1 = _a.pz;
            var X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            var t0 = Fp.mul(X1, X1); // step 1
            var t1 = Fp.mul(Y1, Y1);
            var t2 = Fp.mul(Z1, Z1);
            var t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
        };
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        Point.prototype.add = function (other) {
            assertPrjPoint(other);
            var _a = this, X1 = _a.px, Y1 = _a.py, Z1 = _a.pz;
            var X2 = other.px, Y2 = other.py, Z2 = other.pz;
            var X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            var a = CURVE.a;
            var b3 = Fp.mul(CURVE.b, _3n);
            var t0 = Fp.mul(X1, X2); // step 1
            var t1 = Fp.mul(Y1, Y2);
            var t2 = Fp.mul(Z1, Z2);
            var t3 = Fp.add(X1, Y1);
            var t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            var t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
        };
        Point.prototype.subtract = function (other) {
            return this.add(other.negate());
        };
        Point.prototype.is0 = function () {
            return this.equals(Point.ZERO);
        };
        Point.prototype.wNAF = function (n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, function (comp) {
                var toInv = Fp.invertBatch(comp.map(function (p) { return p.pz; }));
                return comp.map(function (p, i) { return p.toAffine(toInv[i]); }).map(Point.fromAffine);
            });
        };
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        Point.prototype.multiplyUnsafe = function (n) {
            var I = Point.ZERO;
            if (n === _0n)
                return I;
            assertGE(n); // Will throw on 0
            if (n === _1n)
                return this;
            var endo = CURVE.endo;
            if (!endo)
                return wnaf.unsafeLadder(this, n);
            // Apply endomorphism
            var _a = endo.splitScalar(n), k1neg = _a.k1neg, k1 = _a.k1, k2neg = _a.k2neg, k2 = _a.k2;
            var k1p = I;
            var k2p = I;
            var d = this;
            while (k1 > _0n || k2 > _0n) {
                if (k1 & _1n)
                    k1p = k1p.add(d);
                if (k2 & _1n)
                    k2p = k2p.add(d);
                d = d.double();
                k1 >>= _1n;
                k2 >>= _1n;
            }
            if (k1neg)
                k1p = k1p.negate();
            if (k2neg)
                k2p = k2p.negate();
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            return k1p.add(k2p);
        };
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        Point.prototype.multiply = function (scalar) {
            assertGE(scalar);
            var n = scalar;
            var point, fake; // Fake point is used to const-time mult
            var endo = CURVE.endo;
            if (endo) {
                var _a = endo.splitScalar(n), k1neg = _a.k1neg, k1 = _a.k1, k2neg = _a.k2neg, k2 = _a.k2;
                var _b = this.wNAF(k1), k1p = _b.p, f1p = _b.f;
                var _d = this.wNAF(k2), k2p = _d.p, f2p = _d.f;
                k1p = wnaf.constTimeNegate(k1neg, k1p);
                k2p = wnaf.constTimeNegate(k2neg, k2p);
                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
                point = k1p.add(k2p);
                fake = f1p.add(f2p);
            }
            else {
                var _e = this.wNAF(n), p = _e.p, f = _e.f;
                point = p;
                fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return Point.normalizeZ([point, fake])[0];
        };
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        Point.prototype.multiplyAndAddUnsafe = function (Q, a, b) {
            var G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes
            var mul = function (P, a // Select faster multiply() method
            ) { return (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a)); };
            var sum = mul(this, a).add(mul(Q, b));
            return sum.is0() ? undefined : sum;
        };
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z) ∋ (x=x/z, y=y/z)
        Point.prototype.toAffine = function (iz) {
            var _a = this, x = _a.px, y = _a.py, z = _a.pz;
            var is0 = this.is0();
            // If invZ was 0, we return zero point. However we still want to execute
            // all operations, so we replace invZ with a random number, 1.
            if (iz == null)
                iz = is0 ? Fp.ONE : Fp.inv(z);
            var ax = Fp.mul(x, iz);
            var ay = Fp.mul(y, iz);
            var zz = Fp.mul(z, iz);
            if (is0)
                return { x: Fp.ZERO, y: Fp.ZERO };
            if (!Fp.eql(zz, Fp.ONE))
                throw new Error('invZ was invalid');
            return { x: ax, y: ay };
        };
        Point.prototype.isTorsionFree = function () {
            var cofactor = CURVE.h, isTorsionFree = CURVE.isTorsionFree;
            if (cofactor === _1n)
                return true; // No subgroups, always torsion-free
            if (isTorsionFree)
                return isTorsionFree(Point, this);
            throw new Error('isTorsionFree() has not been declared for the elliptic curve');
        };
        Point.prototype.clearCofactor = function () {
            var cofactor = CURVE.h, clearCofactor = CURVE.clearCofactor;
            if (cofactor === _1n)
                return this; // Fast-path
            if (clearCofactor)
                return clearCofactor(Point, this);
            return this.multiplyUnsafe(CURVE.h);
        };
        Point.prototype.toRawBytes = function (isCompressed) {
            if (isCompressed === void 0) { isCompressed = true; }
            this.assertValidity();
            return toBytes(Point, this, isCompressed);
        };
        Point.prototype.toHex = function (isCompressed) {
            if (isCompressed === void 0) { isCompressed = true; }
            return ut.bytesToHex(this.toRawBytes(isCompressed));
        };
        Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
        Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
        return Point;
    }());
    var _bits = CURVE.nBitLength;
    var wnaf = (0, curve_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    // Validate if generator point is on curve
    return {
        CURVE: CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        weierstrassEquation: weierstrassEquation,
        isWithinCurveOrder: isWithinCurveOrder,
    };
}
exports.weierstrassPoints = weierstrassPoints;
function validateOpts(curve) {
    var opts = (0, curve_1.validateBasic)(curve);
    ut.validateObject(opts, {
        hash: 'hash',
        hmac: 'function',
        randomBytes: 'function',
    }, {
        bits2int: 'function',
        bits2int_modN: 'function',
        lowS: 'boolean',
    });
    return Object.freeze(__assign({ lowS: true }, opts));
}
function weierstrass(curveDef) {
    var CURVE = validateOpts(curveDef);
    var Fp = CURVE.Fp, CURVE_ORDER = CURVE.n;
    var compressedLen = Fp.BYTES + 1; // e.g. 33 for 32
    var uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32
    function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE
    }
    function modN(a) {
        return mod.mod(a, CURVE_ORDER);
    }
    function invN(a) {
        return mod.invert(a, CURVE_ORDER);
    }
    var _a = weierstrassPoints(__assign(__assign({}, CURVE), { toBytes: function (_c, point, isCompressed) {
            var a = point.toAffine();
            var x = Fp.toBytes(a.x);
            var cat = ut.concatBytes;
            if (isCompressed) {
                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);
            }
            else {
                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));
            }
        }, fromBytes: function (bytes) {
            var len = bytes.length;
            var head = bytes[0];
            var tail = bytes.subarray(1);
            // this.assertValidity() is done inside of fromHex
            if (len === compressedLen && (head === 0x02 || head === 0x03)) {
                var x = ut.bytesToNumberBE(tail);
                if (!isValidFieldElement(x))
                    throw new Error('Point is not on curve');
                var y2 = weierstrassEquation(x); // y² = x³ + ax + b
                var y = void 0;
                try {
                    y = Fp.sqrt(y2); // y = y² ^ (p+1)/4
                }
                catch (sqrtError) {
                    var suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';
                    throw new Error('Point is not on curve' + suffix);
                }
                var isYOdd = (y & _1n) === _1n;
                // ECDSA
                var isHeadOdd = (head & 1) === 1;
                if (isHeadOdd !== isYOdd)
                    y = Fp.neg(y);
                return { x: x, y: y };
            }
            else if (len === uncompressedLen && head === 0x04) {
                var x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
                var y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
                return { x: x, y: y };
            }
            else {
                throw new Error("Point of length ".concat(len, " was invalid. Expected ").concat(compressedLen, " compressed bytes or ").concat(uncompressedLen, " uncompressed bytes"));
            }
        } })), Point = _a.ProjectivePoint, normPrivateKeyToScalar = _a.normPrivateKeyToScalar, weierstrassEquation = _a.weierstrassEquation, isWithinCurveOrder = _a.isWithinCurveOrder;
    var numToNByteStr = function (num) {
        return ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
    };
    function isBiggerThanHalfOrder(number) {
        var HALF = CURVE_ORDER >> _1n;
        return number > HALF;
    }
    function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
    }
    // slice bytes num
    var slcNum = function (b, from, to) { return ut.bytesToNumberBE(b.slice(from, to)); };
    /**
     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
     */
    var Signature = /** @class */ (function () {
        function Signature(r, s, recovery) {
            this.r = r;
            this.s = s;
            this.recovery = recovery;
            this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        Signature.fromCompact = function (hex) {
            var l = CURVE.nByteLength;
            hex = (0, utils_1.ensureBytes)('compactSignature', hex, l * 2);
            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        };
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        Signature.fromDER = function (hex) {
            var _a = exports.DER.toSig((0, utils_1.ensureBytes)('DER', hex)), r = _a.r, s = _a.s;
            return new Signature(r, s);
        };
        Signature.prototype.assertValidity = function () {
            // can use assertGE here
            if (!isWithinCurveOrder(this.r))
                throw new Error('r must be 0 < r < CURVE.n');
            if (!isWithinCurveOrder(this.s))
                throw new Error('s must be 0 < s < CURVE.n');
        };
        Signature.prototype.addRecoveryBit = function (recovery) {
            return new Signature(this.r, this.s, recovery);
        };
        Signature.prototype.recoverPublicKey = function (msgHash) {
            var _a = this, r = _a.r, s = _a.s, rec = _a.recovery;
            var h = bits2int_modN((0, utils_1.ensureBytes)('msgHash', msgHash)); // Truncate hash
            if (rec == null || ![0, 1, 2, 3].includes(rec))
                throw new Error('recovery id invalid');
            var radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
            if (radj >= Fp.ORDER)
                throw new Error('recovery id 2 or 3 invalid');
            var prefix = (rec & 1) === 0 ? '02' : '03';
            var R = Point.fromHex(prefix + numToNByteStr(radj));
            var ir = invN(radj); // r^-1
            var u1 = modN(-h * ir); // -hr^-1
            var u2 = modN(s * ir); // sr^-1
            var Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)
            if (!Q)
                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked
            Q.assertValidity();
            return Q;
        };
        // Signatures should be low-s, to prevent malleability.
        Signature.prototype.hasHighS = function () {
            return isBiggerThanHalfOrder(this.s);
        };
        Signature.prototype.normalizeS = function () {
            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        };
        // DER-encoded
        Signature.prototype.toDERRawBytes = function () {
            return ut.hexToBytes(this.toDERHex());
        };
        Signature.prototype.toDERHex = function () {
            return exports.DER.hexFromSig({ r: this.r, s: this.s });
        };
        // padded bytes of r, then padded bytes of s
        Signature.prototype.toCompactRawBytes = function () {
            return ut.hexToBytes(this.toCompactHex());
        };
        Signature.prototype.toCompactHex = function () {
            return numToNByteStr(this.r) + numToNByteStr(this.s);
        };
        return Signature;
    }());
    var utils = {
        isValidPrivateKey: function (privateKey) {
            try {
                normPrivateKeyToScalar(privateKey);
                return true;
            }
            catch (error) {
                return false;
            }
        },
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: function () {
            var length = mod.getMinHashLength(CURVE.n);
            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute: function (windowSize, point) {
            if (windowSize === void 0) { windowSize = 8; }
            if (point === void 0) { point = Point.BASE; }
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here
            return point;
        },
    };
    /**
     * Computes public key for a private key. Checks for validity of the private key.
     * @param privateKey private key
     * @param isCompressed whether to return compact (default), or full key
     * @returns Public key, full when isCompressed=false; short when isCompressed=true
     */
    function getPublicKey(privateKey, isCompressed) {
        if (isCompressed === void 0) { isCompressed = true; }
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    /**
     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
     */
    function isProbPub(item) {
        var arr = ut.isBytes(item);
        var str = typeof item === 'string';
        var len = (arr || str) && item.length;
        if (arr)
            return len === compressedLen || len === uncompressedLen;
        if (str)
            return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
            return true;
        return false;
    }
    /**
     * ECDH (Elliptic Curve Diffie Hellman).
     * Computes shared public key from private key and public key.
     * Checks: 1) private key validity 2) shared key is on-curve.
     * Does NOT hash the result.
     * @param privateA private key
     * @param publicB different public key
     * @param isCompressed whether to return compact (default), or full key
     * @returns shared public key
     */
    function getSharedSecret(privateA, publicB, isCompressed) {
        if (isCompressed === void 0) { isCompressed = true; }
        if (isProbPub(privateA))
            throw new Error('first arg must be private key');
        if (!isProbPub(publicB))
            throw new Error('second arg must be public key');
        var b = Point.fromHex(publicB); // check for being on-curve
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
    var bits2int = CURVE.bits2int ||
        function (bytes) {
            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
            // for some cases, since bytes.length * 8 is not actual bitLength.
            var num = ut.bytesToNumberBE(bytes); // check for == u8 done here
            var delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits
            return delta > 0 ? num >> BigInt(delta) : num;
        };
    var bits2int_modN = CURVE.bits2int_modN ||
        function (bytes) {
            return modN(bits2int(bytes)); // can't use bytesToNumberBE here
        };
    // NOTE: pads output with zero as per spec
    var ORDER_MASK = ut.bitMask(CURVE.nBitLength);
    /**
     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
     */
    function int2octets(num) {
        if (typeof num !== 'bigint')
            throw new Error('bigint expected');
        if (!(_0n <= num && num < ORDER_MASK))
            throw new Error("bigint expected < 2^".concat(CURVE.nBitLength));
        // works with order, can have different size than numToField!
        return ut.numberToBytesBE(num, CURVE.nByteLength);
    }
    // Steps A, D of RFC6979 3.2
    // Creates RFC6979 seed; converts msg/privKey to numbers.
    // Used only in sign, not in verify.
    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.
    // Also it can be bigger for P224 + SHA256
    function prepSig(msgHash, privateKey, opts) {
        if (opts === void 0) { opts = defaultSigOpts; }
        if (['recovered', 'canonical'].some(function (k) { return k in opts; }))
            throw new Error('sign() legacy options not supported');
        var hash = CURVE.hash, randomBytes = CURVE.randomBytes;
        var lowS = opts.lowS, prehash = opts.prehash, ent = opts.extraEntropy; // generates low-s sigs by default
        if (lowS == null)
            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
        msgHash = (0, utils_1.ensureBytes)('msgHash', msgHash);
        if (prehash)
            msgHash = (0, utils_1.ensureBytes)('prehashed msgHash', hash(msgHash));
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        var h1int = bits2int_modN(msgHash);
        var d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
        var seedArgs = [int2octets(d), int2octets(h1int)];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (ent != null && ent !== false) {
            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
            var e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is
            seedArgs.push((0, utils_1.ensureBytes)('extraEntropy', e)); // check for being bytes
        }
        var seed = ut.concatBytes.apply(ut, __spreadArray([], __read(seedArgs), false)); // Step D of RFC6979 3.2
        var m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        function k2sig(kBytes) {
            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
            var k = bits2int(kBytes); // Cannot use fields methods, since it is group element
            if (!isWithinCurveOrder(k))
                return; // Important: all mod() calls here must be done over N
            var ik = invN(k); // k^-1 mod n
            var q = Point.BASE.multiply(k).toAffine(); // q = Gk
            var r = modN(q.x); // r = q.x mod n
            if (r === _0n)
                return;
            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to
            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
            var s = modN(ik * modN(m + r * d)); // Not using blinding here
            if (s === _0n)
                return;
            var recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
            var normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
                normS = normalizeS(s); // if lowS was passed, ensure s is always
                recovery ^= 1; // // in the bottom half of N
            }
            return new Signature(r, normS, recovery); // use normS, not s
        }
        return { seed: seed, k2sig: k2sig };
    }
    var defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    var defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    /**
     * Signs message hash with a private key.
     * ```
     * sign(m, d, k) where
     *   (x, y) = G × k
     *   r = x mod n
     *   s = (m + dr)/k mod n
     * ```
     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
     * @param privKey private key
     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
     * @returns signature with recovery param
     */
    function sign(msgHash, privKey, opts) {
        if (opts === void 0) { opts = defaultSigOpts; }
        var _a = prepSig(msgHash, privKey, opts), seed = _a.seed, k2sig = _a.k2sig; // Steps A, D of RFC6979 3.2.
        var C = CURVE;
        var drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig); // Steps B, C, D, E, F, G
    }
    // Enable precomputes. Slows down first publicKey computation by 20ms.
    Point.BASE._setWindowSize(8);
    // utils.precompute(8, ProjectivePoint.BASE)
    /**
     * Verifies a signature against message hash and public key.
     * Rejects lowS signatures by default: to override,
     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
     *
     * ```
     * verify(r, s, h, P) where
     *   U1 = hs^-1 mod n
     *   U2 = rs^-1 mod n
     *   R = U1⋅G - U2⋅P
     *   mod(R.x, n) == r
     * ```
     */
    function verify(signature, msgHash, publicKey, opts) {
        var _a;
        if (opts === void 0) { opts = defaultVerOpts; }
        var sg = signature;
        msgHash = (0, utils_1.ensureBytes)('msgHash', msgHash);
        publicKey = (0, utils_1.ensureBytes)('publicKey', publicKey);
        if ('strict' in opts)
            throw new Error('options.strict was renamed to lowS');
        var lowS = opts.lowS, prehash = opts.prehash;
        var _sig = undefined;
        var P;
        try {
            if (typeof sg === 'string' || ut.isBytes(sg)) {
                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).
                // Since DER can also be 2*nByteLength bytes, we check for it first.
                try {
                    _sig = Signature.fromDER(sg);
                }
                catch (derError) {
                    if (!(derError instanceof exports.DER.Err))
                        throw derError;
                    _sig = Signature.fromCompact(sg);
                }
            }
            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {
                var r_1 = sg.r, s_1 = sg.s;
                _sig = new Signature(r_1, s_1);
            }
            else {
                throw new Error('PARSE');
            }
            P = Point.fromHex(publicKey);
        }
        catch (error) {
            if (error.message === 'PARSE')
                throw new Error("signature must be Signature instance, Uint8Array or hex string");
            return false;
        }
        if (lowS && _sig.hasHighS())
            return false;
        if (prehash)
            msgHash = CURVE.hash(msgHash);
        var r = _sig.r, s = _sig.s;
        var h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
        var is = invN(s); // s^-1
        var u1 = modN(h * is); // u1 = hs^-1 mod n
        var u2 = modN(r * is); // u2 = rs^-1 mod n
        var R = (_a = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)) === null || _a === void 0 ? void 0 : _a.toAffine(); // R = u1⋅G + u2⋅P
        if (!R)
            return false;
        var v = modN(R.x);
        return v === r;
    }
    return {
        CURVE: CURVE,
        getPublicKey: getPublicKey,
        getSharedSecret: getSharedSecret,
        sign: sign,
        verify: verify,
        ProjectivePoint: Point,
        Signature: Signature,
        utils: utils,
    };
}
exports.weierstrass = weierstrass;
/**
 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
 * b = False and y = sqrt(Z * (u / v)) otherwise.
 * @param Fp
 * @param Z
 * @returns
 */
function SWUFpSqrtRatio(Fp, Z) {
    // Generic implementation
    var q = Fp.ORDER;
    var l = _0n;
    for (var o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
    var c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
    // 2n ** c1 == 2n << (c1-1)
    var _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);
    var _2n_pow_c1 = _2n_pow_c1_1 * _2n;
    var c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
    var c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
    var c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
    var c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
    var c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
    var c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
    var sqrtRatio = function (u, v) {
        var tv1 = c6; // 1. tv1 = c6
        var tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
        var tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
        var tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
        var tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
        var isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
        // 17. for i in (c1, c1 - 1, ..., 2):
        for (var i = c1; i > _1n; i--) {
            var tv5_1 = i - _2n; // 18.    tv5 = i - 2
            tv5_1 = _2n << (tv5_1 - _1n); // 19.    tv5 = 2^tv5
            var tvv5 = Fp.pow(tv4, tv5_1); // 20.    tv5 = tv4^tv5
            var e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
        }
        return { isValid: isQR, value: tv3 };
    };
    if (Fp.ORDER % _4n === _3n) {
        // sqrt_ratio_3mod4(u, v)
        var c1_1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
        var c2_1 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
        sqrtRatio = function (u, v) {
            var tv1 = Fp.sqr(v); // 1. tv1 = v^2
            var tv2 = Fp.mul(u, v); // 2. tv2 = u * v
            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
            var y1 = Fp.pow(tv1, c1_1); // 4. y1 = tv1^c1
            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
            var y2 = Fp.mul(y1, c2_1); // 6. y2 = y1 * c2
            var tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
            var isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
            var y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2
        };
    }
    // No curves uses that
    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
    return sqrtRatio;
}
exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
/**
 * Simplified Shallue-van de Woestijne-Ulas Method
 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
 */
function mapToCurveSimpleSWU(Fp, opts) {
    mod.validateField(Fp);
    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error('mapToCurveSimpleSWU: invalid opts');
    var sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
    if (!Fp.isOdd)
        throw new Error('Fp.isOdd is not implemented!');
    // Input: u, an element of F.
    // Output: (x, y), a point on E.
    return function (u) {
        // prettier-ignore
        var tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1
        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4
        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6
        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6
        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
        var _a = sqrtRatio(tv2, tv6), isValid = _a.isValid, value = _a.value; // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
        y = Fp.mul(y, value); // 20.   y = y * y1
        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
        var e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
        x = Fp.div(x, tv4); // 25.   x = x / tv4
        return { x: x, y: y };
    };
}
exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
