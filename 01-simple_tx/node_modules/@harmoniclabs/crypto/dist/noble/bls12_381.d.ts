/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
import { CurveFn } from './abstract/bls.js';
import * as mod from './abstract/modular.js';
import { AffinePoint } from './abstract/weierstrass.js';
export declare const Fp: Readonly<mod.IField<bigint> & Required<Pick<mod.IField<bigint>, "isOdd">>>;
type Fp = bigint;
type BigintTuple = [bigint, bigint];
type Fp2 = {
    c0: bigint;
    c1: bigint;
};
type Fp2Utils = {
    fromBigTuple: (tuple: BigintTuple | bigint[]) => Fp2;
    reim: (num: Fp2) => {
        re: bigint;
        im: bigint;
    };
    mulByNonresidue: (num: Fp2) => Fp2;
    multiplyByB: (num: Fp2) => Fp2;
    frobeniusMap(num: Fp2, power: number): Fp2;
};
export type Fp2_t = typeof Fp2;
export declare const Fp2: mod.IField<Fp2> & Fp2Utils;
type BigintSix = [bigint, bigint, bigint, bigint, bigint, bigint];
type Fp6 = {
    c0: Fp2;
    c1: Fp2;
    c2: Fp2;
};
type Fp6Utils = {
    fromBigSix: (tuple: BigintSix) => Fp6;
    mulByNonresidue: (num: Fp6) => Fp6;
    frobeniusMap(num: Fp6, power: number): Fp6;
    multiplyBy1(num: Fp6, b1: Fp2): Fp6;
    multiplyBy01(num: Fp6, b0: Fp2, b1: Fp2): Fp6;
    multiplyByFp2(lhs: Fp6, rhs: Fp2): Fp6;
};
declare const Fp6: mod.IField<Fp6> & Fp6Utils;
type Fp12 = {
    c0: Fp6;
    c1: Fp6;
};
type BigintTwelve = [
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint
];
export declare const Fp12Multiply: ({ c0, c1 }: Fp12, rhs: Fp12 | bigint) => {
    c0: Fp6;
    c1: Fp6;
};
type Fp12Utils = {
    fromBigTwelve: (t: BigintTwelve) => Fp12;
    frobeniusMap(num: Fp12, power: number): Fp12;
    multiplyBy014(num: Fp12, o0: Fp2, o1: Fp2, o4: Fp2): Fp12;
    multiplyByFp2(lhs: Fp12, rhs: Fp2): Fp12;
    conjugate(num: Fp12): Fp12;
    finalExponentiate(num: Fp12): Fp12;
    _cyclotomicSquare(num: Fp12): Fp12;
    _cyclotomicExp(num: Fp12, n: bigint): Fp12;
};
export declare const Fp12_finalExponentiate: (num: Fp12) => Fp12;
export declare const Fp12_conjugate: ({ c0, c1 }: Fp12) => Fp12;
export declare const Fp12_eql: ({ c0, c1 }: Fp12, { c0: r0, c1: r1 }: Fp12) => boolean;
export declare const Fp12_ONE: {
    c0: Fp6;
    c1: Fp6;
};
export declare const Fp12: mod.IField<Fp12> & Fp12Utils;
export declare function parseMask(bytes: Uint8Array): {
    compressed: boolean;
    infinity: boolean;
    sort: boolean;
    value: Uint8Array;
};
export declare const G1_formBytes: (bytes: Uint8Array) => AffinePoint<Fp>;
export declare const G1_mapToCurve: (scalars: bigint[]) => {
    x: bigint;
    y: bigint;
};
export declare const G2_mapToCurve: (scalars: bigint[]) => {
    x: Fp2;
    y: Fp2;
};
export declare const bls12_381: CurveFn<Fp, Fp2, Fp6, Fp12>;
export {};
