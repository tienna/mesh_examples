"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isFp6 = exports.isBlsResult = exports.bls12_381_finalVerify = exports.bls12_381_eqMlResult = exports.bls12_381_mulMlResult = exports.bls12_381_millerLoop = exports.bls12_381_G2_uncompress = exports.bls12_381_G2_compress = exports.bls12_381_G2_hashToGroup = exports.bls12_381_G2_equal = exports.bls12_381_G2_scalarMul = exports.bls12_381_G2_neg = exports.bls12_381_G2_add = exports.bls12_381_G1_uncompress = exports.bls12_381_G1_compress = exports.bls12_381_G1_hashToGroup = exports.bls12_381_G1_equal = exports.bls12_381_G1_scalarMul = exports.bls12_381_G1_neg = exports.bls12_381_G1_add = exports.isFp2 = exports.isBlsG2 = exports.isBlsG1 = exports.BlsG2 = exports.BlsG1 = void 0;
var noble_1 = require("./noble/index.js");
var hash_to_curve_1 = require("./noble/abstract/hash-to-curve.js");
var utils_1 = require("./noble/abstract/utils.js");
var sha256_1 = require("./noble/sha256.js");
exports.BlsG1 = noble_1.bls12_381.G1.ProjectivePoint;
exports.BlsG2 = noble_1.bls12_381.G2.ProjectivePoint;
function isBlsG1(stuff) {
    return stuff instanceof exports.BlsG1 && (typeof stuff.px === "bigint" &&
        typeof stuff.py === "bigint" &&
        typeof stuff.pz === "bigint");
}
exports.isBlsG1 = isBlsG1;
function isBlsG2(stuff) {
    return stuff instanceof exports.BlsG2 && (isFp2(stuff.px) &&
        isFp2(stuff.py) &&
        isFp2(stuff.pz));
}
exports.isBlsG2 = isBlsG2;
function isFp2(stuff) {
    return typeof stuff === "object" && (stuff !== null && !Array.isArray(stuff) &&
        typeof stuff.c0 === "bigint" &&
        typeof stuff.c1 === "bigint");
}
exports.isFp2 = isFp2;
var curveOrder = BigInt("52435875175126190479447740508185965837690552500527637822603658699938581184513");
var htfDefaults = Object.freeze({
    // DST: a domain separation tag
    // defined in section 2.2.5
    // Use utils.getDSTLabel(), utils.setDSTLabel(value)
    DST: "",
    encodeDST: "",
    // p: the characteristic of F
    //    where F is a finite field of characteristic p and order q = p^m
    p: noble_1.Fp.ORDER,
    // m: the extension degree of F, m >= 1
    //     where F is a finite field of characteristic p and order q = p^m
    m: 2,
    // k: the target security level for the suite in bits
    // defined in section 5.1
    k: 128,
    // option to use a message that has already been processed by
    // expand_message_xmd
    expand: 'xmd',
    // Hash functions for: expand_message_xmd is appropriate for use with a
    // wide range of hash functions, including SHA-2, SHA-3, BLAKE2, and others.
    // BBS+ uses blake2: https://github.com/hyperledger/aries-framework-go/issues/2247
    hash: sha256_1.sha256,
});
var G2_Hasher = (0, hash_to_curve_1.createHasher)(exports.BlsG2, noble_1.G2_mapToCurve, __assign({}, htfDefaults));
var G1_Hasher = (0, hash_to_curve_1.createHasher)(exports.BlsG1, noble_1.G1_mapToCurve, __assign(__assign({}, htfDefaults), { m: 1, DST: 'BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_' }));
function bls12_381_G1_add(a, b) {
    // if( bls12_381_G1_equal( a, BlsG1.ZERO ) ) return b;
    // if( bls12_381_G1_equal( b, BlsG1.ZERO ) ) return a;
    return a.add(b);
}
exports.bls12_381_G1_add = bls12_381_G1_add;
function bls12_381_G1_neg(elem) {
    return elem.negate();
}
exports.bls12_381_G1_neg = bls12_381_G1_neg;
function bls12_381_G1_scalarMul(n, g1) {
    if (n < 0)
        return bls12_381_G1_scalarMul(-n, bls12_381_G1_neg(g1));
    n = BigInt(n);
    if (n >= curveOrder)
        n = n % curveOrder;
    if (n === BigInt(0))
        return exports.BlsG1.ZERO;
    return g1.multiply(n);
}
exports.bls12_381_G1_scalarMul = bls12_381_G1_scalarMul;
function bls12_381_G1_equal(a, b) {
    return a.equals(b);
}
exports.bls12_381_G1_equal = bls12_381_G1_equal;
function bls12_381_G1_hashToGroup(a, b) {
    // noble-curves can handle that but the plutus-machine doesn't
    // so we artificially throw an error here
    if (b.length > 255)
        throw new Error("DST length can not be greater than 255");
    return exports.BlsG1.fromAffine(G1_Hasher.hashToCurve(a, { DST: b })
        .toAffine());
}
exports.bls12_381_G1_hashToGroup = bls12_381_G1_hashToGroup;
function bls12_381_G1_compress(elem) {
    return elem.toRawBytes();
}
exports.bls12_381_G1_compress = bls12_381_G1_compress;
function bls12_381_G1_uncompress(compressed) {
    var _a = (0, noble_1.parseMask)(compressed), compressed_bit = _a.compressed, infinity = _a.infinity, sort = _a.sort, value = _a.value;
    // point zero edge case
    if (compressed_bit &&
        infinity &&
        sort &&
        value.every(function (n) { return n === 0; }))
        throw new Error("sign bit set on pont ZERO, we don't like it");
    // not compressed bytes would be totally fine for the library but we artificially fail here
    // https://github.com/IntersectMBO/plutus/blob/master/plutus-conformance/test-cases/uplc/evaluation/builtin/semantics/bls12_381_G1_uncompress/on-curve-serialised-not-compressed/on-curve-serialised-not-compressed.uplc
    if (!compressed_bit)
        throw new Error("uncompress only works with compressed byets");
    return exports.BlsG1.fromHex(compressed);
}
exports.bls12_381_G1_uncompress = bls12_381_G1_uncompress;
function bls12_381_G2_add(a, b) {
    // if( bls12_381_G2_equal( a, BlsG2.ZERO ) ) return b;
    // if( bls12_381_G2_equal( b, BlsG2.ZERO ) ) return a;
    return a.add(b);
}
exports.bls12_381_G2_add = bls12_381_G2_add;
function bls12_381_G2_neg(elem) {
    return elem.negate();
}
exports.bls12_381_G2_neg = bls12_381_G2_neg;
function bls12_381_G2_scalarMul(n, g2) {
    if (n < 0)
        return bls12_381_G2_scalarMul(-n, bls12_381_G2_neg(g2));
    n = BigInt(n);
    if (n >= curveOrder)
        n = n % curveOrder;
    if (n === BigInt(0))
        return exports.BlsG2.ZERO;
    return g2.multiply(BigInt(n));
}
exports.bls12_381_G2_scalarMul = bls12_381_G2_scalarMul;
function bls12_381_G2_equal(a, b) {
    return a.equals(b);
}
exports.bls12_381_G2_equal = bls12_381_G2_equal;
function bls12_381_G2_hashToGroup(a, b) {
    // noble-curves can handle that but the plutus-machine doesn't
    // so we artificially throw an error here
    if (b.length > 255)
        throw new Error("DST length can not be greater than 255");
    return exports.BlsG2.fromAffine(G2_Hasher.hashToCurve(a, { DST: b })
        .toAffine());
}
exports.bls12_381_G2_hashToGroup = bls12_381_G2_hashToGroup;
function bls12_381_G2_compress(elem) {
    return elem.toRawBytes();
}
exports.bls12_381_G2_compress = bls12_381_G2_compress;
function bls12_381_G2_uncompress(compressed) {
    var compressed_bit = (0, noble_1.parseMask)(compressed).compressed;
    // not compressed bytes would be totally fine for the library but we artificially fail here
    // https://github.com/IntersectMBO/plutus/blob/master/plutus-conformance/test-cases/uplc/evaluation/builtin/semantics/bls12_381_G2_uncompress/on-curve-serialised-not-compressed/on-curve-serialised-not-compressed.uplc
    if (!compressed_bit)
        throw new Error("uncompress only works with compressed byets");
    return exports.BlsG2.fromHex(compressed);
}
exports.bls12_381_G2_uncompress = bls12_381_G2_uncompress;
function bls12_381_millerLoop(g1, g2) {
    var _a = g1.toAffine(), x = _a.x, y = _a.y;
    return millerLoop(pairingPrecomputes(g2), [x, y]);
}
exports.bls12_381_millerLoop = bls12_381_millerLoop;
function bls12_381_mulMlResult(a, b) {
    return (0, noble_1.Fp12Multiply)(a, b);
}
exports.bls12_381_mulMlResult = bls12_381_mulMlResult;
exports.bls12_381_eqMlResult = noble_1.Fp12_eql;
function bls12_381_finalVerify(a, b) {
    // blst implementation https://github.com/supranational/blst/blob/0d46eefa45fc1e57aceb42bba0e84eab3a7a9725/src/aggregate.c#L506
    var GT = (0, noble_1.Fp12_conjugate)(a);
    GT = (0, noble_1.Fp12Multiply)(GT, b);
    GT = (0, noble_1.Fp12_finalExponentiate)(GT);
    return (0, noble_1.Fp12_eql)(GT, noble_1.Fp12_ONE);
}
exports.bls12_381_finalVerify = bls12_381_finalVerify;
// The BLS parameter x for BLS12-381
var BLS_X = BigInt('0xd201000000010000');
var BLS_X_LEN = (0, utils_1.bitLen)(BLS_X);
var _2n = BigInt(2), _3n = BigInt(3);
// Pre-compute coefficients for sparse multiplication
// Point addition and point double calculations is reused for coefficients
function calcPairingPrecomputes(p) {
    var x = p.x, y = p.y;
    // prettier-ignore
    var Qx = x, Qy = y, Qz = noble_1.Fp2.ONE;
    // prettier-ignore
    var Rx = Qx, Ry = Qy, Rz = Qz;
    var ell_coeff = [];
    for (var i = BLS_X_LEN - 2; i >= 0; i--) {
        // Double
        var t0 = noble_1.Fp2.sqr(Ry); // Ry²
        var t1 = noble_1.Fp2.sqr(Rz); // Rz²
        var t2 = noble_1.Fp2.multiplyByB(noble_1.Fp2.mul(t1, _3n)); // 3 * T1 * B
        var t3 = noble_1.Fp2.mul(t2, _3n); // 3 * T2
        var t4 = noble_1.Fp2.sub(noble_1.Fp2.sub(noble_1.Fp2.sqr(noble_1.Fp2.add(Ry, Rz)), t1), t0); // (Ry + Rz)² - T1 - T0
        ell_coeff.push([
            noble_1.Fp2.sub(t2, t0),
            noble_1.Fp2.mul(noble_1.Fp2.sqr(Rx), _3n),
            noble_1.Fp2.neg(t4), // -T4
        ]);
        Rx = noble_1.Fp2.div(noble_1.Fp2.mul(noble_1.Fp2.mul(noble_1.Fp2.sub(t0, t3), Rx), Ry), _2n); // ((T0 - T3) * Rx * Ry) / 2
        Ry = noble_1.Fp2.sub(noble_1.Fp2.sqr(noble_1.Fp2.div(noble_1.Fp2.add(t0, t3), _2n)), noble_1.Fp2.mul(noble_1.Fp2.sqr(t2), _3n)); // ((T0 + T3) / 2)² - 3 * T2²
        Rz = noble_1.Fp2.mul(t0, t4); // T0 * T4
        if ((0, utils_1.bitGet)(BLS_X /*CURVE.params.x*/, i)) {
            // Addition
            var t0_1 = noble_1.Fp2.sub(Ry, noble_1.Fp2.mul(Qy, Rz)); // Ry - Qy * Rz
            var t1_1 = noble_1.Fp2.sub(Rx, noble_1.Fp2.mul(Qx, Rz)); // Rx - Qx * Rz
            ell_coeff.push([
                noble_1.Fp2.sub(noble_1.Fp2.mul(t0_1, Qx), noble_1.Fp2.mul(t1_1, Qy)),
                noble_1.Fp2.neg(t0_1),
                t1_1, // T1
            ]);
            var t2_1 = noble_1.Fp2.sqr(t1_1); // T1²
            var t3_1 = noble_1.Fp2.mul(t2_1, t1_1); // T2 * T1
            var t4_1 = noble_1.Fp2.mul(t2_1, Rx); // T2 * Rx
            var t5 = noble_1.Fp2.add(noble_1.Fp2.sub(t3_1, noble_1.Fp2.mul(t4_1, _2n)), noble_1.Fp2.mul(noble_1.Fp2.sqr(t0_1), Rz)); // T3 - 2 * T4 + T0² * Rz
            Rx = noble_1.Fp2.mul(t1_1, t5); // T1 * T5
            Ry = noble_1.Fp2.sub(noble_1.Fp2.mul(noble_1.Fp2.sub(t4_1, t5), t0_1), noble_1.Fp2.mul(t3_1, Ry)); // (T4 - T5) * T0 - T3 * Ry
            Rz = noble_1.Fp2.mul(Rz, t3_1); // Rz * T3
        }
    }
    return ell_coeff;
}
function pairingPrecomputes(point) {
    var p = point;
    if (p._PPRECOMPUTES)
        return p._PPRECOMPUTES;
    p._PPRECOMPUTES = calcPairingPrecomputes(point.toAffine());
    return p._PPRECOMPUTES;
}
function millerLoop(ell, g1) {
    var x = BLS_X;
    var Px = g1[0];
    var Py = g1[1];
    var f12 = noble_1.Fp12.ONE;
    for (var j = 0, i = BLS_X_LEN - 2; i >= 0; i--, j++) {
        var E = ell[j];
        f12 = noble_1.Fp12.multiplyBy014(f12, E[0], noble_1.Fp2.mul(E[1], Px), noble_1.Fp2.mul(E[2], Py));
        if ((0, utils_1.bitGet)(x, i)) {
            j += 1;
            var F = ell[j];
            f12 = noble_1.Fp12.multiplyBy014(f12, F[0], noble_1.Fp2.mul(F[1], Px), noble_1.Fp2.mul(F[2], Py));
        }
        if (i !== 0)
            f12 = noble_1.Fp12.sqr(f12);
    }
    return noble_1.Fp12.conjugate(f12);
}
function isBlsResult(stuff) {
    return typeof stuff === "object" && (stuff !== null && !Array.isArray(stuff) &&
        isFp6(stuff.c0) &&
        isFp6(stuff.c1));
}
exports.isBlsResult = isBlsResult;
function isFp6(stuff) {
    return typeof stuff === "object" && (stuff !== null && !Array.isArray(stuff) &&
        isFp2(stuff.c0) &&
        isFp2(stuff.c1) &&
        isFp2(stuff.c2));
}
exports.isFp6 = isFp6;
