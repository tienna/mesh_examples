import { byte } from "./types.js";
type bigpoint = [bigint, bigint];
/**
 * Curve point 'addition'
 * Note: this is probably the bottleneck of this Ed25519 implementation
 */
export declare function addPointsEdwards(a: Readonly<bigpoint>, b: Readonly<bigpoint>): bigpoint;
export declare function scalarMul(point: Readonly<bigpoint>, n: bigint): bigpoint;
/**
 * Curve point 'multiplication'
 */
export declare function encodeInt(y: bigint): byte[];
export declare function bigpointToUint8Array(point: bigpoint): Uint8Array;
export declare function pointFromBytes(s: byte[] | Uint8Array): bigpoint;
export declare function scalarFromBytes(h: byte[] | Uint8Array): bigint;
type Uint8ArrayLike = Uint8Array | string | byte[];
export declare function scalarMultBase(scalar: bigint): bigpoint;
export declare function deriveEd25519PublicKey(privateKey: byte[]): byte[];
export declare function extendedToPublic(extended: Uint8Array | byte[]): Uint8Array;
export interface SignEd25519Result {
    0: Uint8Array;
    1: Uint8Array;
    /** to be `ArrayLike` */
    length: 2;
    [Symbol.iterator]: () => Generator<Uint8Array, void, unknown>;
    pubKey: Uint8Array;
    signature: Uint8Array;
}
export declare function signEd25519(message: Uint8ArrayLike, privateKey: Uint8ArrayLike): SignEd25519Result;
export declare function signExtendedEd25519(message: Uint8ArrayLike, extendedKey: Uint8ArrayLike): SignEd25519Result;
export declare function getEd25519Signature(message: Uint8ArrayLike, privateKey: Uint8ArrayLike): Uint8Array;
export declare function verifyEd25519Signature(signature: Uint8ArrayLike, message: Uint8ArrayLike, publicKey: Uint8ArrayLike): boolean;
export declare function ed25519bigint(n: bigint): bigint;
export {};
