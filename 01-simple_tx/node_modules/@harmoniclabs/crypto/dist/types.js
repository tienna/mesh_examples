"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uint64Rotr = exports.uint64ToBytesBE = exports.uint64ToBytesLE = exports.isUint64 = exports.forceUint64 = exports.uint64 = exports.buffToUint5Arr = exports.byteArrToBin = exports.byteArrToHex = exports.buffToByteArr = exports.isByteArr = exports.isByte = exports.byte = exports.isUint6 = exports.isUint5 = void 0;
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var assert_1 = require("./utils/assert.js");
function isUint5(n) {
    return (typeof n === "number" &&
        n >= 0 && n <= 31 &&
        n === Math.round(n));
}
exports.isUint5 = isUint5;
function isUint6(n) {
    return (typeof n === "number" &&
        n >= 0 && n <= 63 &&
        n === Math.round(n));
}
exports.isUint6 = isUint6;
function byte(bint) {
    return (Number(bint) & 0xff);
}
exports.byte = byte;
function isByte(n) {
    return (typeof n === "number" &&
        n >= 0 && n <= 255 &&
        n === Math.round(n));
}
exports.isByte = isByte;
function isByteArr(something) {
    return (Array.isArray(something) &&
        something.every(isByte));
}
exports.isByteArr = isByteArr;
function buffToByteArr(buff) {
    if (!(0, uint8array_utils_1.isUint8Array)(buff)) {
        if (isByteArr(buff))
            return buff.slice();
        throw new Error("can't convert non-buffer to byte array");
    }
    return Array.from(buff);
}
exports.buffToByteArr = buffToByteArr;
function byteArrToHex(bytes) {
    if (bytes instanceof Uint8Array)
        bytes = Array.from(bytes);
    return bytes.reduce(function (acc, val) { return acc + val.toString(16).slice(0, 2).padStart(2, '0'); }, '');
}
exports.byteArrToHex = byteArrToHex;
function byteArrToBin(bytes) {
    return bytes.reduce(function (acc, val) { return acc + val.toString(2).slice(0, 8).padStart(8, '0'); }, '');
}
exports.byteArrToBin = byteArrToBin;
/**
 * Internal method
 *
 * `bytes` is **padded at the end** to be a multiple of 5
 */
function buffToUint5Arr(bytes) {
    var result = [];
    var bits = (0, uint8array_utils_1.isUint8Array)(bytes) ?
        Array.from(bytes).reduce(function (acc, n) { return acc + n.toString(2).padStart(8, '0'); }, "") :
        (isByteArr(bytes) ?
            byteArrToBin(bytes) :
            undefined);
    if (bits === undefined) {
        throw new Error("invalid input to convert ot uint5 array");
    }
    var mod5Len = bits.length % 5;
    if (mod5Len !== 0) {
        bits = bits.padEnd(bits.length + (5 - mod5Len), '0');
    }
    bits = bits.split('');
    for (var i = 0; i < bits.length;) {
        result.push(Number("0b".concat(bits[i++]).concat(bits[i++]).concat(bits[i++]).concat(bits[i++]).concat(bits[i++])));
    }
    return result;
}
exports.buffToUint5Arr = buffToUint5Arr;
function uint64(n) {
    var _n = BigInt(n);
    if (!isUint64(_n))
        throw new Error("can't convert " + n + " to uint64");
    return _n;
}
exports.uint64 = uint64;
function forceUint64(n) {
    return (BigInt(n) & BigInt("0x" + "ff".repeat(8)));
}
exports.forceUint64 = forceUint64;
function isUint64(n) {
    return (typeof n === "bigint" &&
        n >= BigInt(0) &&
        n < BigInt("0x1" + "00".repeat(8)) // n < (1 << 64)
    );
}
exports.isUint64 = isUint64;
function uint64ToBytesLE(uint) {
    return [
        byte(BigInt("0x00000000000000ff") & uint),
        byte((BigInt("0x000000000000ff00") & uint) >> BigInt(8)),
        byte((BigInt("0x0000000000ff0000") & uint) >> BigInt(16)),
        byte((BigInt("0x00000000ff000000") & uint) >> BigInt(24)),
        byte((BigInt("0x000000ff00000000") & uint) >> BigInt(32)),
        byte((BigInt("0x0000ff0000000000") & uint) >> BigInt(40)),
        byte((BigInt("0x00ff000000000000") & uint) >> BigInt(48)),
        byte((BigInt("0xff00000000000000") & uint) >> BigInt(56)),
    ];
}
exports.uint64ToBytesLE = uint64ToBytesLE;
function uint64ToBytesBE(uint) {
    return uint64ToBytesLE(uint).reverse();
}
exports.uint64ToBytesBE = uint64ToBytesBE;
function uint64Rotr(a, b) {
    (0, assert_1.assert)(isUint64(a) && isUint6(b), "invalid args for 'uint64And'");
    if (b === 0)
        return a;
    var n = BigInt(b);
    return forceUint64(forceUint64(a >> n) | forceUint64(a << (BigInt(64) - n)));
}
exports.uint64Rotr = uint64Rotr;
