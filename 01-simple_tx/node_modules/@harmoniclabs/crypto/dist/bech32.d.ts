import { byte, uint5 } from "./types.js";
/**
 * Expand human readable prefix of the bech32 encoding so it can be used in the checkSum
 */
export declare function expandBech32HumanReadablePart(hrp: string): byte[];
/**
 * Used as part of the bech32 checksum.
 */
export declare function getBech32Polymod(bytes: byte[]): number;
/**
 * Generate the bech32 checksum
 */
export declare function getBech32Checksum(humanReadablePart: string, data: uint5[]): [uint5, uint5, uint5, uint5, uint5, uint5];
/**
 * Creates a bech32 checksummed string (used to represent Cardano addresses)
 * @example
 * encodeBech32("foo", textToBytes("foobar")) => "foo1vehk7cnpwgry9h96"
 * @example
 * encodeBech32("addr_test", hexToBytes("70a9508f015cfbcffc3d88ac4c1c934b5b82d2bb281d464672f6c49539")) => "addr_test1wz54prcptnaullpa3zkyc8ynfddc954m9qw5v3nj7mzf2wggs2uld"
 * @param {byte[]} data - uint8 0 - 256
 */
export declare function encodeBech32(humanReadablePart: string, data: byte[] | Uint8Array): string;
/**
 * Verify a bech32 checksum
 * @example
 * isBech32("foo1vehk7cnpwgry9h96") => true
 * @example
 * isBech32("foo1vehk7cnpwgry9h97") => false
 * @example
 * isBech32("a12uel5l") => true
 * @example
 * isBech32("mm1crxm3i") => false
 * @example
 * isBech32("A1G7SGD8") => false
 * @example
 * isBech32("abcdef1qpzry9x8gf2tvdw0s3jn54khce6mua7lmqqqxw") => true
 * @example
 * isBech32("?1ezyfcl") => true
 * @example
 * isBech32("addr_test1wz54prcptnaullpa3zkyc8ynfddc954m9qw5v3nj7mzf2wggs2uld") => true
 * @param {string} addr
 * @returns {boolean}
 */
export declare function isBech32(addr: string): boolean;
/**
 * Decomposes a bech32 checksummed string (i.e. Cardano address), and returns the human readable part and the original bytes
 * Throws an error if checksum is invalid.
 * @example
 * bytesToHex(decodeBech32("addr_test1wz54prcptnaullpa3zkyc8ynfddc954m9qw5v3nj7mzf2wggs2uld")[1]) => "70a9508f015cfbcffc3d88ac4c1c934b5b82d2bb281d464672f6c49539"
 * @param {string} addr
 * @returns {[humanReadablePart: string, bytes: byte[]]}
 */
export declare function decodeBech32(addr: string): [humanReadablePart: string, bytes: byte[]];
