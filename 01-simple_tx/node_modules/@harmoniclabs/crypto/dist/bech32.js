"use strict";
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeBech32 = exports.isBech32 = exports.encodeBech32 = exports.getBech32Checksum = exports.getBech32Polymod = exports.expandBech32HumanReadablePart = void 0;
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var types_1 = require("./types.js");
var base32_1 = require("./utils/base32.js");
var assert_1 = require("./utils/assert.js");
/**
 * Expand human readable prefix of the bech32 encoding so it can be used in the checkSum
 */
function expandBech32HumanReadablePart(hrp) {
    var e_1, _a, e_2, _b;
    var bytes = [];
    try {
        for (var hrp_1 = __values(hrp), hrp_1_1 = hrp_1.next(); !hrp_1_1.done; hrp_1_1 = hrp_1.next()) {
            var c = hrp_1_1.value;
            bytes.push(c.charCodeAt(0) >> 5);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (hrp_1_1 && !hrp_1_1.done && (_a = hrp_1.return)) _a.call(hrp_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    bytes.push(0);
    try {
        for (var hrp_2 = __values(hrp), hrp_2_1 = hrp_2.next(); !hrp_2_1.done; hrp_2_1 = hrp_2.next()) {
            var c = hrp_2_1.value;
            bytes.push(c.charCodeAt(0) & 31);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (hrp_2_1 && !hrp_2_1.done && (_b = hrp_2.return)) _b.call(hrp_2);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return bytes;
}
exports.expandBech32HumanReadablePart = expandBech32HumanReadablePart;
var BECH32_POLYMOD_GEN = Object.freeze([0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3]);
/**
 * Used as part of the bech32 checksum.
 */
function getBech32Polymod(bytes) {
    var e_3, _a;
    var checksum = 1;
    try {
        for (var bytes_1 = __values(bytes), bytes_1_1 = bytes_1.next(); !bytes_1_1.done; bytes_1_1 = bytes_1.next()) {
            var byte_1 = bytes_1_1.value;
            var c = (checksum >> 25);
            checksum = (checksum & 0x1fffffff) << 5 ^ byte_1;
            for (var i = 0; i < 5; i++) {
                if (((c >> i) & 1) != 0) {
                    checksum ^= BECH32_POLYMOD_GEN[i];
                }
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (bytes_1_1 && !bytes_1_1.done && (_a = bytes_1.return)) _a.call(bytes_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return checksum;
}
exports.getBech32Polymod = getBech32Polymod;
/**
 * Generate the bech32 checksum
 */
function getBech32Checksum(humanReadablePart, data) {
    var checksum = getBech32Polymod(expandBech32HumanReadablePart(humanReadablePart)
        .concat(data)
        .concat([0, 0, 0, 0, 0, 0])) ^ 1;
    var chkSum = [];
    for (var i = 0; i < 6; i++) {
        chkSum.push((checksum >> 5 * (5 - i)) & 31);
    }
    return chkSum;
}
exports.getBech32Checksum = getBech32Checksum;
/**
 * Creates a bech32 checksummed string (used to represent Cardano addresses)
 * @example
 * encodeBech32("foo", textToBytes("foobar")) => "foo1vehk7cnpwgry9h96"
 * @example
 * encodeBech32("addr_test", hexToBytes("70a9508f015cfbcffc3d88ac4c1c934b5b82d2bb281d464672f6c49539")) => "addr_test1wz54prcptnaullpa3zkyc8ynfddc954m9qw5v3nj7mzf2wggs2uld"
 * @param {byte[]} data - uint8 0 - 256
 */
function encodeBech32(humanReadablePart, data) {
    (0, assert_1.assert)(humanReadablePart.length > 0, "human-readable-part must have non-zero length");
    var _data = (0, types_1.buffToUint5Arr)((0, uint8array_utils_1.isUint8Array)(data) ? data : new Uint8Array(data));
    return humanReadablePart + "1" +
        _data.concat(getBech32Checksum(humanReadablePart, _data)).map(function (val) { return base32_1.BECH32_BASE32_ALPHABET[val]; }).join("");
}
exports.encodeBech32 = encodeBech32;
/**
 * Verify a bech32 checksum
 * @example
 * isBech32("foo1vehk7cnpwgry9h96") => true
 * @example
 * isBech32("foo1vehk7cnpwgry9h97") => false
 * @example
 * isBech32("a12uel5l") => true
 * @example
 * isBech32("mm1crxm3i") => false
 * @example
 * isBech32("A1G7SGD8") => false
 * @example
 * isBech32("abcdef1qpzry9x8gf2tvdw0s3jn54khce6mua7lmqqqxw") => true
 * @example
 * isBech32("?1ezyfcl") => true
 * @example
 * isBech32("addr_test1wz54prcptnaullpa3zkyc8ynfddc954m9qw5v3nj7mzf2wggs2uld") => true
 * @param {string} addr
 * @returns {boolean}
 */
function isBech32(addr) {
    var e_4, _a;
    var i = addr.indexOf("1");
    if (i == -1 || i == 0) {
        return false;
    }
    var hrp = addr.slice(0, i);
    addr = addr.slice(i + 1);
    var data = [];
    try {
        for (var addr_1 = __values(addr), addr_1_1 = addr_1.next(); !addr_1_1.done; addr_1_1 = addr_1.next()) {
            var ch = addr_1_1.value;
            var j = base32_1.BECH32_BASE32_ALPHABET.indexOf(ch);
            if (j == -1) {
                return false;
            }
            data.push(j);
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (addr_1_1 && !addr_1_1.done && (_a = addr_1.return)) _a.call(addr_1);
        }
        finally { if (e_4) throw e_4.error; }
    }
    var chkSumA = data.slice(data.length - 6);
    var chkSumB = getBech32Checksum(hrp, data.slice(0, data.length - 6));
    for (var i_1 = 0; i_1 < 6; i_1++) {
        if (chkSumA[i_1] != chkSumB[i_1]) {
            return false;
        }
    }
    return true;
}
exports.isBech32 = isBech32;
/**
 * Decomposes a bech32 checksummed string (i.e. Cardano address), and returns the human readable part and the original bytes
 * Throws an error if checksum is invalid.
 * @example
 * bytesToHex(decodeBech32("addr_test1wz54prcptnaullpa3zkyc8ynfddc954m9qw5v3nj7mzf2wggs2uld")[1]) => "70a9508f015cfbcffc3d88ac4c1c934b5b82d2bb281d464672f6c49539"
 * @param {string} addr
 * @returns {[humanReadablePart: string, bytes: byte[]]}
 */
function decodeBech32(addr) {
    (0, assert_1.assert)(isBech32(addr), "invalid bech32 addr");
    var i = addr.indexOf("1");
    (0, assert_1.assert)(i != -1, "bech32 address missing the '1' separator");
    var hrp = addr.slice(0, i);
    addr = addr.slice(i + 1);
    var data = (0, base32_1.decodeBase32Bech32)(addr.slice(0, addr.length - 6));
    return [hrp, Array.from(data)];
}
exports.decodeBech32 = decodeBech32;
