"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bigintToBuffer = void 0;
var assert_1 = require("./assert.js");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
function bigintToBuffer(bigint, nBytes) {
    if (nBytes === void 0) { nBytes = undefined; }
    (0, assert_1.assert)(bigint >= BigInt(0), "cannot convert negative bigint to buffer");
    if (bigint == BigInt(0)) {
        if (nBytes === undefined) {
            return Uint8Array.from([]);
        }
        return new Uint8Array(nBytes);
    }
    var buffHexString = bigint.toString(16);
    buffHexString = buffHexString.length % 2 === 0 ? buffHexString : '0' + buffHexString;
    if (nBytes !== undefined) {
        (0, assert_1.assert)(Math.round(Math.abs(nBytes)) === nBytes, "cannot construct a buffer of length " + nBytes + ", while using BigIntUtils.toBufferOfNBytesBE");
        // pads with zeroes so that the final length is of nBytes*2 (2 hex digits per byte)
        // String.prototype.padStart docs: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart
        buffHexString = buffHexString.padStart(nBytes * 2, "00");
        if (buffHexString.length > nBytes * 2) {
            console.warn("required buffer size is smaller than the one used effectively by the given bigint, truncating the initial bytes as overflow");
            buffHexString = buffHexString.slice(buffHexString.length - (nBytes * 2));
        }
    }
    return (0, uint8array_utils_1.fromHex)(buffHexString);
}
exports.bigintToBuffer = bigintToBuffer;
