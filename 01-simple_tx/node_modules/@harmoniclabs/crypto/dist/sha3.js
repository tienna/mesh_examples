"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sha3 = void 0;
var types_1 = require("./types.js");
var types_2 = require("./types.js");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var assert_1 = require("./utils/assert.js");
/**
 * state width (1600 bits, )
 */
var WIDTH = 200;
/**
 * rate (1088 bits, 136 bytes)
 */
var RATE = 136;
/**
 * capacity
 */
var CAP = WIDTH - RATE;
/**
 * Apply 1000...1 padding until size is multiple of r.
 * If already multiple of r then add a whole block of padding.
 * @param {number[]} src - list of uint8 numbers
 * @returns {number[]} - list of uint8 numbers
 */
function pad(src) {
    var dst = src.slice();
    var nZeroes = RATE - 2 - (dst.length % RATE);
    if (nZeroes < -1) {
        nZeroes += RATE - 2;
    }
    if (nZeroes == -1) {
        dst.push(0x86);
    }
    else {
        dst.push(0x06);
        for (var i = 0; i < nZeroes; i++) {
            dst.push(0);
        }
        dst.push(0x80);
    }
    (0, assert_1.assert)((dst.length % RATE) === 0, "wrong destination length");
    return dst;
}
/**
 * 24 numbers used in the sha3 permute function
 */
var OFFSETS = Object.freeze([6, 12, 18, 24, 3, 9, 10, 16, 22, 1, 7, 13, 19, 20, 4, 5, 11, 17, 23, 2, 8, 14, 15, 21]);
/**
 * 24 numbers used in the sha3 permute function
 */
var SHIFTS = Object.freeze([-12, -11, 21, 14, 28, 20, 3, -13, -29, 1, 6, 25, 8, 18, 27, -4, 10, 15, -24, -30, -23, -7, -9, 2]);
/**
 * Round constants used in the sha3 permute function
 */
var RC = Object.freeze([
    (0, types_2.uint64)("0x0000000000000001"),
    (0, types_2.uint64)("0x0000000000008082"),
    (0, types_2.uint64)("0x800000000000808a"),
    (0, types_2.uint64)("0x8000000080008000"),
    (0, types_2.uint64)("0x000000000000808b"),
    (0, types_2.uint64)("0x0000000080000001"),
    (0, types_2.uint64)("0x8000000080008081"),
    (0, types_2.uint64)("0x8000000000008009"),
    (0, types_2.uint64)("0x000000000000008a"),
    (0, types_2.uint64)("0x0000000000000088"),
    (0, types_2.uint64)("0x0000000080008009"),
    (0, types_2.uint64)("0x000000008000000a"),
    (0, types_2.uint64)("0x000000008000808b"),
    (0, types_2.uint64)("0x800000000000008b"),
    (0, types_2.uint64)("0x8000000000008089"),
    (0, types_2.uint64)("0x8000000000008003"),
    (0, types_2.uint64)("0x8000000000008002"),
    (0, types_2.uint64)("0x8000000000000080"),
    (0, types_2.uint64)("0x000000000000800a"),
    (0, types_2.uint64)("0x800000008000000a"),
    (0, types_2.uint64)("0x8000000080008081"),
    (0, types_2.uint64)("0x8000000000008080"),
    (0, types_2.uint64)("0x0000000080000001"),
    (0, types_2.uint64)("0x8000000080008008"),
]);
function permute(s) {
    var c = new Array(5);
    var b = new Array(25);
    for (var round = 0; round < 24; round++) {
        for (var i = 0; i < 5; i++) {
            c[i] = (0, types_2.uint64)((((s[i] ^ s[i + 5]) ^ s[i + 10]) ^ s[i + 15]) ^ s[i + 20]);
        }
        for (var i = 0; i < 5; i++) {
            var tmp = (0, types_2.uint64)(c[(i + 4) % 5] ^ (0, types_2.uint64Rotr)(c[(i + 1) % 5], 63));
            for (var j = 0; j < 5; j++) {
                s[i + 5 * j] = (0, types_2.uint64)(s[i + 5 * j] ^ tmp);
            }
        }
        b[0] = s[0];
        for (var i = 1; i < 25; i++) {
            var offset = OFFSETS[i - 1];
            var left = Math.abs(SHIFTS[i - 1]);
            var right = (32 - left);
            if (SHIFTS[i - 1] < 0) {
                b[i] = (0, types_2.uint64Rotr)(s[offset], right);
            }
            else {
                b[i] = (0, types_2.uint64Rotr)(s[offset], (right + 32));
            }
        }
        for (var i = 0; i < 5; i++) {
            for (var j = 0; j < 5; j++) {
                s[i * 5 + j] = (0, types_2.uint64)(b[i * 5 + j] ^ ((~b[i * 5 + (j + 1) % 5]) & b[i * 5 + (j + 2) % 5]));
            }
        }
        s[0] = (s[0] ^ RC[round]);
    }
}
/**
 * getulates sha3-256 (32bytes) hash of a list of uint8 numbers.
 * Result is also a list of uint8 number.
 * Sha3 only bit-wise operations, so 64-bit operations can easily be replicated using 2 32-bit operations instead
 * @example
 * bytesToHex(sha3(textToBytes("abc"))) => "3a985da74fe225b2045c172d6bd390bd855f086e3e9d525b46bfe24511431532"
 * @example
 * bytesToHex(sha3((new Array(136)).fill(1))) => "b36dc2167c4d9dda1a58b87046c8d76a6359afe3612c4de8a38857e09117b2db"
 * @example
 * bytesToHex(sha3((new Array(135)).fill(2))) => "5bdf5d815d29a9d7161c66520efc17c2edd7898f2b99a029e8d2e4ff153407f4"
 * @example
 * bytesToHex(sha3((new Array(134)).fill(3))) => "8e6575663dfb75a88f94a32c5b363c410278b65020734560d968aadd6896a621"
 * @example
 * bytesToHex(sha3((new Array(137)).fill(4))) => "f10b39c3e455006aa42120b9751faa0f35c821211c9d086beb28bf3c4134c6c6"
 */
function sha3(bytes) {
    if ((0, uint8array_utils_1.isUint8Array)(bytes)) {
        bytes = (0, types_1.buffToByteArr)(bytes);
    }
    bytes = pad(bytes);
    // initialize the state
    var state = (new Array(WIDTH / 8)).fill((0, types_2.uint64)(0));
    for (var chunkStart = 0; chunkStart < bytes.length; chunkStart += RATE) {
        // extend the chunk to become length WIDTH
        var chunk = bytes.slice(chunkStart, chunkStart + RATE).concat((new Array(CAP)).fill(0));
        // element-wise xor with 'state'
        for (var i = 0; i < WIDTH; i += 8) {
            state[i / 8] = (0, types_2.uint64)(state[i / 8] ^
                (0, types_2.uint64)("0x" + (0, types_2.byteArrToHex)(chunk.slice(i, i + 8).reverse())));
            // beware: a uint32 is stored as little endian, but a pair of uint32s that form a uin64 are stored in big endian format!
            //state[i/4] ^= (chunk[i] << 0) | (chunk[i+1] << 8) | (chunk[i+2] << 16) | (chunk[i+3] << 24);
        }
        // apply block permutations
        permute(state);
    }
    var hash = [];
    for (var i = 0; i < 4; i++) {
        hash.push.apply(hash, __spreadArray([], __read((0, types_2.uint64ToBytesLE)(state[i])), false));
    }
    return hash;
}
exports.sha3 = sha3;
