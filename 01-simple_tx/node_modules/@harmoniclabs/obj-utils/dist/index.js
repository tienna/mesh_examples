"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.defineNormalProperty = exports.defineFixedDeletableProperty = exports.defineHiddenNormalProperty = exports.defineDeletableDescriptor = exports.defineNonDeletableNormalProperty = exports.defineReadOnlyProperty = exports.defineWritableHiddenProperty = exports.defineGetterOnlyProperty = exports.defineReadOnlyHiddenProperty = exports.definePropertyIfNotPresent = exports.defineProperty = exports.freezeAll = exports.deepClone = exports.jsonClone = exports.deepEqual = exports.isSerializable = exports.hasOwn = exports.has_n_determined_keys = exports.containsKeys = exports.hasNkeys = exports.hasUniqueKey = exports.isObject = exports.isNotArray = void 0;
function isNotArray(obj) {
    return !Array.isArray(obj);
}
exports.isNotArray = isNotArray;
function isObject(obj) {
    return (typeof obj === "object" &&
        isNotArray(obj) &&
        obj !== null &&
        obj !== undefined // useless since "typeof" would have returned "undefined", but better safe than sorry :P
    );
}
exports.isObject = isObject;
function hasUniqueKey(obj, key) {
    if (key === void 0) { key = undefined; }
    var keys = Object.keys(obj);
    return (keys.length === 1 &&
        (typeof key !== "undefined" ? keys[0] === key : true));
}
exports.hasUniqueKey = hasUniqueKey;
function hasNkeys(obj, n) {
    return (isObject(obj) &&
        Object.keys(obj).length === n);
}
exports.hasNkeys = hasNkeys;
function containsKeys(obj) {
    var keys = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        keys[_i - 1] = arguments[_i];
    }
    var oKeys = Object.keys(obj);
    for (var i = 0; i < keys.length; i++) {
        if (!oKeys.includes(keys[i]))
            return false;
    }
    return true;
}
exports.containsKeys = containsKeys;
function has_n_determined_keys(obj, n) {
    var keys = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        keys[_i - 2] = arguments[_i];
    }
    return (hasNkeys(obj, n) &&
        keys.length === n && containsKeys.apply(void 0, __spreadArray([obj], __read(keys), false)));
}
exports.has_n_determined_keys = has_n_determined_keys;
exports.hasOwn = (_b = ((_a = Object.hasOwn) !== null && _a !== void 0 ? _a : Object.prototype.hasOwnProperty.call)) !== null && _b !== void 0 ? _b : containsKeys;
function isSerializable(obj) {
    var keys = Object.keys(obj);
    for (var i = 0; i < keys.length; i++) {
        var value = obj[keys[i]];
        if (typeof value === "number" ||
            typeof value === "bigint" ||
            typeof value === "boolean" ||
            typeof value === "string" ||
            typeof value === "undefined")
            continue; // this single value is true, don't know the others
        else {
            if (Array.isArray(value)) {
                for (var i_1 = 0; i_1 < value.length; i_1++) {
                    // all array elements must be serilalizable to
                    // equivalent to AND all elments
                    if (!isSerializable(value[i_1]))
                        return false;
                }
            }
            else if (typeof value === "object") {
                if (!isSerializable(value))
                    continue; // this single value is true, don't know the others
                else
                    return false;
            }
            else if (typeof value === "function")
                return false;
        }
    }
    return true;
}
exports.isSerializable = isSerializable;
function deepEqual(a, b) {
    if (typeof a !== typeof b) {
        return false;
    }
    /*
    covers:
    - nuber
    - strings
    - boolean
    - functions only if are the same object
    ( unfortunately, proving deep function equality is not possible (yet) )
    */
    if (a === b) {
        return true;
    }
    if (Array.isArray(a)) {
        if (Array.isArray(b)) {
            if (a.length !== b.length)
                return false;
            for (var i = 0; i < a.length; i++) {
                if (!deepEqual(a[i], b[i])) {
                    return false;
                }
            }
            return true;
        }
        else // a and b are not both arrays
         {
            return false;
        }
    }
    else if (Array.isArray(b))
        return false; // a is an array indeed
    // type equality checked before, no need to re-check
    if (typeof a === "object") {
        var aKeys = Object.keys(a);
        var bKeys = Object.keys(b);
        if (aKeys.length !== aKeys.length) {
            return false;
        }
        // {} === {} -> true
        if (aKeys.length === 0 && bKeys.length === 0) {
            return true;
        }
        for (var i = 0; i < aKeys.length; i++) {
            var foundThis_a = false;
            for (var j = 0; j < bKeys.length; j++) {
                if (aKeys[i] === bKeys[j]) {
                    foundThis_a = true;
                    break;
                }
            }
            if (foundThis_a) {
                if (deepEqual(a[aKeys[i]], b[aKeys[i]])) {
                    if (i === (aKeys.length - 1)) {
                        return true;
                    }
                    continue;
                }
                else
                    return false;
            }
            else {
                return false;
            }
        }
    }
    return false;
}
exports.deepEqual = deepEqual;
function jsonClone(obj) {
    return JSON.parse(JSON.stringify(obj));
}
exports.jsonClone = jsonClone;
function deepClone(obj) {
    var clone;
    //@ts-ignore
    if (typeof obj === "function")
        return cloneFunc(obj);
    if (typeof obj === "object") {
        if (Array.isArray(obj)) {
            clone = [];
            for (var i = 0; i < obj.length; i++) {
                clone[i] = deepClone(obj[i]);
            }
            return clone;
        }
        var objKeys = Object.keys(obj);
        for (var i = 0; i < objKeys.length; i++) {
            clone[objKeys[i]] = deepClone(obj[objKeys[i]]);
        }
        return clone;
    }
    // number
    // string
    // boolean
    return obj;
}
exports.deepClone = deepClone;
function freezeAll(something) {
    if (typeof something === "object" && something !== null) {
        var ks = Object.keys(something);
        for (var i = 0; i < ks.length; i++) {
            freezeAll(something[ks[i]]);
        }
    }
    return Object.freeze(something);
}
exports.freezeAll = freezeAll;
var writableProperty = 1;
var enumerableProperty = 2;
var configurableProperty = 4;
/*
https://stackoverflow.com/questions/52204566/typescript-add-dynamically-named-property-to-return-type

declare function addKeyValue2<T extends {}, K extends keyof any, V>(obj: T, key: K, value: V):
    { [P in keyof (T & Record<K, any>)]: P extends K ? V : P extends keyof T ? T[P] : never }
*/
/**
 *
 * @param obj {object} to define the property on
 * @param name {PropertyKey} name of the property
 * @param value {any} value of the property
 * @param accessLevel writable / enumerable / configurable
 *
 * enumerable   = 0b010, if ```false``` is not showed
 * configurable = 0b100, if ```false``` cannot be deleted or changed
 *
 * 0 -> none // hidden object-specific descriptor
 *
 * 1 -> writable only // hidden, modifiable, non deletable
 *
 * 2 -> enumerable only // showed object-specific descriptor
 *
 * 3 -> writable AND enumerable // non deletable
 *
 * 4 -> configurable only // hidden object-specific deleteable descriptor
 *
 * 5 -> configurable AND writable // hidden, modifiable, deletable
 *
 * 6 -> configurable AND enumerable // showed, non modifiable, deletable
 *
 * 7 -> all // showed, modifiable, deletable
 *
 */
function defineProperty(obj, name, value, accessLevel) {
    if (accessLevel === void 0) { accessLevel = 0; }
    return Object.defineProperty(obj, name, {
        value: value,
        writable: (accessLevel & writableProperty) === writableProperty,
        enumerable: (accessLevel & enumerableProperty) === enumerableProperty,
        configurable: (accessLevel & configurableProperty) === configurableProperty,
    });
}
exports.defineProperty = defineProperty;
function definePropertyIfNotPresent(obj, name, descriptor) {
    if ((0, exports.hasOwn)(obj, name))
        return obj;
    return Object.defineProperty(obj, name, descriptor);
}
exports.definePropertyIfNotPresent = definePropertyIfNotPresent;
function defineReadOnlyHiddenProperty(obj, name, value) {
    return defineProperty(obj, name, value, 0);
}
exports.defineReadOnlyHiddenProperty = defineReadOnlyHiddenProperty;
function defineGetterOnlyProperty(obj, name, valueGetter) {
    return definePropertyIfNotPresent(obj, name, {
        get: valueGetter,
        set: function () { },
        configurable: false,
        enumerable: true
    });
}
exports.defineGetterOnlyProperty = defineGetterOnlyProperty;
function defineWritableHiddenProperty(obj, name, value) {
    return defineProperty(obj, name, value, 1);
}
exports.defineWritableHiddenProperty = defineWritableHiddenProperty;
/**
 * 2 -> enumerable only
 *
 * property is showed and can be accessed trough indexing
 *
 * cannot be modified
 *
 * cannot be deleted
 */
function defineReadOnlyProperty(obj, name, value) {
    var _a;
    if ((0, exports.hasOwn)(obj, name) && // if the object has already a property with the same name
        (!((_a = Object.getOwnPropertyDescriptor(obj, name)) === null || _a === void 0 ? void 0 : _a.writable)) // and it cannot be overridden
    )
        return obj; // return that object;
    return defineProperty(obj, name, value, 2);
}
exports.defineReadOnlyProperty = defineReadOnlyProperty;
function defineNonDeletableNormalProperty(obj, name, value) {
    var _a;
    if ((0, exports.hasOwn)(obj, name) && // if the object has already a property with the same name
        (!((_a = Object.getOwnPropertyDescriptor(obj, name)) === null || _a === void 0 ? void 0 : _a.writable)) // and it cannot be overridden
    )
        return obj; // return that object;
    return defineProperty(obj, name, value, 3);
}
exports.defineNonDeletableNormalProperty = defineNonDeletableNormalProperty;
function defineDeletableDescriptor(obj, name, value) {
    return defineProperty(obj, name, value, 4);
}
exports.defineDeletableDescriptor = defineDeletableDescriptor;
function defineHiddenNormalProperty(obj, name, value) {
    return defineProperty(obj, name, value, 5);
}
exports.defineHiddenNormalProperty = defineHiddenNormalProperty;
function defineFixedDeletableProperty(obj, name, value) {
    return defineProperty(obj, name, value, 6);
}
exports.defineFixedDeletableProperty = defineFixedDeletableProperty;
function defineNormalProperty(obj, name, value) {
    return defineProperty(obj, name, value, 7);
}
exports.defineNormalProperty = defineNormalProperty;
function cloneFunc(func) {
    var cloneObj = func;
    //@ts-ignore
    if (func.__isClone) {
        //@ts-ignore
        cloneObj = func.__clonedFrom;
    }
    //@ts-ignore
    var temp = function () { return cloneObj.apply(this, arguments); };
    for (var key in func) {
        //@ts-ignore
        temp[key] = func[key];
    }
    //@ts-ignore
    temp.__isClone = true;
    //@ts-ignore
    temp.__clonedFrom = cloneObj;
    return temp;
}
;
