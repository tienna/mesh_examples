"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var assert_1 = require("./assert.js");
/**
 * @static
 */
var BigIntUtils = /** @class */ (function () {
    function BigIntUtils() {
    }
    ;
    /**
     * same as ```Math.abs``` but for bigints
     */
    BigIntUtils.abs = function (n) {
        return n < BigInt(0) ? -n : n;
    };
    /**
     * @returns {bigint} a ```bigint``` between ```0``` and ```Number.MAX_SAFE_INTEGER``` so that is safe to convert to Number for whatever reason
     */
    BigIntUtils.random = function () {
        return BigInt(Math.round(Math.random() * Number.MAX_SAFE_INTEGER));
    };
    BigIntUtils.max = function () {
        var nums = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nums[_i] = arguments[_i];
        }
        return nums.reduce(function (a, b) { return a > b ? a : b; });
    };
    BigIntUtils.min = function () {
        var nums = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nums[_i] = arguments[_i];
        }
        return nums.reduce(function (a, b) { return a < b ? a : b; });
    };
    BigIntUtils.log2 = function (num) {
        if (num === BigInt(0))
            return BigInt(0);
        if (num < BigInt(0))
            return -BigIntUtils.log2(BigIntUtils.abs(num));
        var n = BigInt(num);
        var result = BigInt(0);
        while (n >>= BigInt(1))
            result++;
        return result;
    };
    /**
     * uses the bytes of the buffer to construct a BigInteger
     * > **IMPORTANT** the bytes are considered in Little Endian order; use ```BigIntUtils.fromBuffer``` for Big Endian
     */
    BigIntUtils.fromBufferLE = function (buffer) {
        return BigIntUtils.fromBuffer(
        // need to copy so that it doesn't reverses the original buffer
        Uint8Array.from(buffer)
            .reverse());
    };
    /**
     * converts a Uint8Array to a ```bigint```
     * Big-Endian default
     */
    BigIntUtils.fromBuffer = function (buffer) {
        (0, assert_1.assert)((0, uint8array_utils_1.isUint8Array)(buffer), "expected buffer as input, while constructing a bigint instance using BigIntUtils.fromBufferBE");
        var hexBuff = (0, uint8array_utils_1.toHex)(buffer);
        if (hexBuff.length === 0) {
            return BigInt(0);
        }
        return BigInt("0x".concat(hexBuff));
    };
    /**
     * converts a ```bigint``` to a ```Uint8Array``` of length ```nBytes``` given as second argument
     *
     * if ```nBytes``` is not specified the Uint8Array takes only the bytes needed
     * @param bigint
     * @param nBytes
     * @returns
     */
    BigIntUtils.toBuffer = function (bigint, nBytes) {
        if (nBytes === void 0) { nBytes = undefined; }
        (0, assert_1.assert)(bigint >= BigInt(0), "cannot convert negative bigint to buffer");
        if (bigint == BigInt(0)) {
            if (nBytes === undefined) {
                return Uint8Array.from([]);
            }
            return new Uint8Array(nBytes);
        }
        var buffHexString = bigint.toString(16);
        buffHexString = buffHexString.length % 2 === 0 ? buffHexString : '0' + buffHexString;
        if (nBytes !== undefined) {
            (0, assert_1.assert)(Math.round(Math.abs(nBytes)) === nBytes, "cannot construct a buffer of length " + nBytes + ", while using BigIntUtils.toBufferOfNBytesBE");
            // pads with zeroes so that the final length is of nBytes*2 (2 hex digits per byte)
            // String.prototype.padStart docs: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart
            buffHexString = buffHexString.padStart(nBytes * 2, "00");
            if (buffHexString.length > nBytes * 2) {
                console.warn("required buffer size is smaller than the one used effectively by the given bigint, truncating the initial bytes as overflow");
                buffHexString = buffHexString.slice(buffHexString.length - (nBytes * 2));
            }
        }
        return (0, uint8array_utils_1.fromHex)(buffHexString);
    };
    return BigIntUtils;
}());
exports.default = BigIntUtils;
