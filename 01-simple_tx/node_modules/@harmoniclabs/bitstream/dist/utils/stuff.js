"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.minBytesRequired = exports.getNOfUsedBits = exports.getNLastBits = exports.getNLastBitsInt = exports.andMaskOfLength = exports.andMaskOfLengthInt = exports.getFirstByte = void 0;
var assert_1 = require("./assert.js");
/**
 * @deprecated not sure it has ever made sense to have it
 * @returns a number in range ```[ 0 , 255 ]``` ( ```[ 0b0000_0000, 0b1111_1111 ]``` ) based on the first byte
 */
function getFirstByte(bits) {
    return Number("0x".concat(bits.toString(16).slice(0, 2)));
}
exports.getFirstByte = getFirstByte;
/**
 * @deprecated use ```andMaskOfLength``` instead
 */
function andMaskOfLengthInt(n) {
    n = Math.round(Math.abs(n));
    // operatons used are valid on singed number
    if (n >= 30) {
        return andMaskOfLength(BigInt(n));
    }
    return BigInt((1 << n) - 1);
}
exports.andMaskOfLengthInt = andMaskOfLengthInt;
/**
 * returns a ```bigint``` of that as the last ```n``` bits setted to ones;
 *
 * example
 * ```ts
 * getMaskOfLength( 7 ) === Bigint( 0b0111_1111 ); // true
 * ```
 */
function andMaskOfLength(n) {
    return BigInt((BigInt(1)
        << n)
        - BigInt(1));
}
exports.andMaskOfLength = andMaskOfLength;
/**
 * @deprecated use ```getNLastBits``` instead
 */
function getNLastBitsInt(fromNuber, nBits) {
    (0, assert_1.assert)(typeof fromNuber === "number" && typeof nBits === "number", "can use getNLastBitsInt on number instances only");
    return Number(BigInt(fromNuber)
        &
            andMaskOfLength(BigInt(nBits)));
}
exports.getNLastBitsInt = getNLastBitsInt;
function getNLastBits(fromNuber, nBits) {
    return (fromNuber & andMaskOfLength(nBits));
}
exports.getNLastBits = getNLastBits;
/**
 * @returns the number of bits from the first setted to ```1``` on the left up until the end
 */
function getNOfUsedBits(bits) {
    if (bits === BigInt(0))
        return 0;
    return bits.toString(2).length;
}
exports.getNOfUsedBits = getNOfUsedBits;
function minBytesRequired(bigint) {
    if (bigint < BigInt(0))
        throw new Error("minBytesRequired works for positives integers only");
    var fullByteOnes = BigInt(255);
    var mask = fullByteOnes;
    var bytesRequired = 1;
    while (bigint !== (bigint & mask)) {
        mask = (mask << BigInt(8)) | fullByteOnes;
        bytesRequired++;
    }
    return bytesRequired;
}
exports.minBytesRequired = minBytesRequired;
