"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitStreamIterator = exports.BitStream = exports.forceInByteOffset = exports.isInByteOffset = void 0;
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var stuff_1 = require("./utils/stuff.js");
var assert_1 = require("./utils/assert.js");
var BigIntUtils_1 = __importDefault(require("./utils/BigIntUtils.js"));
var isBinary_1 = require("./utils/isBinary.js");
function isInByteOffset(offset) {
    return (offset === 0 ||
        offset === 1 ||
        offset === 2 ||
        offset === 3 ||
        offset === 4 ||
        offset === 5 ||
        offset === 6 ||
        offset === 7);
}
exports.isInByteOffset = isInByteOffset;
function forceInByteOffset(offset) {
    return (Math.round(Math.abs(offset)) % 8);
}
exports.forceInByteOffset = forceInByteOffset;
var BitStream = /** @class */ (function () {
    function BitStream(bytes, nInitialZeroes) {
        if (nInitialZeroes === void 0) { nInitialZeroes = 0; }
        var _this = this;
        /**
         * allows to use ```BitStream```s in ```for..of``` loops
         *
         * e.g.:
         * ```ts
         * for( let bit of bitStream )
         * {
         *    // ```bit``` si an object of type ```Bit```
         * }
         * ```
         */
        this[_a] = function () { return new BitStreamIterator(_this); };
        // case empty BitStream
        // aka. new BitStream() || new BitStream( undefined )
        if (bytes === undefined) {
            this._bits = BigInt(-1);
            this._nInitialZeroes = 0;
            return;
        }
        // nInitialZeroes has to be an integer
        (0, assert_1.assert)(Math.round(Math.abs(nInitialZeroes)) === nInitialZeroes, "invalid numebr of nInitialZeroes passed, expected non-negative integer, got: " + nInitialZeroes.toString());
        // construct form bigint
        if (typeof bytes == "bigint") {
            this._nInitialZeroes = nInitialZeroes;
            // silently adapts the input if negative in produciton
            this._bits = BigIntUtils_1.default.abs(bytes);
            return;
        }
        // construct form Uint8Array
        // assert got Uint8Array instance as input
        (0, assert_1.assert)((0, uint8array_utils_1.isUint8Array)(bytes), "expected a Uint8Array instance", {
            got: bytes,
            nativeType: typeof bytes
        });
        if (bytes.length === 0) {
            this._bits = BigInt(-1);
            this._nInitialZeroes = 0;
            return;
        }
        var nZeroesAsEndPadding = forceInByteOffset(nInitialZeroes);
        var firstNonZeroByte = 0;
        var allZeroesBytes = 0;
        while (allZeroesBytes < bytes.length) {
            firstNonZeroByte = (0, uint8array_utils_1.readUint8)(bytes, allZeroesBytes);
            if (firstNonZeroByte > 0)
                break;
            allZeroesBytes++;
        }
        if (allZeroesBytes === bytes.length) {
            this._bits = BigInt(-1);
            this._nInitialZeroes = 8 * allZeroesBytes;
            return;
        }
        this._nInitialZeroes = (8 * allZeroesBytes) + (8 - (0, stuff_1.getNOfUsedBits)(BigInt(firstNonZeroByte)));
        (0, assert_1.assert)(this._nInitialZeroes >= 0, "this._nInitialZeroes was setted badly in a BitStream creation using a Uint8Array as input.");
        this._bits = BigIntUtils_1.default.fromBuffer(bytes);
        if (nZeroesAsEndPadding !== 0) {
            this._bits = this.bits << BigInt(nZeroesAsEndPadding);
        }
    }
    BitStream.isStrictInstance = function (value) {
        return Object.getPrototypeOf(value) === BitStream.prototype;
    };
    Object.defineProperty(BitStream.prototype, "bits", {
        /**
         * **IMPORTANT**
         *
         * this property returns the raw bigint stored in the instance
         *
         * this means that if the instance represents an empty ```BitStream``` ,
         * or one composed by an undefinite series of zeroes, you'll likely get an different result than the expected one
         *
         * for a more appropriate result you should use the ```asBigInt``` method
         *
         * example:
         * ```ts
         * const myBitStream = new BitStream();
         *
         * myBitStream.bits // -> -1n
         * myBitStream.asBigInt().bigint // -> 0n
         *
         * ```
         *
         */
        get: function () {
            return this._bits;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BitStream.prototype, "nInitialZeroes", {
        get: function () {
            return this._nInitialZeroes;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BitStream.prototype, "length", {
        get: function () {
            if (this.isEmpty())
                return 0;
            return this._nInitialZeroes + (0, stuff_1.getNOfUsedBits)(this._bits);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BitStream.prototype, "lengthInBytes", {
        get: function () {
            return BitStream.getMinBytesForLength(this.length);
        },
        enumerable: false,
        configurable: true
    });
    BitStream.prototype.isEmpty = function () {
        return this._bits < BigInt(0) && this.nInitialZeroes <= 0;
    };
    BitStream.prototype.isAllZeroes = function () {
        return this._bits <= BigInt(0) && this.nInitialZeroes >= 0;
    };
    BitStream.fromBinStr = function (binStr) {
        (0, assert_1.assert)((0, isBinary_1.isBinary)(binStr), "expected an instance of the 'BinsryString' class; got: " + binStr.toString());
        var firstOneAt = binStr.indexOf('1');
        if (firstOneAt < 0) // case all zeroes
         {
            return new BitStream(BigInt(0), binStr.length);
        }
        return new BitStream(BigInt("0b".concat(binStr.slice(firstOneAt))), firstOneAt);
    };
    BitStream.prototype.toBinStr = function () {
        var _b = this.asBigInt(), bigint = _b.bigint, nInitialZeroes = _b.nInitialZeroes;
        return "0".repeat(nInitialZeroes) + bigint.toString(2);
    };
    BitStream.getMinBytesForLength = function (length) {
        length = Math.round(Math.abs(length));
        // even one bit requires a new byte,
        // that's why ceil
        return Math.ceil(length / 8);
    };
    BitStream.prototype.getNBitsMissingToByte = function () {
        var lengthMod8 = this.length % 8;
        if (lengthMod8 === 0)
            return 0; // would have returned 8 (8 - 0) otherwise
        return (8 - lengthMod8);
    };
    BitStream.prototype.at = function (index) {
        if (index >= this.length || index < 0)
            throw RangeError("cannot access bit at index " + index.toString());
        if (index < this.nInitialZeroes)
            return 0;
        index = Math.round(index);
        return (Boolean(this.bits & BigInt(1 << (this.length - index - 1)))) ? 1 : 0;
    };
    /**
     *
     * @returns {object}
     *      with a @property {Uint8Array} bigint containing the bigint
     *      and a @property {InByteOffset} nInitialZeroes
     *      containing a non-negative integer
     *      indicating how many (non-tracked in the bigint) zeroes are present in the ```BitStream```
     */
    BitStream.prototype.asBigInt = function () {
        if (this.isEmpty())
            return {
                bigint: BigInt(0),
                nInitialZeroes: 0
            };
        if (this.isAllZeroes())
            return {
                bigint: BigInt(0),
                nInitialZeroes: this.nInitialZeroes
            };
        return {
            bigint: this.bits,
            nInitialZeroes: this.nInitialZeroes
        };
    };
    /**
     *
     * @returns {object}
     *      with a @property {Uint8Array} buffer containing the buffer
     *      and a @property {InByteOffset} nZeroesAsEndPadding
     *      containing a number between 7 and 1 both included,
     *      indicating how many of the end bits should be ignored
     */
    BitStream.prototype.toBuffer = function () {
        if (this.isEmpty())
            return {
                buffer: Uint8Array.from([]),
                nZeroesAsEndPadding: 0
            };
        if (this.isAllZeroes())
            return {
                buffer: this.nInitialZeroes <= 0 ? Uint8Array.from([]) : (0, uint8array_utils_1.fromHex)("00".repeat(Math.ceil(this.nInitialZeroes / 8))),
                nZeroesAsEndPadding: this._nInitialZeroes % 8 === 0 ?
                    0 :
                    (8 - forceInByteOffset(this._nInitialZeroes))
            };
        // we don't want to modify our own bits
        var bits = this.bits;
        // Array is provided with usefull operation
        // unshift
        // push
        // at the moment doesnt contain any initial zero
        var bitsArr = Array.from(BigIntUtils_1.default.toBuffer(bits));
        var firstNonZeroByte = bitsArr[0];
        // add whole bytes of zeroes at the beginning if needed
        if (this.nInitialZeroes >= 8) {
            bitsArr.unshift.apply(bitsArr, __spreadArray([], __read(Array(
            // number of whole bytes as zeroes
            Math.floor(this.nInitialZeroes / 8)).fill(0)), false));
        }
        if (firstNonZeroByte === undefined) {
            console.error(firstNonZeroByte);
            console.log("toBuffer called on: ", this);
            console.log("this.isEmpty(): ".concat(this.isEmpty()), "this.isAllZeroes(): ".concat(this.isAllZeroes()));
        }
        // remaining zeroes bits
        var supposedInByteInitialZeroes = (this.nInitialZeroes % 8);
        var effectiveInByteInitialZeroes = (8 - (0, stuff_1.getNOfUsedBits)(BigInt(firstNonZeroByte !== null && firstNonZeroByte !== void 0 ? firstNonZeroByte : 0)));
        (0, assert_1.assert)((effectiveInByteInitialZeroes >= 0 && effectiveInByteInitialZeroes <= 7) &&
            Math.round(effectiveInByteInitialZeroes) == effectiveInByteInitialZeroes, "unexpected numebr of effectiveInByteInitialZeroes; should be 'InByteOffset'; got: " + effectiveInByteInitialZeroes.toString());
        if (
        // no bits (whole bytes only)
        // supposedInByteInitialZeroes === 0  ||
        // supposedInByteInitialZeroes already tracked
        supposedInByteInitialZeroes === effectiveInByteInitialZeroes) {
            return {
                buffer: Uint8Array.from(bitsArr),
                nZeroesAsEndPadding: 0
            };
        }
        /*
        
        example:
        if( 5 < 7 ) means
        the first (non-zero) byte is like `0b0000_0111`
        whereas it should be              `0b0000_0001`

        if that's the case we shift right by 2 ( 7 - 5 )
        */
        if (effectiveInByteInitialZeroes < supposedInByteInitialZeroes) {
            // shiftr carrying the bits
            var shiftBy_1 = supposedInByteInitialZeroes - effectiveInByteInitialZeroes;
            var lostBits = 0;
            var prevLostBits = 0;
            for (var i = 
            //skip the bytes manually setted to zero before (line 245)
            Math.floor(this.nInitialZeroes / 8); i < bitsArr.length; i++) {
                prevLostBits = Number((0, stuff_1.getNLastBits)(BigInt(bitsArr[i]), BigInt(shiftBy_1)));
                bitsArr[i] = (bitsArr[i] >>> shiftBy_1) | lostBits;
                lostBits = prevLostBits
                    // prepares lostBits to be used in the biwise or
                    << (8 - shiftBy_1);
            }
            // add one final byte containing bits tha would have be lost
            bitsArr.push(lostBits);
            return {
                buffer: Uint8Array.from(bitsArr),
                nZeroesAsEndPadding: (8 - shiftBy_1)
            };
        }
        /*
        otherwhise it means
        effectiveInByteInitialZeroes > supposedInByteInitialZeroes

        so the situation is like:

        first (non-zero) byte `0b0000_0001`
        whereas it should be  `0b0000_0111`

        so we are supposed to shif left by "effectiveInByteInitialZeroes - supposedInByteInitialZeroes" (in this case 2)
        */
        var shiftBy = effectiveInByteInitialZeroes - supposedInByteInitialZeroes;
        /**
         * this is quick and dirty, we are basically re-doin what did before
         * @fixme should be moved above to remove code duplication
         */
        var shiftedlBitsArr = Array.from(
        // let bigint do the dirty work
        BigIntUtils_1.default.toBuffer(bits << BigInt(shiftBy)));
        // add whole bytes of zeroes at the beginning if needed
        if (this.nInitialZeroes >= 8) {
            shiftedlBitsArr.unshift.apply(shiftedlBitsArr, __spreadArray([], __read(Array(
            // number of whole bytes as zeroes
            Math.floor(this.nInitialZeroes / 8)).fill(0)), false));
        }
        return {
            buffer: Uint8Array.from(shiftedlBitsArr),
            nZeroesAsEndPadding: shiftBy
        };
    };
    /**
     * @param byOffset number of bits to move to
     * @returns {bigint} lost bits as big integer
     */
    BitStream.prototype.shiftr = function (byOffset) {
        var lostBits = (0, stuff_1.getNLastBits)(this._bits, byOffset);
        this._bits = this.bits >> byOffset;
        return lostBits;
    };
    BitStream.prototype.shiftl = function (byOffset) {
        this._bits = this.bits << byOffset;
    };
    BitStream.prototype.append = function (other) {
        if (other.isEmpty()) {
            return;
        }
        if (this.isEmpty()) {
            this._bits = other.bits;
            this._nInitialZeroes = other.nInitialZeroes;
            return;
        }
        if (this.isAllZeroes()) {
            this._bits = other.bits;
            this._nInitialZeroes = this._nInitialZeroes + other.nInitialZeroes;
            return;
        }
        if (other.isAllZeroes()) {
            this._bits = this._bits << BigInt(other.nInitialZeroes);
            return;
        }
        // make some space
        this._bits = this.bits << BigInt(other.length);
        // other.length keeps track also of possible initial zeroes
        // so those have been added when shifting
        this._bits = this.bits | other.bits;
    };
    BitStream.prototype.clone = function () {
        if (this.isEmpty())
            return new BitStream();
        return new BitStream(this.bits, this.nInitialZeroes);
    };
    BitStream.concat = function (a, b) {
        var bitStream = a.clone();
        // .append's argument is readonly
        bitStream.append(b);
        return bitStream;
    };
    // -------------------------------------------------------------------------------------------------------------------------- //
    // ------------------------------------------------------- Operations ------------------------------------------------------- //
    // -------------------------------------------------------------------------------------------------------------------------- //
    BitStream.eq = function (a, b) {
        // if same object (same reference) return true
        // Ω(1) // Omega(1)
        if (a === b)
            return true;
        return (a.nInitialZeroes === b.nInitialZeroes &&
            a.bits === b.bits);
    };
    return BitStream;
}());
exports.BitStream = BitStream;
_a = Symbol.iterator;
var BitStreamIterator = /** @class */ (function () {
    function BitStreamIterator(bitStream) {
        if (bitStream.length === 0) {
            this._bitStreamBuff = Uint8Array.from([]);
            this._nZeroesAsPadding = 0;
            this._currByteIndex = 0;
            this._currByte = 0;
            this._currBitIndex = 0;
            this._isDone = function () { return true; };
            return;
        }
        var _b = bitStream.toBuffer(), buffer = _b.buffer, nZeroesAsEndPadding = _b.nZeroesAsEndPadding;
        this._bitStreamBuff = buffer;
        this._nZeroesAsPadding = nZeroesAsEndPadding;
        this._currByteIndex = 0;
        this._currByte = (0, uint8array_utils_1.readUint8)(this._bitStreamBuff, this._currByteIndex);
        this._currBitIndex = 0;
        this._updateByte = this._updateByte.bind(this);
        this._isDone = this._isDone.bind(this);
    }
    BitStreamIterator.prototype.next = function () {
        if (this._isDone())
            return { done: true, value: 0 };
        /*
        Debug.ignore.log(
            `currByte: ${this._currByte.toString(2).padStart( 8 , '0' )}`,
            `\nmask    : ${( 0b1 << ( 7 - this._currBitIndex ) ).toString(2).padStart( 8 , '0' )}`,
            `\nresult  : ${(
                this._currByte &
                ( 0b1 << ( 7 - this._currBitIndex ) )
            ).toString(2).padStart( 8 , '0' )}`
        )
        //*/
        // get value
        var value = Boolean(this._currByte &
            (1 << (7 - this._currBitIndex))) ? 1 : 0;
        // perform update for next call
        this._currBitIndex++;
        if (this._currBitIndex >= 8) {
            this._currBitIndex = 0;
            this._updateByte();
        }
        // yeilds value
        return {
            value: value,
            done: false
        };
    };
    BitStreamIterator.prototype._updateByte = function () {
        this._currByteIndex++;
        if (this._currByteIndex < this._bitStreamBuff.length) {
            this._currByte = (0, uint8array_utils_1.readUint8)(this._bitStreamBuff, this._currByteIndex);
        }
    };
    BitStreamIterator.prototype._isDone = function () {
        return ((this._currByteIndex >= this._bitStreamBuff.length) ||
            ((this._currByteIndex === this._bitStreamBuff.length - 1) &&
                (this._currBitIndex === (8 - this._nZeroesAsPadding))));
    };
    return BitStreamIterator;
}());
exports.BitStreamIterator = BitStreamIterator;
