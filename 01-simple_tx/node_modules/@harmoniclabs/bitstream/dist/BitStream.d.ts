export type RawBit = 0 | 1;
export type InByteOffset = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7;
export declare function isInByteOffset(offset: InByteOffset): boolean;
export declare function forceInByteOffset(offset: number): InByteOffset;
export declare class BitStream {
    static isStrictInstance(value: any): boolean;
    private _bits;
    /**
     * **IMPORTANT**
     *
     * this property returns the raw bigint stored in the instance
     *
     * this means that if the instance represents an empty ```BitStream``` ,
     * or one composed by an undefinite series of zeroes, you'll likely get an different result than the expected one
     *
     * for a more appropriate result you should use the ```asBigInt``` method
     *
     * example:
     * ```ts
     * const myBitStream = new BitStream();
     *
     * myBitStream.bits // -> -1n
     * myBitStream.asBigInt().bigint // -> 0n
     *
     * ```
     *
     */
    get bits(): bigint;
    /**
     * a ```BitStream``` could start with a series of zeroes
     * that would not be tracked otherwhise
     */
    private _nInitialZeroes;
    get nInitialZeroes(): number;
    get length(): number;
    get lengthInBytes(): number;
    isEmpty(): boolean;
    isAllZeroes(): boolean;
    constructor(bytes?: undefined);
    constructor(bytes: bigint, nInitialZeroes?: number);
    constructor(bytes: Uint8Array, nZeroesAsEndPadding?: InByteOffset);
    static fromBinStr(binStr: string): BitStream;
    toBinStr(): string;
    static getMinBytesForLength(length: number): number;
    getNBitsMissingToByte(): InByteOffset;
    /**
     * allows to use ```BitStream```s in ```for..of``` loops
     *
     * e.g.:
     * ```ts
     * for( let bit of bitStream )
     * {
     *    // ```bit``` si an object of type ```Bit```
     * }
     * ```
     */
    [Symbol.iterator]: () => BitStreamIterator;
    at(index: number): RawBit;
    /**
     *
     * @returns {object}
     *      with a @property {Uint8Array} bigint containing the bigint
     *      and a @property {InByteOffset} nInitialZeroes
     *      containing a non-negative integer
     *      indicating how many (non-tracked in the bigint) zeroes are present in the ```BitStream```
     */
    asBigInt(): {
        bigint: bigint;
        nInitialZeroes: number;
    };
    /**
     *
     * @returns {object}
     *      with a @property {Uint8Array} buffer containing the buffer
     *      and a @property {InByteOffset} nZeroesAsEndPadding
     *      containing a number between 7 and 1 both included,
     *      indicating how many of the end bits should be ignored
     */
    toBuffer(): {
        buffer: Uint8Array;
        nZeroesAsEndPadding: InByteOffset;
    };
    /**
     * @param byOffset number of bits to move to
     * @returns {bigint} lost bits as big integer
     */
    shiftr(byOffset: bigint): bigint;
    shiftl(byOffset: bigint): void;
    append(other: Readonly<BitStream>): void;
    clone(): BitStream;
    static concat(a: BitStream, b: BitStream): BitStream;
    static eq(a: BitStream, b: BitStream): boolean;
}
export declare class BitStreamIterator {
    private _bitStreamBuff;
    private _nZeroesAsPadding;
    private _currByteIndex;
    private _currByte;
    private _currBitIndex;
    constructor(bitStream: Readonly<BitStream>);
    next(): {
        done: boolean;
        value: RawBit;
    };
    private _updateByte;
    private _isDone;
}
