import { CanBeUInteger } from "@harmoniclabs/biguint";
import { Data } from "./Data.js";
export declare class DataConstr {
    readonly constr: bigint;
    readonly fields: Data[];
    constructor(constr: CanBeUInteger, fields: Data[]);
    clone(): DataConstr;
    toJson(): any;
    toString(): string;
}
/**
 * Note [CBOR alternative tags]
 *
 * We've proposed to add additional tags to the CBOR standard to cover (essentially) sum types.
 * This is exactly what we need to encode the 'Constr' constructor of 'Data' in an unambiguous way.
 * The tags aren't *quite* accepted yet, but they're clearly going to accept so we might as well
 * start using them.
 * The scheme is:
 * - Alternatives 0-6 -> tags 121-127, followed by the arguments in a list
 * - Alternatives 7-127 -> tags 1280-1400, followed by the arguments in a list
 * - Any alternatives, including those that don't fit in the above -> tag 102 followed by a list containing
 * an unsigned integer for the actual alternative, and then the arguments in a (nested!) list.
 */
export declare function constrNumberToCborTag(uint: bigint): bigint;
/**
 * the case ```tag === 102``` should be handled outside the funciton
 *
 * returns a negative number in case of unrecognized alternative
 */
export declare function cborTagToConstrNumber(tag: bigint): bigint;
