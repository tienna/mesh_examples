"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cborTagToConstrNumber = exports.constrNumberToCborTag = exports.DataConstr = void 0;
var biguint_1 = require("@harmoniclabs/biguint");
var Data_1 = require("./Data.js");
var assert_1 = require("./utils/assert.js");
var roDescr_1 = require("./utils/roDescr.js");
var DataConstr = /** @class */ (function () {
    function DataConstr(constr, fields) {
        (0, assert_1.assert)(Array.isArray(fields) && fields.every(Data_1.isData), "invalid fields passed to constructor");
        Object.defineProperties(this, {
            constr: __assign({ value: (0, biguint_1.forceBigUInt)(constr) }, roDescr_1.roDescr),
            fields: __assign({ value: fields }, roDescr_1.roDescr)
        });
    }
    DataConstr.prototype.clone = function () {
        return new DataConstr(this.constr, this.fields.map(function (dataElem) { return dataElem.clone(); }));
    };
    DataConstr.prototype.toJson = function () {
        return {
            constr: Number(this.constr),
            fields: this.fields.map(function (f) { return f.toJson(); })
        };
    };
    DataConstr.prototype.toString = function () {
        return "Constr ".concat(this.constr.toString(), " [").concat(this.fields.map(function (data) { return data.toString(); }).join(","), "]");
    };
    return DataConstr;
}());
exports.DataConstr = DataConstr;
/**
 * Note [CBOR alternative tags]
 *
 * We've proposed to add additional tags to the CBOR standard to cover (essentially) sum types.
 * This is exactly what we need to encode the 'Constr' constructor of 'Data' in an unambiguous way.
 * The tags aren't *quite* accepted yet, but they're clearly going to accept so we might as well
 * start using them.
 * The scheme is:
 * - Alternatives 0-6 -> tags 121-127, followed by the arguments in a list
 * - Alternatives 7-127 -> tags 1280-1400, followed by the arguments in a list
 * - Any alternatives, including those that don't fit in the above -> tag 102 followed by a list containing
 * an unsigned integer for the actual alternative, and then the arguments in a (nested!) list.
 */
function constrNumberToCborTag(uint) {
    if (uint < BigInt(0)) {
        throw new Error("an unsinged integer was negative; while constructing a CborTag from a DataConstr; tag: " + uint);
    }
    if (uint < BigInt(7)) {
        return uint + BigInt(121);
    }
    if (uint < BigInt(128)) {
        // ( 1280 - 7 ) + uint
        return (BigInt(1273) + uint);
    }
    return BigInt(102);
}
exports.constrNumberToCborTag = constrNumberToCborTag;
/**
 * the case ```tag === 102``` should be handled outside the funciton
 *
 * returns a negative number in case of unrecognized alternative
 */
function cborTagToConstrNumber(tag) {
    // should never happen being tag unsigned
    // ignores the tag if that's the case
    // negative numbers are returned also in case of unrecognized alternative
    if (tag < 0)
        return tag;
    if (121 <= tag && tag <= 127)
        return tag - BigInt(121);
    if (1280 <= tag && tag <= 1400)
        return tag - BigInt(1273);
    if (tag === BigInt(102))
        return tag;
    // unrecognized alternative
    return BigInt(-1);
}
exports.cborTagToConstrNumber = cborTagToConstrNumber;
