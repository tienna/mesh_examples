"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dataFromString = exports.dataFromStringWithOffset = void 0;
var DataB_1 = require("./DataB.js");
var DataConstr_1 = require("./DataConstr.js");
var DataI_1 = require("./DataI.js");
var DataList_1 = require("./DataList.js");
var DataPair_1 = require("./DataPair.js");
var DataMap_1 = require("./DataMap.js");
// | [`I ${bigint}` ]
// | [`B #${string}`];
function formatStringByBrackets(str) {
    var openBracketIdx = str.indexOf("[");
    var bIdx = str.indexOf("B");
    var iIdx = str.indexOf("I");
    if (
    // there is no open bracket
    openBracketIdx < 0 ||
        ( // or
        // we have an open bracket
        // and B is also present
        bIdx >= 0 ?
            // and B is before the open bracket
            bIdx < openBracketIdx :
            (
            // or I is also present
            iIdx >= 0 ?
                // and I is before
                iIdx < openBracketIdx :
                // else open bracket comes first
                false))) {
        var intMatch = str
            // I\s+             -> "I" followed by one or more space
            // \+?\-?           -> may or may nost start with "+" or "-"
            // (?<!\.)          -> MUST NOT have dots before
            // (?<!(#|x)\d*)    -> MUST NOT have before "#" or "x" with 0 or more digits (escluded bls elements and bytestrings)
            // \d+              -> one or more digits
            // (?!(\.|x))       -> MUST NOT have dots after or "x" (x excludes "0x" which are bls elems)
            .match(/I\s+\+?\-?(?<!\.)(?<!(#|x)\d*)\d+(?!(\.|x))/);
        var bsMatch = str.match(/B\s*#[0-9a-fA-F]*/);
        if (!bsMatch && !intMatch)
            throw new Error("expected Data I or B; found none");
        var match = bsMatch && intMatch ?
            (str.indexOf(bsMatch[0]) < str.indexOf(intMatch[0]) ?
                bsMatch :
                intMatch) :
            (!bsMatch ? intMatch : bsMatch);
        if (!match)
            throw new Error("expected Data I or B; found none");
        var formattedStr = match[0];
        return {
            formatted: [formattedStr],
            offset: str.indexOf(formattedStr) + formattedStr.length
        }; // I or B
    }
    var start = str.slice(0, openBracketIdx).trim();
    var prev = openBracketIdx + 1;
    var i = prev;
    var ch = "";
    var nOpen = 0;
    var isMap = /^\(?(\s*)?Map/.test(str);
    var insidePair = false;
    var pairK = undefined;
    var rest = [];
    while (true) {
        ch = str[i];
        switch (ch) {
            case "[": {
                nOpen++;
                break;
            }
            case "]": {
                if (nOpen === 0) {
                    var elem = str.substring(prev, i).trim();
                    if (elem !== "")
                        rest.push([elem]);
                    return {
                        formatted: [start, rest],
                        offset: i + 1
                    };
                }
                else
                    nOpen--;
                break;
            }
            case ",": {
                if (nOpen === 0) {
                    if (!isMap) {
                        rest.push(formatStringByBrackets(str.substring(prev, i)).formatted);
                        prev = i + 1;
                    }
                    else {
                        if (insidePair) {
                            if (str[prev] === ",")
                                prev++;
                            if (str[prev] === "(")
                                prev++;
                            pairK = formatStringByBrackets(str.substring(prev, i)).formatted;
                            prev = i + 1;
                        }
                        else
                            break;
                    }
                }
                break;
            }
            case "(": {
                if (nOpen === 0)
                    insidePair = true;
                break;
            }
            case ")": {
                if (nOpen === 0) {
                    var v = formatStringByBrackets(str.substring(prev, i)).formatted;
                    prev = i + 1;
                    rest.push({ k: pairK, v: v });
                    pairK = undefined;
                    insidePair = false;
                }
                break;
            }
            default: break;
        }
        i++;
    }
}
/**
 * parses the result of `data.toString()`
 *
 * @param {string} str data
 *
 * @returns and object with the parsed data and the length of the string used as `offset`
 */
function dataFromStringWithOffset(str) {
    var _a = formatStringByBrackets(str), words = _a.formatted, offset = _a.offset;
    return { data: parseWords(words), offset: offset };
}
exports.dataFromStringWithOffset = dataFromStringWithOffset;
/**
 * parses the result of `data.toString()`
 *
 * @param {string} str data
 */
function dataFromString(str) {
    return dataFromStringWithOffset(str).data;
}
exports.dataFromString = dataFromString;
function parseWords(words) {
    var start = words[0];
    while (start.startsWith("("))
        start = start.slice(1);
    if (/^\(?(\s*)?Constr/.test(start)) {
        var _a = __read(start.split(" "), 2), _ = _a[0], idxStr = _a[1];
        var idx = BigInt(idxStr);
        if (Array.isArray(words[1])) {
            var fields = words[1].map(parseWords);
            return new DataConstr_1.DataConstr(idx, fields);
        }
        else
            return dataFromString(words[0]);
    }
    if (/^\(?(\s*)?Map/.test(start)) {
        if (Array.isArray(words[1])) {
            var pairs = words[1];
            return new DataMap_1.DataMap(pairs.map(function (_a) {
                var k = _a.k, v = _a.v;
                return new DataPair_1.DataPair(parseWords(k), parseWords(v));
            }));
        }
        else
            return dataFromString(words[0]);
    }
    if (/^\(?(\s*)?List/.test(start)) {
        if (Array.isArray(words[1])) {
            return new DataList_1.DataList(words[1].map(parseWords));
        }
        else
            return dataFromString(words[0]);
    }
    if (start[0] === "I") {
        var _b = __read(start.split(" "), 2), _ = _b[0], valStr = _b[1];
        return new DataI_1.DataI(BigInt(valStr));
    }
    if (start[0] === "B") {
        var _c = __read(start.split("#"), 2), _ = _c[0], valueStr = _c[1];
        return new DataB_1.DataB(valueStr);
    }
    throw new Error("invalid string to parse Data; " + JSON.stringify(words));
}
