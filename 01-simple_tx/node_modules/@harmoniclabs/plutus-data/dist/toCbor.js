"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dataToCbor = exports.dataToCborObj = void 0;
var Data_1 = require("./Data.js");
var DataConstr_1 = require("./DataConstr.js");
var DataMap_1 = require("./DataMap.js");
var DataList_1 = require("./DataList.js");
var DataI_1 = require("./DataI.js");
var DataB_1 = require("./DataB.js");
var cbor_1 = require("@harmoniclabs/cbor");
var assert_1 = require("./utils/assert.js");
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var minBigInt = BigInt("-18446744073709551616"); // -(2n ** 64n)
var maxBigInt = BigInt("18446744073709551615"); // (2n ** 64n) - 1n
function dataToCborObj(data) {
    (0, assert_1.assert)((0, Data_1.isData)(data), "Invalid data; cannot convert to CBOR");
    if (data instanceof DataConstr_1.DataConstr) {
        var constrNum = data.constr;
        var tag = (0, DataConstr_1.constrNumberToCborTag)(constrNum);
        var fields = new cbor_1.CborArray(data.fields.map(dataToCborObj), {
            indefinite: data.fields.length > 0
        });
        if (Number(tag) === 102) {
            /*
            Any alternatives, including those that don't fit in the above
            
            -> tag 102 followed by a list containing
                an unsigned integer for the actual alternative,
                and then the arguments in a (nested!) list.
            */
            fields = new cbor_1.CborArray([
                new cbor_1.CborUInt(constrNum),
                fields
            ]);
        }
        return new cbor_1.CborTag(tag, fields);
    }
    if (data instanceof DataMap_1.DataMap) {
        return new cbor_1.CborMap(data.map.map(function (pair) {
            return {
                k: dataToCborObj(pair.fst),
                v: dataToCborObj(pair.snd)
            };
        }), {
            indefinite: data.map.length > 0
        });
    }
    if (data instanceof DataList_1.DataList) {
        return new cbor_1.CborArray(data.list.map(dataToCborObj), {
            indefinite: data.list.length > 0
        });
    }
    if (data instanceof DataI_1.DataI) {
        var n = data.int;
        return (n < 0 ?
            new cbor_1.CborNegInt(n) :
            new cbor_1.CborUInt(n));
    }
    if (data instanceof DataB_1.DataB) {
        var bytes = data.bytes.toBuffer();
        // definite length only if length <= 64
        if (bytes.length <= 64)
            return new cbor_1.CborBytes(bytes);
        var ptr = 64;
        var fst = Uint8Array.prototype.slice.call(bytes, 0, ptr);
        var chunks = [];
        var chunkSize = 0;
        var chunkEnd = 0;
        while (ptr < bytes.length) {
            chunkSize = Math.min(64, bytes.length - ptr);
            chunkEnd = ptr + chunkSize;
            chunks.push(Uint8Array.prototype.slice.call(bytes, ptr, chunkEnd));
            ptr = chunkEnd;
        }
        // indefinite length bytes
        return new cbor_1.CborBytes(fst, chunks);
    }
    throw new Error("'dataToCborObj' did not match any possible Data constructor");
}
exports.dataToCborObj = dataToCborObj;
function dataToCbor(data) {
    return cbor_1.Cbor.encode(dataToCborObj(data));
}
exports.dataToCbor = dataToCbor;
function positiveIntegerToBytes(n) {
    var hex = n.toString(16);
    return (0, uint8array_utils_1.fromHex)((hex.length % 2) === 0 ? hex : "0" + hex);
}
