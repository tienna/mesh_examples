"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readFloat64BE = exports.readFloat32BE = exports.readIntLE = exports.readBigUInt64BE = exports.readBigUInt64LE = exports.readUInt32BE = exports.readUint32BE = exports.readUInt32LE = exports.readUint32LE = exports.readUInt16BE = exports.readUint16BE = exports.readUInt16LE = exports.readUint16LE = exports.readUInt8 = exports.readUint8 = void 0;
var _asserts_1 = require("./_asserts.js");
exports.readUint8 = readUInt8;
function readUInt8(buff, offset, noAssert) {
    if (noAssert === void 0) { noAssert = false; }
    offset = offset >>> 0;
    if (!noAssert)
        (0, _asserts_1.asserValidOffset)(offset, 1, buff.length);
    return buff[offset];
}
exports.readUInt8 = readUInt8;
exports.readUint16LE = readUInt16LE;
function readUInt16LE(buff, offset, noAssert) {
    if (noAssert === void 0) { noAssert = false; }
    offset = offset >>> 0;
    if (!noAssert)
        (0, _asserts_1.asserValidOffset)(offset, 2, buff.length);
    return buff[offset] | (buff[offset + 1] << 8);
}
exports.readUInt16LE = readUInt16LE;
exports.readUint16BE = readUInt16BE;
function readUInt16BE(buff, offset, noAssert) {
    if (noAssert === void 0) { noAssert = false; }
    offset = offset >>> 0;
    if (!noAssert)
        (0, _asserts_1.asserValidOffset)(offset, 2, buff.length);
    return (buff[offset] << 8) | buff[offset + 1];
}
exports.readUInt16BE = readUInt16BE;
exports.readUint32LE = readUInt32LE;
function readUInt32LE(buff, offset, noAssert) {
    if (noAssert === void 0) { noAssert = false; }
    offset = offset >>> 0;
    if (!noAssert)
        (0, _asserts_1.asserValidOffset)(offset, 4, buff.length);
    return ((buff[offset]) |
        (buff[offset + 1] << 8) |
        (buff[offset + 2] << 16)) +
        (buff[offset + 3] * 0x1000000);
}
exports.readUInt32LE = readUInt32LE;
exports.readUint32BE = readUInt32BE;
function readUInt32BE(buff, offset, noAssert) {
    if (noAssert === void 0) { noAssert = false; }
    offset = offset >>> 0;
    if (!noAssert)
        (0, _asserts_1.asserValidOffset)(offset, 4, buff.length);
    return (buff[offset] * 0x1000000) +
        ((buff[offset + 1] << 16) |
            (buff[offset + 2] << 8) |
            buff[offset + 3]);
}
exports.readUInt32BE = readUInt32BE;
function readBigUInt64LE(buff, offset) {
    offset = offset >>> 0;
    (0, _asserts_1.assertNum)(offset);
    var first = buff[offset];
    var last = buff[offset + 7];
    if (first === undefined || last === undefined) {
        (0, _asserts_1.assertInBound)(offset, buff.length - 8);
    }
    var lo = first +
        buff[++offset] * Math.pow(2, 8) +
        buff[++offset] * Math.pow(2, 16) +
        buff[++offset] * Math.pow(2, 24);
    var hi = buff[++offset] +
        buff[++offset] * Math.pow(2, 8) +
        buff[++offset] * Math.pow(2, 16) +
        last * Math.pow(2, 24);
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
}
exports.readBigUInt64LE = readBigUInt64LE;
function readBigUInt64BE(buff, offset) {
    offset = offset >>> 0;
    (0, _asserts_1.assertNum)(offset);
    var first = buff[offset];
    var last = buff[offset + 7];
    if (first === undefined || last === undefined) {
        (0, _asserts_1.assertInBound)(offset, buff.length - 8);
    }
    var hi = first * Math.pow(2, 24) +
        buff[++offset] * Math.pow(2, 16) +
        buff[++offset] * Math.pow(2, 8) +
        buff[++offset];
    var lo = buff[++offset] * Math.pow(2, 24) +
        buff[++offset] * Math.pow(2, 16) +
        buff[++offset] * Math.pow(2, 8) +
        last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
}
exports.readBigUInt64BE = readBigUInt64BE;
function readIntLE(buff, offset, byteLength, noAssert) {
    if (noAssert === void 0) { noAssert = false; }
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert)
        (0, _asserts_1.asserValidOffset)(offset, byteLength, buff.length);
    var val = buff[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
        val += buff[offset + i] * mul;
    }
    mul *= 0x80;
    if (val >= mul)
        val -= Math.pow(2, 8 * byteLength);
    return val;
}
exports.readIntLE = readIntLE;
function readFloat32BE(buf, offset) {
    var buff = new ArrayBuffer(4);
    var asFloat32 = new Float32Array(buff);
    var asUint8 = new Uint8Array(buff);
    for (var i = offset; i < offset + 4; i++) {
        asUint8[i - offset] = buf[i];
    }
    return asFloat32[0];
}
exports.readFloat32BE = readFloat32BE;
function readFloat64BE(buf, offset) {
    var buff = new ArrayBuffer(8);
    var asFloat64 = new Float64Array(buff);
    var asUint8 = new Uint8Array(buff);
    for (var i = offset; i < offset + 8; i++) {
        asUint8[i - offset] = buf[i];
    }
    return asFloat64[0];
}
exports.readFloat64BE = readFloat64BE;
