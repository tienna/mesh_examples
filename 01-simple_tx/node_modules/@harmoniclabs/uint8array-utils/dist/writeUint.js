"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeFloat64BE = exports.writeBigUInt64BE = exports.writeBigUInt64LE = exports.writeUInt32BE = exports.writeUint32BE = exports.writeUInt32LE = exports.writeUint32LE = exports.writeUInt16BE = exports.writeUint16BE = exports.writeUInt16LE = exports.writeUint16LE = exports.writeUInt8 = exports.writeUint8 = exports.writeUIntBE = exports.writeUintBE = exports.writeUIntLE = exports.writeUintLE = void 0;
var _asserts_1 = require("./_asserts.js");
var errors = __importStar(require("./errors.js"));
function checkInt(buf, value, offset, ext, max, min) {
    if (!(buf instanceof Uint8Array))
        throw new TypeError('"buffer" argument must be an Uint8Array instance');
    if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
        throw new RangeError('Index out of range');
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        var n = typeof min === 'bigint' ? 'n' : '';
        var range = void 0;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) {
                range = ">= 0".concat(n, " and < 2").concat(n, " ** ").concat((byteLength + 1) * 8).concat(n);
            }
            else {
                range = ">= -(2".concat(n, " ** ").concat((byteLength + 1) * 8 - 1).concat(n, ") and < 2 ** ") +
                    "".concat((byteLength + 1) * 8 - 1).concat(n);
            }
        }
        else {
            range = ">= ".concat(min).concat(n, " and <= ").concat(max).concat(n);
        }
        throw new errors.ERR_OUT_OF_RANGE('value', range, value);
    }
    (0, _asserts_1.checkBounds)(buf, offset, byteLength);
}
exports.writeUintLE = writeUIntLE;
function writeUIntLE(buff, value, offset, byteLength, noAssert) {
    if (noAssert === void 0) { noAssert = false; }
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(buff, value, offset, byteLength, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    buff[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
        buff[offset + i] = (value / mul) & 0xFF;
    }
    return offset + byteLength;
}
exports.writeUIntLE = writeUIntLE;
exports.writeUintBE = writeUIntBE;
function writeUIntBE(buff, value, offset, byteLength, noAssert) {
    if (noAssert === void 0) { noAssert = false; }
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(buff, value, offset, byteLength, maxBytes, 0);
    }
    var i = byteLength - 1;
    var mul = 1;
    buff[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
        buff[offset + i] = (value / mul) & 0xFF;
    }
    return offset + byteLength;
}
exports.writeUIntBE = writeUIntBE;
exports.writeUint8 = writeUInt8;
function writeUInt8(buff, value, offset, noAssert) {
    if (noAssert === void 0) { noAssert = false; }
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
        checkInt(buff, value, offset, 1, 0xff, 0);
    buff[offset] = (value & 0xff);
    return offset + 1;
}
exports.writeUInt8 = writeUInt8;
exports.writeUint16LE = writeUInt16LE;
function writeUInt16LE(buff, value, offset, noAssert) {
    if (noAssert === void 0) { noAssert = false; }
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
        checkInt(buff, value, offset, 2, 0xffff, 0);
    buff[offset] = (value & 0xff);
    buff[offset + 1] = (value >>> 8);
    return offset + 2;
}
exports.writeUInt16LE = writeUInt16LE;
exports.writeUint16BE = writeUInt16BE;
function writeUInt16BE(buff, value, offset, noAssert) {
    if (noAssert === void 0) { noAssert = false; }
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
        checkInt(buff, value, offset, 2, 0xffff, 0);
    buff[offset] = (value >>> 8);
    buff[offset + 1] = (value & 0xff);
    return offset + 2;
}
exports.writeUInt16BE = writeUInt16BE;
exports.writeUint32LE = writeUInt32LE;
function writeUInt32LE(buff, value, offset, noAssert) {
    if (noAssert === void 0) { noAssert = false; }
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
        checkInt(buff, value, offset, 4, 0xffffffff, 0);
    buff[offset + 3] = (value >>> 24);
    buff[offset + 2] = (value >>> 16);
    buff[offset + 1] = (value >>> 8);
    buff[offset] = (value & 0xff);
    return offset + 4;
}
exports.writeUInt32LE = writeUInt32LE;
exports.writeUint32BE = writeUInt32BE;
function writeUInt32BE(buff, value, offset, noAssert) {
    if (noAssert === void 0) { noAssert = false; }
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
        checkInt(buff, value, offset, 4, 0xffffffff, 0);
    buff[offset] = (value >>> 24);
    buff[offset + 1] = (value >>> 16);
    buff[offset + 2] = (value >>> 8);
    buff[offset + 3] = (value & 0xff);
    return offset + 4;
}
exports.writeUInt32BE = writeUInt32BE;
function writeBigUInt64LE(buf, value, offset) {
    var min = BigInt(0);
    var max = BigInt('0xffffffffffffffff');
    checkIntBI(value, min, max, buf, offset, 7);
    var lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
exports.writeBigUInt64LE = writeBigUInt64LE;
function writeBigUInt64BE(buf, value, offset) {
    var min = BigInt(0);
    var max = BigInt('0xffffffffffffffff');
    checkIntBI(value, min, max, buf, offset, 7);
    var lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
exports.writeBigUInt64BE = writeBigUInt64BE;
function writeFloat64BE(buf, value, offset) {
    var buff = new ArrayBuffer(8);
    var asFloatArr = new Float64Array(buff);
    asFloatArr[0] = value;
    var asUint8 = new Uint8Array(buff);
    for (var i = 0; i < 8; i++) {
        buf[offset + i] = asUint8[i];
    }
    return offset + 8;
}
exports.writeFloat64BE = writeFloat64BE;
