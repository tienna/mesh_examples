"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bigintToBuffer = exports.bigintFromBuffer = exports.bigintFromBufferLE = exports.log2 = exports.min = exports.max = exports.random = exports.abs = void 0;
var uint8array_utils_1 = require("@harmoniclabs/uint8array-utils");
var assert_1 = require("./utils/assert.js");
/**
 * same as ```Math.abs``` but for bigints
 */
function abs(n) {
    return n < BigInt(0) ? -n : n;
}
exports.abs = abs;
/**
 * @returns {bigint} a ```bigint``` between ```0``` and ```Number.MAX_SAFE_INTEGER``` so that is safe to convert to Number for whatever reason
 */
function random() {
    return BigInt(Math.round(Math.random() * Number.MAX_SAFE_INTEGER));
}
exports.random = random;
function max() {
    var nums = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nums[_i] = arguments[_i];
    }
    return nums.reduce(function (a, b) { return a > b ? a : b; });
}
exports.max = max;
function min() {
    var nums = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        nums[_i] = arguments[_i];
    }
    return nums.reduce(function (a, b) { return a < b ? a : b; });
}
exports.min = min;
function log2(num) {
    if (num === BigInt(0))
        return BigInt(0);
    if (num < BigInt(0))
        return -log2(abs(num));
    var n = BigInt(num);
    var result = BigInt(0);
    while (n >>= BigInt(1))
        result++;
    return result;
}
exports.log2 = log2;
/**
 * uses the bytes of the buffer to construct a BigInteger
 * > **IMPORTANT** the bytes are considered in Little Endian order; use ```bigintFromBuffer``` for Big Endian
 */
function bigintFromBufferLE(buffer) {
    return bigintFromBuffer(
    // need to copy so that it doesn't reverses the original buffer
    Uint8Array.from(buffer)
        .reverse());
}
exports.bigintFromBufferLE = bigintFromBufferLE;
/**
 * converts a Uint8Array to a ```bigint```
 * Big-Endian default
 */
function bigintFromBuffer(buffer) {
    (0, assert_1.assert)((0, uint8array_utils_1.isUint8Array)(buffer), "expected buffer as input, while constructing a bigint instance using bigintFromBufferBE");
    var hexBuff = (0, uint8array_utils_1.toHex)(buffer);
    if (hexBuff.length === 0) {
        return BigInt(0);
    }
    return BigInt("0x".concat(hexBuff));
}
exports.bigintFromBuffer = bigintFromBuffer;
/**
 * converts a ```bigint``` to a ```Uint8Array``` of length ```nBytes``` given as second argument
 *
 * if ```nBytes``` is not specified the Uint8Array takes only the bytes needed
 * @param bigint
 * @param nBytes
 * @returns
 */
function bigintToBuffer(bigint, nBytes) {
    if (nBytes === void 0) { nBytes = undefined; }
    (0, assert_1.assert)(bigint >= BigInt(0), "cannot convert negative bigint to buffer");
    if (bigint == BigInt(0)) {
        if (nBytes === undefined) {
            return Uint8Array.from([]);
        }
        return new Uint8Array(nBytes);
    }
    var buffHexString = bigint.toString(16);
    buffHexString = buffHexString.length % 2 === 0 ? buffHexString : '0' + buffHexString;
    if (nBytes !== undefined) {
        (0, assert_1.assert)(Math.round(Math.abs(nBytes)) === nBytes, "cannot construct a buffer of length " + nBytes + ", while using bigintToBufferOfNBytesBE");
        // pads with zeroes so that the final length is of nBytes*2 (2 hex digits per byte)
        // String.prototype.padStart docs: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart
        buffHexString = buffHexString.padStart(nBytes * 2, "00");
        if (buffHexString.length > nBytes * 2) {
            console.warn("required buffer size is smaller than the one used effectively by the given bigint, truncating the initial bytes as overflow");
            buffHexString = buffHexString.slice(buffHexString.length - (nBytes * 2));
        }
    }
    return (0, uint8array_utils_1.fromHex)(buffHexString);
}
exports.bigintToBuffer = bigintToBuffer;
